{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Charli3 Dendrite Documentation","text":"<p>Get ready to dive into the incredible world of decentralized exchanges (DEXs) on the Cardano blockchain! With Charli3 Dendrite, we've integrated some of the most exciting and innovative DEXs out there, each offering unique features that are transforming the way we trade and manage liquidity on Cardano.</p>"},{"location":"#supported-dexs","title":"Supported DEXs","text":""},{"location":"#vyfi","title":"Vyfi","text":"<ul> <li>VyFi (VyFinance) is nothing short of a game-changer on Cardano! This all-in-one DeFi platform delivers a powerhouse of tools, including a top-notch DEX and yield farming opportunities that cater to both newbies and seasoned pros. VyFi is your gateway to unlocking the full potential of DeFi on Cardano!</li> </ul>"},{"location":"#minswap","title":"Minswap","text":"<ul> <li>Minswap is where simplicity meets power on Cardano. As a community-driven AMM DEX, Minswap makes trading tokens and earning rewards a breeze. Whether you're new to DeFi or a veteran, Minswap's user-friendly design and robust features make it an essential stop on your Cardano journey.</li> </ul>"},{"location":"#muesliswap","title":"Muesliswap","text":"<ul> <li>MuesliSwap is not just any DEX; it's a trailblazer as the first order book-based DEX on Cardano! With MuesliSwap, you're in control, placing orders directly on the blockchain for a truly unique and hands-on trading experience. Step away from the AMM crowd and discover the distinct advantages of MuesliSwap!</li> </ul>"},{"location":"#spectrum","title":"Spectrum","text":"<ul> <li>Spectrum (formerly ErgoDEX) is revolutionizing the cross-chain world by seamlessly connecting the Cardano and Ergo blockchains. With Spectrum, you can execute secure and efficient token swaps across networks, expanding your reach and enhancing interoperability like never before. This is the future of cross-chain trading!</li> </ul>"},{"location":"#sundae","title":"Sundae","text":"<ul> <li>SundaeSwap has quickly become a fan favorite among Cardano users, and it's easy to see why! This AMM DEX is as sweet as its name, offering an intuitive interface for token swaps and liquidity provision. SundaeSwap's vibrant community and user-centric approach make it the perfect choice for anyone looking to get the most out of Cardano's DeFi ecosystem.</li> </ul>"},{"location":"#wingriders","title":"Wingriders","text":"<ul> <li>WingRiders takes performance to new heights! This high-speed AMM DEX on Cardano is all about delivering deep liquidity and lightning-fast transaction speeds, making it a go-to platform for traders looking to move large volumes with efficiency and ease. Fly high with WingRiders and experience trading like never before!</li> </ul>"},{"location":"#axo","title":"Axo","text":"<ul> <li>Axo is where advanced trading meets cutting-edge technology on Cardano. Designed for the serious trader, Axo offers customizable strategies and high-performance order execution that cater to both retail and institutional users. If you're looking to elevate your trading game, Axo is your new best friend!</li> </ul>"},{"location":"#genius-yield","title":"Genius Yield","text":"<ul> <li>Genius Yield is not just a DEX; it's a smart liquidity management powerhouse on Cardano! By combining a DEX with intelligent yield optimization, Genius Yield helps you maximize your returns while enjoying a seamless and sophisticated trading experience. Get ready to be amazed by the future of DeFi with Genius Yield!</li> </ul>"},{"location":"#special-thanks","title":"Special Thanks","text":"<p>A huge shoutout to SteelSwap for their incredible collaboration and unwavering support in making Charli3 Dendrite a reality. SteelSwap has been a cornerstone in this project, and we couldn't have done it without them. Here's to the exciting future we're building together!</p>"},{"location":"amm_base/","title":"Amm base","text":"<p>Module providing base classes for AMM pools.</p>"},{"location":"amm_base/#charli3_dendrite.dexs.amm.amm_base.AbstractPoolState","title":"<code>AbstractPoolState</code>","text":"<p>               Bases: <code>AbstractPairState</code></p> <p>Abstract class representing the state of a pool in an exchange.</p> Source code in <code>src/charli3_dendrite/dexs/amm/amm_base.py</code> <pre><code>class AbstractPoolState(AbstractPairState):\n    \"\"\"Abstract class representing the state of a pool in an exchange.\"\"\"\n\n    datum_cbor: str\n    datum_hash: str\n    inactive: bool = False\n    lp_tokens: Assets | None = None\n    pool_nft: Assets | None = None\n    tx_index: int\n    tx_hash: str\n\n    _batcher_fee: Assets\n    _datum_parsed: PlutusData | None = None\n    _deposit: Assets\n    _volume_fee: int | None = None\n\n    @property\n    @abstractmethod\n    def pool_id(self) -&gt; str:\n        \"\"\"A unique identifier for the pool.\n\n        This is a unique string differentiating this pool from every other pool on the\n        dex, and is necessary for dexs that have more than one pool for a pair but with\n        different fee structures.\n        \"\"\"\n        msg = \"Unique pool id is not specified.\"\n        raise NotImplementedError(msg)\n\n    @classmethod\n    @abstractmethod\n    def pool_datum_class(cls) -&gt; type[PlutusData]:\n        \"\"\"The class type for the pool datum.\n\n        This property should be implemented to return the specific PlutusData subclass\n        that represents the datum for the pool.\n\n        Returns:\n            type[PlutusData]: The class type for the pool datum.\n        \"\"\"\n        raise NotImplementedError\n\n    @property\n    def pool_datum(self) -&gt; PlutusData:\n        \"\"\"The pool state datum.\"\"\"\n        return self.pool_datum_class().from_cbor(self.datum_cbor)\n\n    def swap_datum(  # noqa: PLR0913\n        self,\n        address_source: Address,\n        in_assets: Assets,\n        out_assets: Assets,\n        extra_assets: Assets | None = None,\n        address_target: Address | None = None,\n        datum_target: PlutusData | None = None,\n    ) -&gt; PlutusData:\n        \"\"\"Create a swap datum for the pool.\n\n        Args:\n            address_source (Address): The source address for the swap.\n            in_assets (Assets): The assets being swapped in.\n            out_assets (Assets): The assets being swapped out.\n            extra_assets (Assets | None, optional): Any additional assets involved.\n            Defaults to None.\n            address_target (Address | None, optional): The target address for the swap.\n            Defaults to None.\n            datum_target (PlutusData | None, optional): The target datum for the swap.\n            Defaults to None.\n\n        Returns:\n            PlutusData: The created swap datum.\n\n        Raises:\n            ValueError: If more than one asset is supplied as input or output.\n        \"\"\"\n        if self.swap_forward and address_target is not None:\n            print(  # noqa: T201\n                f\"{self.__class__.__name__} does not support swap forwarding.\",\n            )\n\n        return self.order_datum_class().create_datum(\n            address_source=address_source,\n            in_assets=in_assets,\n            out_assets=out_assets,\n            batcher_fee=self.batcher_fee(\n                in_assets=in_assets,\n                out_assets=out_assets,\n                extra_assets=extra_assets,\n            ),\n            deposit=self.deposit(in_assets=in_assets, out_assets=out_assets),\n            address_target=address_target,\n            datum_target=datum_target,\n        )\n\n    def swap_utxo(  # noqa: PLR0913\n        self,\n        address_source: Address,\n        in_assets: Assets,\n        out_assets: Assets,\n        extra_assets: Assets | None = None,\n        address_target: Address | None = None,\n        datum_target: PlutusData | None = None,\n    ) -&gt; TransactionOutput:\n        \"\"\"Create a swap UTXO for the pool.\n\n        Args:\n            address_source (Address): The source address for the swap.\n            in_assets (Assets): The assets being swapped in.\n            out_assets (Assets): The assets being swapped out.\n            extra_assets (Assets | None, optional): Any additional assets involved.\n            Defaults to None.\n            address_target (Address | None, optional): The target address for the swap.\n            Defaults to None.\n            datum_target (PlutusData | None, optional): The target datum for the swap.\n            Defaults to None.\n\n        Returns:\n            tuple[TransactionOutput, PlutusData]: A tuple containing the created\n            transaction output and the swap datum.\n\n        Raises:\n            ValueError: If more than one asset is supplied as input or output.\n        \"\"\"\n        # Basic checks\n        if len(in_assets) != 1 or len(out_assets) != 1:\n            raise ValueError(\n                \"Only one asset can be supplied as input, \"\n                + \"and one asset supplied as output.\",\n            )\n\n        order_datum = self.swap_datum(\n            address_source=address_source,\n            in_assets=in_assets,\n            out_assets=out_assets,\n            extra_assets=extra_assets,\n            address_target=address_target,\n            datum_target=datum_target,\n        )\n\n        in_assets.root[\"lovelace\"] = (\n            in_assets[\"lovelace\"]\n            + self.batcher_fee(\n                in_assets=in_assets,\n                out_assets=out_assets,\n                extra_assets=extra_assets,\n            ).quantity()\n            + self.deposit(in_assets=in_assets, out_assets=out_assets).quantity()\n        )\n\n        if self.inline_datum:\n            output = TransactionOutput(\n                address=self.stake_address,\n                amount=asset_to_value(in_assets),\n                datum=order_datum,\n            )\n        else:\n            output = TransactionOutput(\n                address=self.stake_address,\n                amount=asset_to_value(in_assets),\n                datum_hash=order_datum.hash(),\n            )\n\n        return output, order_datum\n\n    @classmethod\n    def pool_policy(cls) -&gt; list[str] | None:\n        \"\"\"The pool nft policies.\n\n        This should be the policy or policy+name of any pool nft policy that might be\n        in the pool. Each pool must contain one of the NFTs in the list, and if this\n        is None then no pool NFT check is made.\n\n        By default, no pool policy is defined.\n\n        Returns:\n            Optional[List[str]]: list of policy or policy+name of pool nfts or None\n        \"\"\"\n        return None\n\n    @classmethod\n    def lp_policy(cls) -&gt; list[str] | None:\n        \"\"\"The lp token policies.\n\n        Some dexs store staked lp tokens in the pool, and this definition is needed to\n        filter out tokens from the assets.\n\n        This should be the policy or policy+name of lp pool lp policy that might be\n        in the pool. Each pool must contain one of the NFTs in the list, and if this\n        is None then no lp token check is made.\n\n        By default, no pool policy is defined.\n\n        Returns:\n            Optional[str]: policy or policy+name of lp tokens\n        \"\"\"\n        return None\n\n    @classmethod\n    def extract_dex_nft(cls, values: dict[str, Any]) -&gt; Assets | None:\n        \"\"\"Extract the dex nft from the UTXO.\n\n        Some DEXs put a DEX nft into the pool UTXO.\n\n        This function checks to see if the DEX nft is in the UTXO if the DEX policy is\n        defined.\n\n        If the dex nft is in the values, this value is skipped because it is assumed\n        that this utxo has already been parsed.\n\n        Args:\n            values: The pool UTXO inputs.\n\n        Returns:\n            Assets: None or the dex nft.\n        \"\"\"\n        assets = values[\"assets\"]\n        dex_policy = cls.dex_policy()\n\n        # If no dex policy id defined, return nothing\n        if dex_policy is None:\n            dex_nft = None\n\n        # If the dex nft is in the values, it's been parsed already\n        elif \"dex_nft\" in values:\n            if not any(\n                any(p.startswith(d) for d in dex_policy) for p in values[\"dex_nft\"]\n            ):\n                msg = \"Invalid DEX NFT\"\n                raise NotAPoolError(msg)\n            dex_nft = values[\"dex_nft\"]\n\n        # Check for the dex nft\n        else:\n            nfts = [\n                asset\n                for asset in assets\n                if any(asset.startswith(policy) for policy in dex_policy)\n            ]\n            if len(nfts) &lt; 1:\n                msg = f\"{cls.__name__}: Pool must have one DEX NFT token.\"\n                raise NotAPoolError(\n                    msg,\n                )\n            dex_nft = Assets(**{nfts[0]: assets.root.pop(nfts[0])})\n            values[\"dex_nft\"] = dex_nft\n\n        return dex_nft\n\n    @classmethod\n    def extract_pool_nft(cls, values: dict[str, Any]) -&gt; Assets | None:\n        \"\"\"Extract the pool nft from the UTXO.\n\n        Some DEXs put a pool nft into the pool UTXO.\n\n        This function checks to see if the pool nft is in the UTXO if the DEX policy is\n        defined.\n\n        If the pool nft is in the values, this value is skipped because it is assumed\n        that this utxo has already been parsed.\n\n        Args:\n            values: The pool UTXO inputs.\n\n        Returns:\n            Assets: None or the pool nft.\n        \"\"\"\n        assets = values[\"assets\"]\n        pool_policy = cls.pool_policy()\n\n        # If no pool policy id defined, return nothing\n        if pool_policy is None:\n            return None\n\n        # If the pool nft is in the values, it's been parsed already\n        if \"pool_nft\" in values:\n            if not any(\n                any(p.startswith(d) for d in pool_policy) for p in values[\"pool_nft\"]\n            ):\n                msg = f\"{cls.__name__}: Invalid pool NFT: {values}\"\n                raise InvalidPoolError(msg)\n            pool_nft = Assets(\n                **dict(values[\"pool_nft\"].items()),\n            )\n\n        # Check for the pool nft\n        else:\n            nfts = [\n                asset\n                for asset in assets\n                if any(asset.startswith(policy) for policy in pool_policy)\n            ]\n\n            if len(nfts) != 1:\n                msg = f\"{cls.__name__}: A pool must have one pool NFT token.\"\n                raise InvalidPoolError(\n                    msg,\n                )\n            pool_nft = Assets(**{nfts[0]: assets.root.pop(nfts[0])})\n            values[\"pool_nft\"] = pool_nft\n\n        assets = values[\"assets\"]\n        pool_id = pool_nft.unit()[len(pool_policy) :]\n        lps = [asset for asset in assets if asset.endswith(pool_id)]\n        for lp in lps:\n            assets.root.pop(lp)\n\n        return pool_nft\n\n    @classmethod\n    def extract_lp_tokens(cls, values: dict[str, Any]) -&gt; Assets | None:\n        \"\"\"Extract the lp tokens from the UTXO.\n\n        Some DEXs put lp tokens into the pool UTXO.\n\n        Args:\n            values: The pool UTXO inputs.\n\n        Returns:\n            Assets: None or the pool nft.\n        \"\"\"\n        assets = values[\"assets\"]\n        lp_policy = cls.lp_policy()\n\n        # If no pool policy id defined, return nothing\n        if lp_policy is None:\n            return None\n\n        # If the pool nft is in the values, it's been parsed already\n        if \"lp_tokens\" in values:\n            if values[\"lp_tokens\"] is not None and not any(\n                any(p.startswith(d) for d in lp_policy) for p in values[\"lp_tokens\"]\n            ):\n                msg = f\"{cls.__name__}: Pool has invalid LP tokens.\"\n                raise InvalidPoolError(\n                    msg,\n                )\n            lp_tokens = values[\"lp_tokens\"]\n\n        # Check for the pool nft\n        else:\n            nfts = [\n                asset\n                for asset in assets\n                if any(asset.startswith(policy) for policy in lp_policy)\n            ]\n            if len(nfts) &gt; 0:\n                lp_tokens = Assets(**{nfts[0]: assets.root.pop(nfts[0])})\n                values[\"lp_tokens\"] = lp_tokens\n            else:\n                lp_tokens = None\n                values[\"lp_tokens\"] = None\n\n        return lp_tokens\n\n    @classmethod\n    def skip_init(cls, values: dict[str, Any]) -&gt; bool:  # noqa: ARG003\n        \"\"\"An initial check to determine if parsing should be carried out.\n\n        Args:\n            values: The pool initialization parameters.\n\n        Returns:\n            bool: If this returns True, initialization checks will get skipped.\n        \"\"\"\n        return False\n\n    @classmethod\n    def post_init(cls, values: dict[str, Any]) -&gt; dict[str, Any]:\n        \"\"\"Post initialization checks.\n\n        Args:\n            values: The pool initialization parameters\n        \"\"\"\n        assets = values[\"assets\"]\n        non_ada_assets = [a for a in assets if a != \"lovelace\"]\n\n        if len(assets) == ASSET_COUNT_TWO:\n            if len(non_ada_assets) != ASSET_COUNT_ONE:\n                error_msg = f\"Pool must only have 1 non-ADA asset: {values}\"\n                raise InvalidPoolError(error_msg)\n\n        elif len(assets) == ASSET_COUNT_THREE:\n            if len(non_ada_assets) != ASSET_COUNT_TWO:\n                error_msg = f\"Pool must only have 2 non-ADA assets: {values}\"\n                raise InvalidPoolError(error_msg)\n\n            # Send the ADA token to the end\n            values[\"assets\"].root[\"lovelace\"] = values[\"assets\"].root.pop(\"lovelace\")\n\n        else:\n            if len(assets) == 1 and \"lovelace\" in assets:\n                msg = f\"Invalid pool, only contains lovelace: assets={assets}\"\n                raise NoAssetsError(\n                    msg,\n                )\n            msg = (\n                f\"Pool must have 2 or 3 assets except factor, NFT, and LP tokens: \"\n                f\"assets={assets}\"\n            )\n            raise InvalidPoolError(\n                msg,\n            )\n        return values\n\n    @model_validator(mode=\"before\")\n    def translate_address(cls, values: dict[str, Any]) -&gt; dict[str, Any]:\n        \"\"\"The main validation function called when initialized.\n\n        Args:\n            values: The pool initialization values.\n\n        Returns:\n            The parsed/modified pool initialization values.\n        \"\"\"\n        if \"assets\" in values:\n            if values[\"assets\"] is None:\n                msg = \"No assets in the pool.\"\n                raise NoAssetsError(msg)\n            if not isinstance(values[\"assets\"], Assets):\n                values[\"assets\"] = Assets(**values[\"assets\"])\n\n        if cls.skip_init(values):\n            return values\n\n        # Parse the pool datum\n        try:\n            datum = cls.pool_datum_class().from_cbor(values[\"datum_cbor\"])\n        except (DeserializeException, TypeError) as e:\n            msg = (\n                \"Pool datum could not be deserialized: \\n \"\n                + f\" error={e}\\n\"\n                + f\"   tx_hash={values['tx_hash']}\\n\"\n                + f\"    datum={values['datum_cbor']}\\n\"\n            )\n            raise NotAPoolError(msg) from e\n\n        # To help prevent edge cases, remove pool tokens while running other checks\n        pair = Assets({})\n        if datum.pool_pair() is not None:\n            for token in datum.pool_pair():\n                try:\n                    pair.root.update({token: values[\"assets\"].root.pop(token)})\n                except KeyError:\n                    msg = (\n                        \"Pool does not contain expected asset.\\n\"\n                        + f\"    Expected: {token}\\n\"\n                        + f\"    Actual: {values['assets']}\"\n                    )\n                    raise InvalidPoolError(msg) from KeyError\n\n        _ = cls.extract_dex_nft(values)\n\n        _ = cls.extract_lp_tokens(values)\n\n        _ = cls.extract_pool_nft(values)\n\n        # Add the pool tokens back in\n        values[\"assets\"].root.update(pair.root)\n\n        cls.post_init(values)\n\n        return values\n\n    @property\n    def price(self) -&gt; tuple[Decimal, Decimal]:\n        \"\"\"Price of assets.\n\n        Returns:\n            A `Tuple[Decimal, Decimal] where the first `Decimal` is the price to buy\n                1 of token B in units of token A, and the second `Decimal` is the price\n                to buy 1 of token A in units of token B.\n        \"\"\"\n        nat_assets = naturalize_assets(self.assets)\n\n        return (\n            (nat_assets[self.unit_a] / nat_assets[self.unit_b]),\n            (nat_assets[self.unit_b] / nat_assets[self.unit_a]),\n        )\n\n    @property\n    def tvl(self) -&gt; Decimal:\n        \"\"\"Return the total value locked for the pool.\n\n        Raises:\n            NotImplementedError: Only ADA pool TVL is implemented.\n        \"\"\"\n        if self.unit_a != \"lovelace\":\n            msg = \"tvl for non-ADA pools is not implemented.\"\n            raise NotImplementedError(msg)\n\n        return 2 * (Decimal(self.reserve_a) / Decimal(10**6)).quantize(\n            1 / Decimal(10**6),\n        )\n</code></pre>"},{"location":"amm_base/#charli3_dendrite.dexs.amm.amm_base.AbstractPoolState.pool_datum","title":"<code>pool_datum: PlutusData</code>  <code>property</code>","text":"<p>The pool state datum.</p>"},{"location":"amm_base/#charli3_dendrite.dexs.amm.amm_base.AbstractPoolState.pool_id","title":"<code>pool_id: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>A unique identifier for the pool.</p> <p>This is a unique string differentiating this pool from every other pool on the dex, and is necessary for dexs that have more than one pool for a pair but with different fee structures.</p>"},{"location":"amm_base/#charli3_dendrite.dexs.amm.amm_base.AbstractPoolState.price","title":"<code>price: tuple[Decimal, Decimal]</code>  <code>property</code>","text":"<p>Price of assets.</p> <p>Returns:</p> Type Description <code>tuple[Decimal, Decimal]</code> <p>A <code>Tuple[Decimal, Decimal] where the first</code>Decimal<code>is the price to buy 1 of token B in units of token A, and the second</code>Decimal` is the price to buy 1 of token A in units of token B.</p>"},{"location":"amm_base/#charli3_dendrite.dexs.amm.amm_base.AbstractPoolState.tvl","title":"<code>tvl: Decimal</code>  <code>property</code>","text":"<p>Return the total value locked for the pool.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Only ADA pool TVL is implemented.</p>"},{"location":"amm_base/#charli3_dendrite.dexs.amm.amm_base.AbstractPoolState.extract_dex_nft","title":"<code>extract_dex_nft(values: dict[str, Any]) -&gt; Assets | None</code>  <code>classmethod</code>","text":"<p>Extract the dex nft from the UTXO.</p> <p>Some DEXs put a DEX nft into the pool UTXO.</p> <p>This function checks to see if the DEX nft is in the UTXO if the DEX policy is defined.</p> <p>If the dex nft is in the values, this value is skipped because it is assumed that this utxo has already been parsed.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>dict[str, Any]</code> <p>The pool UTXO inputs.</p> required <p>Returns:</p> Name Type Description <code>Assets</code> <code>Assets | None</code> <p>None or the dex nft.</p> Source code in <code>src/charli3_dendrite/dexs/amm/amm_base.py</code> <pre><code>@classmethod\ndef extract_dex_nft(cls, values: dict[str, Any]) -&gt; Assets | None:\n    \"\"\"Extract the dex nft from the UTXO.\n\n    Some DEXs put a DEX nft into the pool UTXO.\n\n    This function checks to see if the DEX nft is in the UTXO if the DEX policy is\n    defined.\n\n    If the dex nft is in the values, this value is skipped because it is assumed\n    that this utxo has already been parsed.\n\n    Args:\n        values: The pool UTXO inputs.\n\n    Returns:\n        Assets: None or the dex nft.\n    \"\"\"\n    assets = values[\"assets\"]\n    dex_policy = cls.dex_policy()\n\n    # If no dex policy id defined, return nothing\n    if dex_policy is None:\n        dex_nft = None\n\n    # If the dex nft is in the values, it's been parsed already\n    elif \"dex_nft\" in values:\n        if not any(\n            any(p.startswith(d) for d in dex_policy) for p in values[\"dex_nft\"]\n        ):\n            msg = \"Invalid DEX NFT\"\n            raise NotAPoolError(msg)\n        dex_nft = values[\"dex_nft\"]\n\n    # Check for the dex nft\n    else:\n        nfts = [\n            asset\n            for asset in assets\n            if any(asset.startswith(policy) for policy in dex_policy)\n        ]\n        if len(nfts) &lt; 1:\n            msg = f\"{cls.__name__}: Pool must have one DEX NFT token.\"\n            raise NotAPoolError(\n                msg,\n            )\n        dex_nft = Assets(**{nfts[0]: assets.root.pop(nfts[0])})\n        values[\"dex_nft\"] = dex_nft\n\n    return dex_nft\n</code></pre>"},{"location":"amm_base/#charli3_dendrite.dexs.amm.amm_base.AbstractPoolState.extract_lp_tokens","title":"<code>extract_lp_tokens(values: dict[str, Any]) -&gt; Assets | None</code>  <code>classmethod</code>","text":"<p>Extract the lp tokens from the UTXO.</p> <p>Some DEXs put lp tokens into the pool UTXO.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>dict[str, Any]</code> <p>The pool UTXO inputs.</p> required <p>Returns:</p> Name Type Description <code>Assets</code> <code>Assets | None</code> <p>None or the pool nft.</p> Source code in <code>src/charli3_dendrite/dexs/amm/amm_base.py</code> <pre><code>@classmethod\ndef extract_lp_tokens(cls, values: dict[str, Any]) -&gt; Assets | None:\n    \"\"\"Extract the lp tokens from the UTXO.\n\n    Some DEXs put lp tokens into the pool UTXO.\n\n    Args:\n        values: The pool UTXO inputs.\n\n    Returns:\n        Assets: None or the pool nft.\n    \"\"\"\n    assets = values[\"assets\"]\n    lp_policy = cls.lp_policy()\n\n    # If no pool policy id defined, return nothing\n    if lp_policy is None:\n        return None\n\n    # If the pool nft is in the values, it's been parsed already\n    if \"lp_tokens\" in values:\n        if values[\"lp_tokens\"] is not None and not any(\n            any(p.startswith(d) for d in lp_policy) for p in values[\"lp_tokens\"]\n        ):\n            msg = f\"{cls.__name__}: Pool has invalid LP tokens.\"\n            raise InvalidPoolError(\n                msg,\n            )\n        lp_tokens = values[\"lp_tokens\"]\n\n    # Check for the pool nft\n    else:\n        nfts = [\n            asset\n            for asset in assets\n            if any(asset.startswith(policy) for policy in lp_policy)\n        ]\n        if len(nfts) &gt; 0:\n            lp_tokens = Assets(**{nfts[0]: assets.root.pop(nfts[0])})\n            values[\"lp_tokens\"] = lp_tokens\n        else:\n            lp_tokens = None\n            values[\"lp_tokens\"] = None\n\n    return lp_tokens\n</code></pre>"},{"location":"amm_base/#charli3_dendrite.dexs.amm.amm_base.AbstractPoolState.extract_pool_nft","title":"<code>extract_pool_nft(values: dict[str, Any]) -&gt; Assets | None</code>  <code>classmethod</code>","text":"<p>Extract the pool nft from the UTXO.</p> <p>Some DEXs put a pool nft into the pool UTXO.</p> <p>This function checks to see if the pool nft is in the UTXO if the DEX policy is defined.</p> <p>If the pool nft is in the values, this value is skipped because it is assumed that this utxo has already been parsed.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>dict[str, Any]</code> <p>The pool UTXO inputs.</p> required <p>Returns:</p> Name Type Description <code>Assets</code> <code>Assets | None</code> <p>None or the pool nft.</p> Source code in <code>src/charli3_dendrite/dexs/amm/amm_base.py</code> <pre><code>@classmethod\ndef extract_pool_nft(cls, values: dict[str, Any]) -&gt; Assets | None:\n    \"\"\"Extract the pool nft from the UTXO.\n\n    Some DEXs put a pool nft into the pool UTXO.\n\n    This function checks to see if the pool nft is in the UTXO if the DEX policy is\n    defined.\n\n    If the pool nft is in the values, this value is skipped because it is assumed\n    that this utxo has already been parsed.\n\n    Args:\n        values: The pool UTXO inputs.\n\n    Returns:\n        Assets: None or the pool nft.\n    \"\"\"\n    assets = values[\"assets\"]\n    pool_policy = cls.pool_policy()\n\n    # If no pool policy id defined, return nothing\n    if pool_policy is None:\n        return None\n\n    # If the pool nft is in the values, it's been parsed already\n    if \"pool_nft\" in values:\n        if not any(\n            any(p.startswith(d) for d in pool_policy) for p in values[\"pool_nft\"]\n        ):\n            msg = f\"{cls.__name__}: Invalid pool NFT: {values}\"\n            raise InvalidPoolError(msg)\n        pool_nft = Assets(\n            **dict(values[\"pool_nft\"].items()),\n        )\n\n    # Check for the pool nft\n    else:\n        nfts = [\n            asset\n            for asset in assets\n            if any(asset.startswith(policy) for policy in pool_policy)\n        ]\n\n        if len(nfts) != 1:\n            msg = f\"{cls.__name__}: A pool must have one pool NFT token.\"\n            raise InvalidPoolError(\n                msg,\n            )\n        pool_nft = Assets(**{nfts[0]: assets.root.pop(nfts[0])})\n        values[\"pool_nft\"] = pool_nft\n\n    assets = values[\"assets\"]\n    pool_id = pool_nft.unit()[len(pool_policy) :]\n    lps = [asset for asset in assets if asset.endswith(pool_id)]\n    for lp in lps:\n        assets.root.pop(lp)\n\n    return pool_nft\n</code></pre>"},{"location":"amm_base/#charli3_dendrite.dexs.amm.amm_base.AbstractPoolState.lp_policy","title":"<code>lp_policy() -&gt; list[str] | None</code>  <code>classmethod</code>","text":"<p>The lp token policies.</p> <p>Some dexs store staked lp tokens in the pool, and this definition is needed to filter out tokens from the assets.</p> <p>This should be the policy or policy+name of lp pool lp policy that might be in the pool. Each pool must contain one of the NFTs in the list, and if this is None then no lp token check is made.</p> <p>By default, no pool policy is defined.</p> <p>Returns:</p> Type Description <code>list[str] | None</code> <p>Optional[str]: policy or policy+name of lp tokens</p> Source code in <code>src/charli3_dendrite/dexs/amm/amm_base.py</code> <pre><code>@classmethod\ndef lp_policy(cls) -&gt; list[str] | None:\n    \"\"\"The lp token policies.\n\n    Some dexs store staked lp tokens in the pool, and this definition is needed to\n    filter out tokens from the assets.\n\n    This should be the policy or policy+name of lp pool lp policy that might be\n    in the pool. Each pool must contain one of the NFTs in the list, and if this\n    is None then no lp token check is made.\n\n    By default, no pool policy is defined.\n\n    Returns:\n        Optional[str]: policy or policy+name of lp tokens\n    \"\"\"\n    return None\n</code></pre>"},{"location":"amm_base/#charli3_dendrite.dexs.amm.amm_base.AbstractPoolState.pool_datum_class","title":"<code>pool_datum_class() -&gt; type[PlutusData]</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>The class type for the pool datum.</p> <p>This property should be implemented to return the specific PlutusData subclass that represents the datum for the pool.</p> <p>Returns:</p> Type Description <code>type[PlutusData]</code> <p>type[PlutusData]: The class type for the pool datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/amm_base.py</code> <pre><code>@classmethod\n@abstractmethod\ndef pool_datum_class(cls) -&gt; type[PlutusData]:\n    \"\"\"The class type for the pool datum.\n\n    This property should be implemented to return the specific PlutusData subclass\n    that represents the datum for the pool.\n\n    Returns:\n        type[PlutusData]: The class type for the pool datum.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"amm_base/#charli3_dendrite.dexs.amm.amm_base.AbstractPoolState.pool_policy","title":"<code>pool_policy() -&gt; list[str] | None</code>  <code>classmethod</code>","text":"<p>The pool nft policies.</p> <p>This should be the policy or policy+name of any pool nft policy that might be in the pool. Each pool must contain one of the NFTs in the list, and if this is None then no pool NFT check is made.</p> <p>By default, no pool policy is defined.</p> <p>Returns:</p> Type Description <code>list[str] | None</code> <p>Optional[List[str]]: list of policy or policy+name of pool nfts or None</p> Source code in <code>src/charli3_dendrite/dexs/amm/amm_base.py</code> <pre><code>@classmethod\ndef pool_policy(cls) -&gt; list[str] | None:\n    \"\"\"The pool nft policies.\n\n    This should be the policy or policy+name of any pool nft policy that might be\n    in the pool. Each pool must contain one of the NFTs in the list, and if this\n    is None then no pool NFT check is made.\n\n    By default, no pool policy is defined.\n\n    Returns:\n        Optional[List[str]]: list of policy or policy+name of pool nfts or None\n    \"\"\"\n    return None\n</code></pre>"},{"location":"amm_base/#charli3_dendrite.dexs.amm.amm_base.AbstractPoolState.post_init","title":"<code>post_init(values: dict[str, Any]) -&gt; dict[str, Any]</code>  <code>classmethod</code>","text":"<p>Post initialization checks.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>dict[str, Any]</code> <p>The pool initialization parameters</p> required Source code in <code>src/charli3_dendrite/dexs/amm/amm_base.py</code> <pre><code>@classmethod\ndef post_init(cls, values: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Post initialization checks.\n\n    Args:\n        values: The pool initialization parameters\n    \"\"\"\n    assets = values[\"assets\"]\n    non_ada_assets = [a for a in assets if a != \"lovelace\"]\n\n    if len(assets) == ASSET_COUNT_TWO:\n        if len(non_ada_assets) != ASSET_COUNT_ONE:\n            error_msg = f\"Pool must only have 1 non-ADA asset: {values}\"\n            raise InvalidPoolError(error_msg)\n\n    elif len(assets) == ASSET_COUNT_THREE:\n        if len(non_ada_assets) != ASSET_COUNT_TWO:\n            error_msg = f\"Pool must only have 2 non-ADA assets: {values}\"\n            raise InvalidPoolError(error_msg)\n\n        # Send the ADA token to the end\n        values[\"assets\"].root[\"lovelace\"] = values[\"assets\"].root.pop(\"lovelace\")\n\n    else:\n        if len(assets) == 1 and \"lovelace\" in assets:\n            msg = f\"Invalid pool, only contains lovelace: assets={assets}\"\n            raise NoAssetsError(\n                msg,\n            )\n        msg = (\n            f\"Pool must have 2 or 3 assets except factor, NFT, and LP tokens: \"\n            f\"assets={assets}\"\n        )\n        raise InvalidPoolError(\n            msg,\n        )\n    return values\n</code></pre>"},{"location":"amm_base/#charli3_dendrite.dexs.amm.amm_base.AbstractPoolState.skip_init","title":"<code>skip_init(values: dict[str, Any]) -&gt; bool</code>  <code>classmethod</code>","text":"<p>An initial check to determine if parsing should be carried out.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>dict[str, Any]</code> <p>The pool initialization parameters.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>If this returns True, initialization checks will get skipped.</p> Source code in <code>src/charli3_dendrite/dexs/amm/amm_base.py</code> <pre><code>@classmethod\ndef skip_init(cls, values: dict[str, Any]) -&gt; bool:  # noqa: ARG003\n    \"\"\"An initial check to determine if parsing should be carried out.\n\n    Args:\n        values: The pool initialization parameters.\n\n    Returns:\n        bool: If this returns True, initialization checks will get skipped.\n    \"\"\"\n    return False\n</code></pre>"},{"location":"amm_base/#charli3_dendrite.dexs.amm.amm_base.AbstractPoolState.swap_datum","title":"<code>swap_datum(address_source: Address, in_assets: Assets, out_assets: Assets, extra_assets: Assets | None = None, address_target: Address | None = None, datum_target: PlutusData | None = None) -&gt; PlutusData</code>","text":"<p>Create a swap datum for the pool.</p> <p>Parameters:</p> Name Type Description Default <code>address_source</code> <code>Address</code> <p>The source address for the swap.</p> required <code>in_assets</code> <code>Assets</code> <p>The assets being swapped in.</p> required <code>out_assets</code> <code>Assets</code> <p>The assets being swapped out.</p> required <code>extra_assets</code> <code>Assets | None</code> <p>Any additional assets involved.</p> <code>None</code> <code>address_target</code> <code>Address | None</code> <p>The target address for the swap.</p> <code>None</code> <code>datum_target</code> <code>PlutusData | None</code> <p>The target datum for the swap.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>PlutusData</code> <code>PlutusData</code> <p>The created swap datum.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If more than one asset is supplied as input or output.</p> Source code in <code>src/charli3_dendrite/dexs/amm/amm_base.py</code> <pre><code>def swap_datum(  # noqa: PLR0913\n    self,\n    address_source: Address,\n    in_assets: Assets,\n    out_assets: Assets,\n    extra_assets: Assets | None = None,\n    address_target: Address | None = None,\n    datum_target: PlutusData | None = None,\n) -&gt; PlutusData:\n    \"\"\"Create a swap datum for the pool.\n\n    Args:\n        address_source (Address): The source address for the swap.\n        in_assets (Assets): The assets being swapped in.\n        out_assets (Assets): The assets being swapped out.\n        extra_assets (Assets | None, optional): Any additional assets involved.\n        Defaults to None.\n        address_target (Address | None, optional): The target address for the swap.\n        Defaults to None.\n        datum_target (PlutusData | None, optional): The target datum for the swap.\n        Defaults to None.\n\n    Returns:\n        PlutusData: The created swap datum.\n\n    Raises:\n        ValueError: If more than one asset is supplied as input or output.\n    \"\"\"\n    if self.swap_forward and address_target is not None:\n        print(  # noqa: T201\n            f\"{self.__class__.__name__} does not support swap forwarding.\",\n        )\n\n    return self.order_datum_class().create_datum(\n        address_source=address_source,\n        in_assets=in_assets,\n        out_assets=out_assets,\n        batcher_fee=self.batcher_fee(\n            in_assets=in_assets,\n            out_assets=out_assets,\n            extra_assets=extra_assets,\n        ),\n        deposit=self.deposit(in_assets=in_assets, out_assets=out_assets),\n        address_target=address_target,\n        datum_target=datum_target,\n    )\n</code></pre>"},{"location":"amm_base/#charli3_dendrite.dexs.amm.amm_base.AbstractPoolState.swap_utxo","title":"<code>swap_utxo(address_source: Address, in_assets: Assets, out_assets: Assets, extra_assets: Assets | None = None, address_target: Address | None = None, datum_target: PlutusData | None = None) -&gt; TransactionOutput</code>","text":"<p>Create a swap UTXO for the pool.</p> <p>Parameters:</p> Name Type Description Default <code>address_source</code> <code>Address</code> <p>The source address for the swap.</p> required <code>in_assets</code> <code>Assets</code> <p>The assets being swapped in.</p> required <code>out_assets</code> <code>Assets</code> <p>The assets being swapped out.</p> required <code>extra_assets</code> <code>Assets | None</code> <p>Any additional assets involved.</p> <code>None</code> <code>address_target</code> <code>Address | None</code> <p>The target address for the swap.</p> <code>None</code> <code>datum_target</code> <code>PlutusData | None</code> <p>The target datum for the swap.</p> <code>None</code> <p>Returns:</p> Type Description <code>TransactionOutput</code> <p>tuple[TransactionOutput, PlutusData]: A tuple containing the created</p> <code>TransactionOutput</code> <p>transaction output and the swap datum.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If more than one asset is supplied as input or output.</p> Source code in <code>src/charli3_dendrite/dexs/amm/amm_base.py</code> <pre><code>def swap_utxo(  # noqa: PLR0913\n    self,\n    address_source: Address,\n    in_assets: Assets,\n    out_assets: Assets,\n    extra_assets: Assets | None = None,\n    address_target: Address | None = None,\n    datum_target: PlutusData | None = None,\n) -&gt; TransactionOutput:\n    \"\"\"Create a swap UTXO for the pool.\n\n    Args:\n        address_source (Address): The source address for the swap.\n        in_assets (Assets): The assets being swapped in.\n        out_assets (Assets): The assets being swapped out.\n        extra_assets (Assets | None, optional): Any additional assets involved.\n        Defaults to None.\n        address_target (Address | None, optional): The target address for the swap.\n        Defaults to None.\n        datum_target (PlutusData | None, optional): The target datum for the swap.\n        Defaults to None.\n\n    Returns:\n        tuple[TransactionOutput, PlutusData]: A tuple containing the created\n        transaction output and the swap datum.\n\n    Raises:\n        ValueError: If more than one asset is supplied as input or output.\n    \"\"\"\n    # Basic checks\n    if len(in_assets) != 1 or len(out_assets) != 1:\n        raise ValueError(\n            \"Only one asset can be supplied as input, \"\n            + \"and one asset supplied as output.\",\n        )\n\n    order_datum = self.swap_datum(\n        address_source=address_source,\n        in_assets=in_assets,\n        out_assets=out_assets,\n        extra_assets=extra_assets,\n        address_target=address_target,\n        datum_target=datum_target,\n    )\n\n    in_assets.root[\"lovelace\"] = (\n        in_assets[\"lovelace\"]\n        + self.batcher_fee(\n            in_assets=in_assets,\n            out_assets=out_assets,\n            extra_assets=extra_assets,\n        ).quantity()\n        + self.deposit(in_assets=in_assets, out_assets=out_assets).quantity()\n    )\n\n    if self.inline_datum:\n        output = TransactionOutput(\n            address=self.stake_address,\n            amount=asset_to_value(in_assets),\n            datum=order_datum,\n        )\n    else:\n        output = TransactionOutput(\n            address=self.stake_address,\n            amount=asset_to_value(in_assets),\n            datum_hash=order_datum.hash(),\n        )\n\n    return output, order_datum\n</code></pre>"},{"location":"amm_base/#charli3_dendrite.dexs.amm.amm_base.AbstractPoolState.translate_address","title":"<code>translate_address(values: dict[str, Any]) -&gt; dict[str, Any]</code>","text":"<p>The main validation function called when initialized.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>dict[str, Any]</code> <p>The pool initialization values.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The parsed/modified pool initialization values.</p> Source code in <code>src/charli3_dendrite/dexs/amm/amm_base.py</code> <pre><code>@model_validator(mode=\"before\")\ndef translate_address(cls, values: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"The main validation function called when initialized.\n\n    Args:\n        values: The pool initialization values.\n\n    Returns:\n        The parsed/modified pool initialization values.\n    \"\"\"\n    if \"assets\" in values:\n        if values[\"assets\"] is None:\n            msg = \"No assets in the pool.\"\n            raise NoAssetsError(msg)\n        if not isinstance(values[\"assets\"], Assets):\n            values[\"assets\"] = Assets(**values[\"assets\"])\n\n    if cls.skip_init(values):\n        return values\n\n    # Parse the pool datum\n    try:\n        datum = cls.pool_datum_class().from_cbor(values[\"datum_cbor\"])\n    except (DeserializeException, TypeError) as e:\n        msg = (\n            \"Pool datum could not be deserialized: \\n \"\n            + f\" error={e}\\n\"\n            + f\"   tx_hash={values['tx_hash']}\\n\"\n            + f\"    datum={values['datum_cbor']}\\n\"\n        )\n        raise NotAPoolError(msg) from e\n\n    # To help prevent edge cases, remove pool tokens while running other checks\n    pair = Assets({})\n    if datum.pool_pair() is not None:\n        for token in datum.pool_pair():\n            try:\n                pair.root.update({token: values[\"assets\"].root.pop(token)})\n            except KeyError:\n                msg = (\n                    \"Pool does not contain expected asset.\\n\"\n                    + f\"    Expected: {token}\\n\"\n                    + f\"    Actual: {values['assets']}\"\n                )\n                raise InvalidPoolError(msg) from KeyError\n\n    _ = cls.extract_dex_nft(values)\n\n    _ = cls.extract_lp_tokens(values)\n\n    _ = cls.extract_pool_nft(values)\n\n    # Add the pool tokens back in\n    values[\"assets\"].root.update(pair.root)\n\n    cls.post_init(values)\n\n    return values\n</code></pre>"},{"location":"axo/","title":"Axo","text":"<p>Axo Order Book Module.</p>"},{"location":"axo/#charli3_dendrite.dexs.ob.axo.AxoCreateResponse","title":"<code>AxoCreateResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/charli3_dendrite/dexs/ob/axo.py</code> <pre><code>class AxoCreateResponse(BaseModel):\n    policy_script: str\n    strat_id: str\n    token_name: str\n    datum: str\n    algo_addr: str\n    nft_metadata: dict\n\n    @field_validator(\"nft_metadata\", mode=\"before\")\n    @classmethod\n    def validate_metadata(cls, v: str) -&gt; dict:\n        return json.loads(v)\n\n    @field_validator(\"policy_script\")\n    @classmethod\n    def strip_policy(cls, v: str) -&gt; str:\n        \"\"\"Trim the extra bytes cbor tag off it.\"\"\"\n        return v[6:]\n</code></pre>"},{"location":"axo/#charli3_dendrite.dexs.ob.axo.AxoCreateResponse.strip_policy","title":"<code>strip_policy(v: str) -&gt; str</code>  <code>classmethod</code>","text":"<p>Trim the extra bytes cbor tag off it.</p> Source code in <code>src/charli3_dendrite/dexs/ob/axo.py</code> <pre><code>@field_validator(\"policy_script\")\n@classmethod\ndef strip_policy(cls, v: str) -&gt; str:\n    \"\"\"Trim the extra bytes cbor tag off it.\"\"\"\n    return v[6:]\n</code></pre>"},{"location":"axo/#charli3_dendrite.dexs.ob.axo.AxoOBMarketState","title":"<code>AxoOBMarketState</code>","text":"<p>               Bases: <code>AbstractOrderBookState</code></p> Source code in <code>src/charli3_dendrite/dexs/ob/axo.py</code> <pre><code>class AxoOBMarketState(AbstractOrderBookState):\n    fee: int = 10\n    spot: float = 1\n    plutus_v2: bool = True\n    inactive: bool = False\n    _stake_address: ClassVar[Address] = Address.decode(\n        \"addr1z92l7rnra7sxjn5qv5fzc4fwsrrm29mgkleqj9a0y46j5lrryf9mtf9layje8u7u7wmap6alr28l90ry5t9nlyldjjsse4mxc9\",\n    )\n    _client: ClassVar[AxoAPIClient] = AxoAPIClient()\n    _reference_utxo: ClassVar[UTxO | None] = None\n    _deposit: Assets = Assets(lovelace=8000000)\n\n    @classmethod\n    def dex(cls) -&gt; str:\n        return \"Axo\"\n\n    @classmethod\n    def order_selector(self) -&gt; list[str]:\n        \"\"\"Order selection information.\"\"\"\n        addresses = [\n            \"addr1z92l7rnra7sxjn5qv5fzc4fwsrrm29mgkleqj9a0y46j5lrryf9mtf9layje8u7u7wmap6alr28l90ry5t9nlyldjjsse4mxc9\",\n        ]\n        return addresses\n\n    @classmethod\n    def pool_selector(self) -&gt; PoolSelector:\n        \"\"\"Pool selection information.\"\"\"\n        return []\n\n    @property\n    def swap_forward(self) -&gt; bool:\n        return False\n\n    @classmethod\n    def default_script_class(cls):\n        return PlutusV2Script\n\n    @classmethod\n    def reference_utxo(cls) -&gt; UTxO | None:\n        if cls._reference_utxo is None:\n            script_reference = get_backend().get_script_from_address(cls._stake_address)\n\n            script = cls.default_script_class()(bytes.fromhex(script_reference.script))\n\n            cls._reference_utxo = UTxO(\n                input=TransactionInput(\n                    transaction_id=TransactionId(\n                        bytes.fromhex(\n                            script_reference.tx_hash,\n                        ),\n                    ),\n                    index=script_reference.tx_index,\n                ),\n                output=TransactionOutput(\n                    address=Address.decode(script_reference.address),\n                    amount=asset_to_value(script_reference.assets),\n                    script=script,\n                ),\n            )\n        return cls._reference_utxo\n\n    @classmethod\n    def _process_ob(\n        self,\n        ob: AxoOBResponse,\n    ) -&gt; tuple[list[OrderBookOrder], list[OrderBookOrder]]:\n        prices = get_token_prices(assets=[ob.left, ob.right])\n        left = ob.left if ob.left != \"\" else \"lovelace\"\n        if prices[0].policy_id + prices[0].policy_name == left:\n            token_a_decimals = prices[0].decimals\n            token_b_decimals = prices[1].decimals\n        else:\n            token_a_decimals = prices[1].decimals\n            token_b_decimals = prices[0].decimals\n\n        sell_book = []\n        for index in range(len(ob.sell_side_price)):\n            sell_book.append(\n                OrderBookOrder(\n                    price=ob.sell_side_price[index]\n                    * 10 ** (token_a_decimals - token_b_decimals),\n                    quantity=int(ob.sell_side_amount[index] * 10**token_b_decimals),\n                ),\n            )\n        buy_book = []\n        for index in range(len(ob.buy_side_price)):\n            buy_book.append(\n                OrderBookOrder(\n                    price=ob.buy_side_price[index] ** -1\n                    * 10 ** (token_b_decimals - token_a_decimals),\n                    quantity=int(\n                        ob.buy_side_amount[index]\n                        * 10**token_a_decimals\n                        * ob.buy_side_price[index],\n                    ),\n                ),\n            )\n\n        return BuyOrderBook(buy_book), SellOrderBook(sell_book)\n\n    @classmethod\n    def get_book(cls, assets: Assets) -&gt; \"AxoOBMarketState\":\n        aob, ob, spot = cls._client.get_ob_info(assets)\n\n        if spot is None:\n            raise InvalidPoolError\n\n        try:\n            buy_book, sell_book = cls._process_ob(ob=aob)\n            buy_book_full, sell_book_full = cls._process_ob(ob=ob)\n        except IndexError:\n            logger.error(f\"Error getting Axo order book for assets: {assets}\")\n            raise InvalidPoolError\n\n        if \"lovelace\" in assets:\n            spot = 1.0\n\n        instance = cls(\n            assets=assets,\n            spot=spot,\n            block_time=int(datetime.now().timestamp()),\n            block_index=0,\n            buy_book_full=buy_book_full,\n            sell_book_full=sell_book_full,\n        )\n\n        return instance\n\n    @classmethod\n    def order_datum_class(self) -&gt; type[PlutusData]:\n        return AxoOrderDatum\n\n    @property\n    def stake_address(self) -&gt; Address:\n        return self._stake_address\n\n    def swap_utxo(\n        self,\n        address_source: Address,\n        in_assets: Assets,\n        out_assets: Assets,\n        tx_builder: TransactionBuilder,\n        extra_assets: Assets | None = None,\n        address_target: Address | None = None,\n        datum_target: PlutusData | None = None,\n    ) -&gt; tuple[TransactionOutput, PlutusData, UTxO]:\n        # Basic checks\n        if len(in_assets) != 1 or len(out_assets) != 1:\n            raise ValueError(\n                \"Only one asset can be supplied as input, \"\n                + \"and one asset supplied as output.\",\n            )\n\n        # Get the mint input UTxO\n        utxo_input = None\n        for utxo in tx_builder.inputs:\n            if utxo.output.amount.coin &gt; 1200000:\n                if utxo_input is None or len(utxo_input.output.to_cbor_hex()) &lt; len(\n                    utxo.output.to_cbor_hex(),\n                ):\n                    utxo_input = utxo\n\n        # Get the order build info\n        prices = get_token_prices(assets=[in_assets.unit(), out_assets.unit()])\n        if prices[0].policy_id + prices[0].policy_name == in_assets.unit():\n            in_decimals = prices[0].decimals\n            out_decimals = prices[1].decimals\n        else:\n            in_decimals = prices[1].decimals\n            out_decimals = prices[0].decimals\n        params = AxoCreateParams(\n            left=in_assets.unit() if in_assets.unit() != \"lovelace\" else \"\",\n            right=out_assets.unit() if out_assets.unit() != \"lovelace\" else \"\",\n            amount=in_assets.quantity() / 10**in_decimals,\n            slippage=self.slippage(in_assets=in_assets, out_assets=out_assets) + 2.0,\n        )\n        create: AxoCreateResponse = self._client.create(\n            wallet_addr=address_source.encode(),\n            tx_hash=utxo_input.input.transaction_id.payload.hex(),\n            tx_idx=utxo_input.input.index,\n            params=params,\n        )\n\n        # Create the mint metadata\n        metadata = AuxiliaryData(\n            AlonzoMetadata(metadata=Metadata({721: create.nft_metadata})),\n        )\n        tx_builder.auxiliary_data = metadata\n\n        # Create the axo receipt\n        axo_receipt = MultiAsset.from_primitive(\n            {\n                bytes.fromhex(create.strat_id): {\n                    bytes.fromhex(create.token_name): 2,\n                },\n            },\n        )\n        tx_builder.mint = axo_receipt\n        redeemer = Redeemer(CancelRedeemer())\n        redeemer.tag = RedeemerTag.MINT\n        tx_builder.add_minting_script(\n            PlutusV2Script(bytes.fromhex(create.policy_script)),\n            redeemer,\n        )\n\n        # Add in the recommended lovelace to the input and the axo receipt\n        in_assets.root[\"lovelace\"] = (\n            in_assets[\"lovelace\"]\n            + self.batcher_fee(\n                in_assets=in_assets,\n                out_assets=out_assets,\n                extra_assets=extra_assets,\n            ).quantity()\n            + self.deposit(in_assets=in_assets, out_assets=out_assets).quantity()\n        )\n        in_assets.root[create.strat_id + create.token_name] = 1\n\n        # Create the swap utxo\n        order_datum = AxoOrderDatum.from_cbor(create.datum)\n        output = TransactionOutput(\n            address=create.algo_addr,\n            amount=asset_to_value(in_assets),\n            datum=order_datum,\n        )\n        tx_builder.add_output(output)\n\n        # Create the receipt UTxO\n        utxo = TransactionOutput(\n            address=address_source,\n            amount=Value(\n                coin=1000000,\n                multi_asset=MultiAsset.from_primitive(\n                    {\n                        bytes.fromhex(create.strat_id): {\n                            bytes.fromhex(create.token_name): 1,\n                        },\n                    },\n                ),\n            ),\n        )\n        utxo.amount.coin = min_lovelace(context=tx_builder.context, output=utxo)\n        tx_builder.add_output(utxo)\n\n        return output, order_datum, utxo_input\n\n    @property\n    def volume_fee(self) -&gt; int:\n        return 10\n\n    @classmethod\n    def cancel_redeemer(cls) -&gt; PlutusData:\n        return Redeemer(AxoCancelRedeemer())\n\n    def batcher_fee(\n        self,\n        in_assets: Assets | None = None,\n        out_assets: Assets | None = None,\n        extra_assets: Assets | None = None,\n    ) -&gt; Assets:\n        \"\"\"Batcher fee.\n\n        Args:\n            in_assets: The input assets for the swap\n            out_assets: The output assets for the swap\n            extra_assets: Extra assets included in the transaction\n        \"\"\"\n        if in_assets.unit() == \"lovelace\":\n            fees = max(self.volume_fee * in_assets.quantity() // 10000, 1200000)\n        elif out_assets.unit() == \"lovelace\":\n            fees = max(self.volume_fee * out_assets.quantity() // 10000, 1200000)\n        else:\n            fees = max(\n                self.volume_fee * in_assets.quantity() * self.spot // 10000,\n                1200000,\n            )\n\n        # The below code estimates the Cardano cost of executing the tx\n        fees += 250000  # ~cost of output tx\n\n        if in_assets.unit() == self.unit_a:\n            book = self.sell_book_full\n        else:\n            book = self.buy_book_full\n\n        # Each fill order incurs ~0.6 ada cost\n        index = 0\n        in_quantity = in_assets.quantity()\n        while in_quantity &gt; 0 and index &lt; len(book):\n            available = book[index].quantity * book[index].price\n            fees += 600000\n            if available &gt; in_quantity:\n                in_quantity = 0\n            else:\n                in_quantity -= book[index].price * book[index].quantity\n            index += 1\n\n        return Assets(lovelace=fees)\n\n    def slippage(\n        self,\n        in_assets: Assets | None = None,\n        out_assets: Assets | None = None,\n    ) -&gt; Assets:\n        \"\"\"Calculate slippage.\n\n        Args:\n            in_assets: The input assets for the swap\n            out_assets: The output assets for the swap\n            extra_assets: Extra assets included in the transaction\n        \"\"\"\n        if in_assets.unit() == \"lovelace\":\n            fees = max(self.volume_fee * in_assets.quantity() // 10000, 1200000)\n        elif out_assets.unit() == \"lovelace\":\n            fees = max(self.volume_fee * out_assets.quantity() // 10000, 1200000)\n        else:\n            fees = max(\n                self.volume_fee * in_assets.quantity() * self.spot // 10000,\n                1200000,\n            )\n\n        # The below code estimates the Cardano cost of executing the tx\n        fees += 250000  # ~cost of output tx\n\n        if in_assets.unit() == self.unit_a:\n            book = self.sell_book_full\n        else:\n            book = self.buy_book_full\n\n        # Each fill order incurs ~0.5 ada cost\n        index = 0\n        best_price = book[index].price\n        in_quantity = in_assets.quantity()\n        while in_quantity &gt; 0 and index &lt; len(book):\n            available = book[index].quantity * book[index].price\n            fees += 500000\n            if available &gt; in_quantity:\n                in_quantity = 0\n            else:\n                in_quantity -= book[index].price * book[index].quantity\n            last_price = book[index].price\n            index += 1\n\n        return 100 * abs(1 - (best_price / last_price))\n\n    @property\n    def pool_id(self):\n        return \".\".join([self.dex, self.unit_a, self.unit_b])\n</code></pre>"},{"location":"axo/#charli3_dendrite.dexs.ob.axo.AxoOBMarketState.batcher_fee","title":"<code>batcher_fee(in_assets: Assets | None = None, out_assets: Assets | None = None, extra_assets: Assets | None = None) -&gt; Assets</code>","text":"<p>Batcher fee.</p> <p>Parameters:</p> Name Type Description Default <code>in_assets</code> <code>Assets | None</code> <p>The input assets for the swap</p> <code>None</code> <code>out_assets</code> <code>Assets | None</code> <p>The output assets for the swap</p> <code>None</code> <code>extra_assets</code> <code>Assets | None</code> <p>Extra assets included in the transaction</p> <code>None</code> Source code in <code>src/charli3_dendrite/dexs/ob/axo.py</code> <pre><code>def batcher_fee(\n    self,\n    in_assets: Assets | None = None,\n    out_assets: Assets | None = None,\n    extra_assets: Assets | None = None,\n) -&gt; Assets:\n    \"\"\"Batcher fee.\n\n    Args:\n        in_assets: The input assets for the swap\n        out_assets: The output assets for the swap\n        extra_assets: Extra assets included in the transaction\n    \"\"\"\n    if in_assets.unit() == \"lovelace\":\n        fees = max(self.volume_fee * in_assets.quantity() // 10000, 1200000)\n    elif out_assets.unit() == \"lovelace\":\n        fees = max(self.volume_fee * out_assets.quantity() // 10000, 1200000)\n    else:\n        fees = max(\n            self.volume_fee * in_assets.quantity() * self.spot // 10000,\n            1200000,\n        )\n\n    # The below code estimates the Cardano cost of executing the tx\n    fees += 250000  # ~cost of output tx\n\n    if in_assets.unit() == self.unit_a:\n        book = self.sell_book_full\n    else:\n        book = self.buy_book_full\n\n    # Each fill order incurs ~0.6 ada cost\n    index = 0\n    in_quantity = in_assets.quantity()\n    while in_quantity &gt; 0 and index &lt; len(book):\n        available = book[index].quantity * book[index].price\n        fees += 600000\n        if available &gt; in_quantity:\n            in_quantity = 0\n        else:\n            in_quantity -= book[index].price * book[index].quantity\n        index += 1\n\n    return Assets(lovelace=fees)\n</code></pre>"},{"location":"axo/#charli3_dendrite.dexs.ob.axo.AxoOBMarketState.order_selector","title":"<code>order_selector() -&gt; list[str]</code>  <code>classmethod</code>","text":"<p>Order selection information.</p> Source code in <code>src/charli3_dendrite/dexs/ob/axo.py</code> <pre><code>@classmethod\ndef order_selector(self) -&gt; list[str]:\n    \"\"\"Order selection information.\"\"\"\n    addresses = [\n        \"addr1z92l7rnra7sxjn5qv5fzc4fwsrrm29mgkleqj9a0y46j5lrryf9mtf9layje8u7u7wmap6alr28l90ry5t9nlyldjjsse4mxc9\",\n    ]\n    return addresses\n</code></pre>"},{"location":"axo/#charli3_dendrite.dexs.ob.axo.AxoOBMarketState.pool_selector","title":"<code>pool_selector() -&gt; PoolSelector</code>  <code>classmethod</code>","text":"<p>Pool selection information.</p> Source code in <code>src/charli3_dendrite/dexs/ob/axo.py</code> <pre><code>@classmethod\ndef pool_selector(self) -&gt; PoolSelector:\n    \"\"\"Pool selection information.\"\"\"\n    return []\n</code></pre>"},{"location":"axo/#charli3_dendrite.dexs.ob.axo.AxoOBMarketState.slippage","title":"<code>slippage(in_assets: Assets | None = None, out_assets: Assets | None = None) -&gt; Assets</code>","text":"<p>Calculate slippage.</p> <p>Parameters:</p> Name Type Description Default <code>in_assets</code> <code>Assets | None</code> <p>The input assets for the swap</p> <code>None</code> <code>out_assets</code> <code>Assets | None</code> <p>The output assets for the swap</p> <code>None</code> <code>extra_assets</code> <p>Extra assets included in the transaction</p> required Source code in <code>src/charli3_dendrite/dexs/ob/axo.py</code> <pre><code>def slippage(\n    self,\n    in_assets: Assets | None = None,\n    out_assets: Assets | None = None,\n) -&gt; Assets:\n    \"\"\"Calculate slippage.\n\n    Args:\n        in_assets: The input assets for the swap\n        out_assets: The output assets for the swap\n        extra_assets: Extra assets included in the transaction\n    \"\"\"\n    if in_assets.unit() == \"lovelace\":\n        fees = max(self.volume_fee * in_assets.quantity() // 10000, 1200000)\n    elif out_assets.unit() == \"lovelace\":\n        fees = max(self.volume_fee * out_assets.quantity() // 10000, 1200000)\n    else:\n        fees = max(\n            self.volume_fee * in_assets.quantity() * self.spot // 10000,\n            1200000,\n        )\n\n    # The below code estimates the Cardano cost of executing the tx\n    fees += 250000  # ~cost of output tx\n\n    if in_assets.unit() == self.unit_a:\n        book = self.sell_book_full\n    else:\n        book = self.buy_book_full\n\n    # Each fill order incurs ~0.5 ada cost\n    index = 0\n    best_price = book[index].price\n    in_quantity = in_assets.quantity()\n    while in_quantity &gt; 0 and index &lt; len(book):\n        available = book[index].quantity * book[index].price\n        fees += 500000\n        if available &gt; in_quantity:\n            in_quantity = 0\n        else:\n            in_quantity -= book[index].price * book[index].quantity\n        last_price = book[index].price\n        index += 1\n\n    return 100 * abs(1 - (best_price / last_price))\n</code></pre>"},{"location":"backend_base/","title":"Backend Base","text":"<p>Abstract base class for Cardano blockchain backend implementations.</p>"},{"location":"backend_base/#charli3_dendrite.backend.backend_base.AbstractBackend","title":"<code>AbstractBackend</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for Cardano blockchain backend implementations.</p> <p>This class defines the interface for interacting with various Cardano blockchain data sources such as db-sync, Ogmios, or Kupo.</p> Source code in <code>src/charli3_dendrite/backend/backend_base.py</code> <pre><code>class AbstractBackend(ABC):\n    \"\"\"Abstract base class for Cardano blockchain backend implementations.\n\n    This class defines the interface for interacting with various Cardano blockchain\n    data sources such as db-sync, Ogmios, or Kupo.\n    \"\"\"\n\n    @abstractmethod\n    def get_pool_utxos(  # noqa: PLR0913\n        self,\n        assets: list[str] | None = None,\n        addresses: list[str] | None = None,\n        limit: int = 1000,\n        page: int = 0,\n        historical: bool = True,\n    ) -&gt; PoolStateList:\n        \"\"\"Get UTXOs for specific assets or addresses.\n\n        Args:\n            assets (Optional[List[str]]): List of asset IDs to filter by.\n            addresses (Optional[List[str]]): List of addresses to filter by.\n            limit (int): Maximum number of results to return.\n            page (int): Page number for pagination.\n            historical (bool): Whether to include historical data.\n\n        Returns:\n            PoolStateList: List of pool state objects.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_pool_in_tx(\n        self,\n        tx_hash: str,\n        assets: list[str] | None = None,\n        addresses: list[str] | None = None,\n    ) -&gt; PoolStateList:\n        \"\"\"Get pool state for a specific transaction.\n\n        Args:\n            tx_hash (str): The transaction hash to query.\n            assets (Optional[List[str]]): List of asset IDs to filter by.\n            addresses (Optional[List[str]]): List of addresses to filter by.\n\n        Returns:\n            PoolStateList: List of pool state objects for the transaction.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def last_block(self, last_n_blocks: int = 2) -&gt; BlockList:\n        \"\"\"Get information about the last n blocks.\n\n        Args:\n            last_n_blocks (int): Number of recent blocks to retrieve.\n\n        Returns:\n            BlockList: List of recent block information.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_pool_utxos_in_block(self, block_no: int) -&gt; PoolStateList:\n        \"\"\"Get pool UTXOs for a specific block.\n\n        Args:\n            block_no (int): The block number to query.\n\n        Returns:\n            PoolStateList: List of pool state objects for the block.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_script_from_address(self, address: Address) -&gt; ScriptReference:\n        \"\"\"Get script reference for a given address.\n\n        Args:\n            address (Address): The address to query.\n\n        Returns:\n            ScriptReference: Script reference for the address.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_historical_order_utxos(\n        self,\n        stake_addresses: list[str],\n        after_time: datetime | int | None = None,\n        limit: int = 1000,\n        page: int = 0,\n    ) -&gt; SwapTransactionList:\n        \"\"\"Get historical order UTXOs for given stake addresses.\n\n        Args:\n            stake_addresses (List[str]): List of stake addresses to query.\n            after_time (Optional[Union[datetime, int]]): Filter results after this time.\n            limit (int): Maximum number of results to return.\n            page (int): Page number for pagination.\n\n        Returns:\n            SwapTransactionList: List of swap transaction objects.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_order_utxos_by_block_or_tx(  # noqa: PLR0913\n        self,\n        stake_addresses: list[str],\n        out_tx_hash: list[str] | None = None,\n        in_tx_hash: list[str] | None = None,\n        block_no: int | None = None,\n        after_block: int | None = None,\n        limit: int = 1000,\n        page: int = 0,\n    ) -&gt; SwapTransactionList:\n        \"\"\"Get order UTXOs by block or transaction.\n\n        Args:\n            stake_addresses (List[str]): List of stake addresses to query.\n            out_tx_hash (Optional[List[str]]): List of transaction hashes to filter by.\n            in_tx_hash: list of input transaction hashes to filter by.\n            block_no (Optional[int]): Specific block number to query.\n            after_block (Optional[int]): Filter results after this block number.\n            limit (int): Maximum number of results to return.\n            page (int): Page number for pagination.\n\n        Returns:\n            SwapTransactionList: List of swap transaction objects.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_cancel_utxos(  # noqa: PLR0913\n        self,\n        stake_addresses: list[str],\n        block_no: int | None = None,\n        after_time: datetime | int | None = None,\n        limit: int = 1000,\n        page: int = 0,\n    ) -&gt; SwapTransactionList:\n        \"\"\"Get cancelled order UTXOs.\n\n        Args:\n            stake_addresses (List[str]): List of stake addresses to query.\n            block_no (Optional[int]): Specific block number to query.\n            after_time (Optional[Union[datetime, int]]): Filter results after this time.\n            limit (int): Maximum number of results to return.\n            page (int): Page number for pagination.\n\n        Returns:\n            SwapTransactionList: List of swap transaction objects for cancelled orders.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_datum_from_address(\n        self,\n        address: str,\n        asset: str | None = None,\n    ) -&gt; str | None:\n        \"\"\"Get datum from a given address.\n\n        Args:\n            address: The address to query.\n            asset: Assets required to be in the UTxO.\n\n        Returns:\n            The datum associated with the address, if any.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"backend_base/#charli3_dendrite.backend.backend_base.AbstractBackend.get_cancel_utxos","title":"<code>get_cancel_utxos(stake_addresses: list[str], block_no: int | None = None, after_time: datetime | int | None = None, limit: int = 1000, page: int = 0) -&gt; SwapTransactionList</code>  <code>abstractmethod</code>","text":"<p>Get cancelled order UTXOs.</p> <p>Parameters:</p> Name Type Description Default <code>stake_addresses</code> <code>List[str]</code> <p>List of stake addresses to query.</p> required <code>block_no</code> <code>Optional[int]</code> <p>Specific block number to query.</p> <code>None</code> <code>after_time</code> <code>Optional[Union[datetime, int]]</code> <p>Filter results after this time.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of results to return.</p> <code>1000</code> <code>page</code> <code>int</code> <p>Page number for pagination.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>SwapTransactionList</code> <code>SwapTransactionList</code> <p>List of swap transaction objects for cancelled orders.</p> Source code in <code>src/charli3_dendrite/backend/backend_base.py</code> <pre><code>@abstractmethod\ndef get_cancel_utxos(  # noqa: PLR0913\n    self,\n    stake_addresses: list[str],\n    block_no: int | None = None,\n    after_time: datetime | int | None = None,\n    limit: int = 1000,\n    page: int = 0,\n) -&gt; SwapTransactionList:\n    \"\"\"Get cancelled order UTXOs.\n\n    Args:\n        stake_addresses (List[str]): List of stake addresses to query.\n        block_no (Optional[int]): Specific block number to query.\n        after_time (Optional[Union[datetime, int]]): Filter results after this time.\n        limit (int): Maximum number of results to return.\n        page (int): Page number for pagination.\n\n    Returns:\n        SwapTransactionList: List of swap transaction objects for cancelled orders.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"backend_base/#charli3_dendrite.backend.backend_base.AbstractBackend.get_datum_from_address","title":"<code>get_datum_from_address(address: str, asset: str | None = None) -&gt; str | None</code>  <code>abstractmethod</code>","text":"<p>Get datum from a given address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The address to query.</p> required <code>asset</code> <code>str | None</code> <p>Assets required to be in the UTxO.</p> <code>None</code> <p>Returns:</p> Type Description <code>str | None</code> <p>The datum associated with the address, if any.</p> Source code in <code>src/charli3_dendrite/backend/backend_base.py</code> <pre><code>@abstractmethod\ndef get_datum_from_address(\n    self,\n    address: str,\n    asset: str | None = None,\n) -&gt; str | None:\n    \"\"\"Get datum from a given address.\n\n    Args:\n        address: The address to query.\n        asset: Assets required to be in the UTxO.\n\n    Returns:\n        The datum associated with the address, if any.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"backend_base/#charli3_dendrite.backend.backend_base.AbstractBackend.get_historical_order_utxos","title":"<code>get_historical_order_utxos(stake_addresses: list[str], after_time: datetime | int | None = None, limit: int = 1000, page: int = 0) -&gt; SwapTransactionList</code>  <code>abstractmethod</code>","text":"<p>Get historical order UTXOs for given stake addresses.</p> <p>Parameters:</p> Name Type Description Default <code>stake_addresses</code> <code>List[str]</code> <p>List of stake addresses to query.</p> required <code>after_time</code> <code>Optional[Union[datetime, int]]</code> <p>Filter results after this time.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of results to return.</p> <code>1000</code> <code>page</code> <code>int</code> <p>Page number for pagination.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>SwapTransactionList</code> <code>SwapTransactionList</code> <p>List of swap transaction objects.</p> Source code in <code>src/charli3_dendrite/backend/backend_base.py</code> <pre><code>@abstractmethod\ndef get_historical_order_utxos(\n    self,\n    stake_addresses: list[str],\n    after_time: datetime | int | None = None,\n    limit: int = 1000,\n    page: int = 0,\n) -&gt; SwapTransactionList:\n    \"\"\"Get historical order UTXOs for given stake addresses.\n\n    Args:\n        stake_addresses (List[str]): List of stake addresses to query.\n        after_time (Optional[Union[datetime, int]]): Filter results after this time.\n        limit (int): Maximum number of results to return.\n        page (int): Page number for pagination.\n\n    Returns:\n        SwapTransactionList: List of swap transaction objects.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"backend_base/#charli3_dendrite.backend.backend_base.AbstractBackend.get_order_utxos_by_block_or_tx","title":"<code>get_order_utxos_by_block_or_tx(stake_addresses: list[str], out_tx_hash: list[str] | None = None, in_tx_hash: list[str] | None = None, block_no: int | None = None, after_block: int | None = None, limit: int = 1000, page: int = 0) -&gt; SwapTransactionList</code>  <code>abstractmethod</code>","text":"<p>Get order UTXOs by block or transaction.</p> <p>Parameters:</p> Name Type Description Default <code>stake_addresses</code> <code>List[str]</code> <p>List of stake addresses to query.</p> required <code>out_tx_hash</code> <code>Optional[List[str]]</code> <p>List of transaction hashes to filter by.</p> <code>None</code> <code>in_tx_hash</code> <code>list[str] | None</code> <p>list of input transaction hashes to filter by.</p> <code>None</code> <code>block_no</code> <code>Optional[int]</code> <p>Specific block number to query.</p> <code>None</code> <code>after_block</code> <code>Optional[int]</code> <p>Filter results after this block number.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of results to return.</p> <code>1000</code> <code>page</code> <code>int</code> <p>Page number for pagination.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>SwapTransactionList</code> <code>SwapTransactionList</code> <p>List of swap transaction objects.</p> Source code in <code>src/charli3_dendrite/backend/backend_base.py</code> <pre><code>@abstractmethod\ndef get_order_utxos_by_block_or_tx(  # noqa: PLR0913\n    self,\n    stake_addresses: list[str],\n    out_tx_hash: list[str] | None = None,\n    in_tx_hash: list[str] | None = None,\n    block_no: int | None = None,\n    after_block: int | None = None,\n    limit: int = 1000,\n    page: int = 0,\n) -&gt; SwapTransactionList:\n    \"\"\"Get order UTXOs by block or transaction.\n\n    Args:\n        stake_addresses (List[str]): List of stake addresses to query.\n        out_tx_hash (Optional[List[str]]): List of transaction hashes to filter by.\n        in_tx_hash: list of input transaction hashes to filter by.\n        block_no (Optional[int]): Specific block number to query.\n        after_block (Optional[int]): Filter results after this block number.\n        limit (int): Maximum number of results to return.\n        page (int): Page number for pagination.\n\n    Returns:\n        SwapTransactionList: List of swap transaction objects.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"backend_base/#charli3_dendrite.backend.backend_base.AbstractBackend.get_pool_in_tx","title":"<code>get_pool_in_tx(tx_hash: str, assets: list[str] | None = None, addresses: list[str] | None = None) -&gt; PoolStateList</code>  <code>abstractmethod</code>","text":"<p>Get pool state for a specific transaction.</p> <p>Parameters:</p> Name Type Description Default <code>tx_hash</code> <code>str</code> <p>The transaction hash to query.</p> required <code>assets</code> <code>Optional[List[str]]</code> <p>List of asset IDs to filter by.</p> <code>None</code> <code>addresses</code> <code>Optional[List[str]]</code> <p>List of addresses to filter by.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>PoolStateList</code> <code>PoolStateList</code> <p>List of pool state objects for the transaction.</p> Source code in <code>src/charli3_dendrite/backend/backend_base.py</code> <pre><code>@abstractmethod\ndef get_pool_in_tx(\n    self,\n    tx_hash: str,\n    assets: list[str] | None = None,\n    addresses: list[str] | None = None,\n) -&gt; PoolStateList:\n    \"\"\"Get pool state for a specific transaction.\n\n    Args:\n        tx_hash (str): The transaction hash to query.\n        assets (Optional[List[str]]): List of asset IDs to filter by.\n        addresses (Optional[List[str]]): List of addresses to filter by.\n\n    Returns:\n        PoolStateList: List of pool state objects for the transaction.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"backend_base/#charli3_dendrite.backend.backend_base.AbstractBackend.get_pool_utxos","title":"<code>get_pool_utxos(assets: list[str] | None = None, addresses: list[str] | None = None, limit: int = 1000, page: int = 0, historical: bool = True) -&gt; PoolStateList</code>  <code>abstractmethod</code>","text":"<p>Get UTXOs for specific assets or addresses.</p> <p>Parameters:</p> Name Type Description Default <code>assets</code> <code>Optional[List[str]]</code> <p>List of asset IDs to filter by.</p> <code>None</code> <code>addresses</code> <code>Optional[List[str]]</code> <p>List of addresses to filter by.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of results to return.</p> <code>1000</code> <code>page</code> <code>int</code> <p>Page number for pagination.</p> <code>0</code> <code>historical</code> <code>bool</code> <p>Whether to include historical data.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>PoolStateList</code> <code>PoolStateList</code> <p>List of pool state objects.</p> Source code in <code>src/charli3_dendrite/backend/backend_base.py</code> <pre><code>@abstractmethod\ndef get_pool_utxos(  # noqa: PLR0913\n    self,\n    assets: list[str] | None = None,\n    addresses: list[str] | None = None,\n    limit: int = 1000,\n    page: int = 0,\n    historical: bool = True,\n) -&gt; PoolStateList:\n    \"\"\"Get UTXOs for specific assets or addresses.\n\n    Args:\n        assets (Optional[List[str]]): List of asset IDs to filter by.\n        addresses (Optional[List[str]]): List of addresses to filter by.\n        limit (int): Maximum number of results to return.\n        page (int): Page number for pagination.\n        historical (bool): Whether to include historical data.\n\n    Returns:\n        PoolStateList: List of pool state objects.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"backend_base/#charli3_dendrite.backend.backend_base.AbstractBackend.get_pool_utxos_in_block","title":"<code>get_pool_utxos_in_block(block_no: int) -&gt; PoolStateList</code>  <code>abstractmethod</code>","text":"<p>Get pool UTXOs for a specific block.</p> <p>Parameters:</p> Name Type Description Default <code>block_no</code> <code>int</code> <p>The block number to query.</p> required <p>Returns:</p> Name Type Description <code>PoolStateList</code> <code>PoolStateList</code> <p>List of pool state objects for the block.</p> Source code in <code>src/charli3_dendrite/backend/backend_base.py</code> <pre><code>@abstractmethod\ndef get_pool_utxos_in_block(self, block_no: int) -&gt; PoolStateList:\n    \"\"\"Get pool UTXOs for a specific block.\n\n    Args:\n        block_no (int): The block number to query.\n\n    Returns:\n        PoolStateList: List of pool state objects for the block.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"backend_base/#charli3_dendrite.backend.backend_base.AbstractBackend.get_script_from_address","title":"<code>get_script_from_address(address: Address) -&gt; ScriptReference</code>  <code>abstractmethod</code>","text":"<p>Get script reference for a given address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>Address</code> <p>The address to query.</p> required <p>Returns:</p> Name Type Description <code>ScriptReference</code> <code>ScriptReference</code> <p>Script reference for the address.</p> Source code in <code>src/charli3_dendrite/backend/backend_base.py</code> <pre><code>@abstractmethod\ndef get_script_from_address(self, address: Address) -&gt; ScriptReference:\n    \"\"\"Get script reference for a given address.\n\n    Args:\n        address (Address): The address to query.\n\n    Returns:\n        ScriptReference: Script reference for the address.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"backend_base/#charli3_dendrite.backend.backend_base.AbstractBackend.last_block","title":"<code>last_block(last_n_blocks: int = 2) -&gt; BlockList</code>  <code>abstractmethod</code>","text":"<p>Get information about the last n blocks.</p> <p>Parameters:</p> Name Type Description Default <code>last_n_blocks</code> <code>int</code> <p>Number of recent blocks to retrieve.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>BlockList</code> <code>BlockList</code> <p>List of recent block information.</p> Source code in <code>src/charli3_dendrite/backend/backend_base.py</code> <pre><code>@abstractmethod\ndef last_block(self, last_n_blocks: int = 2) -&gt; BlockList:\n    \"\"\"Get information about the last n blocks.\n\n    Args:\n        last_n_blocks (int): Number of recent blocks to retrieve.\n\n    Returns:\n        BlockList: List of recent block information.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"core_base/","title":"Core base","text":"<p>Abstract base class and common functions for handling token pairs.</p>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState","title":"<code>AbstractPairState</code>","text":"<p>               Bases: <code>DendriteBaseModel</code>, <code>ABC</code></p> <p>Abstract base class representing the state of a pair.</p> Source code in <code>src/charli3_dendrite/dexs/core/base.py</code> <pre><code>class AbstractPairState(DendriteBaseModel, ABC):\n    \"\"\"Abstract base class representing the state of a pair.\"\"\"\n\n    assets: Assets\n    block_time: int\n    block_index: int\n    fee: int | list[int] | None = None\n    plutus_v2: bool\n    tx_index: int | None = None\n    tx_hash: str | None = None\n    datum_cbor: str | None = None\n    datum_hash: str | None = None\n    dex_nft: Assets | None = None\n\n    _batcher_fee: Assets\n    _datum_parsed: PlutusData\n\n    @classmethod\n    @abstractmethod\n    def dex(cls) -&gt; str:\n        \"\"\"Official dex name.\"\"\"\n        raise NotImplementedError\n\n    @classmethod\n    @abstractmethod\n    def order_selector(cls) -&gt; list[str]:\n        \"\"\"Order selection information.\"\"\"\n        raise NotImplementedError\n\n    @classmethod\n    @abstractmethod\n    def pool_selector(cls) -&gt; PoolSelector:\n        \"\"\"Pool selection information.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_amount_out(self, asset: Assets) -&gt; tuple[Assets, float]:\n        \"\"\"Calculate the output amount of assets for given input.\n\n        Args:\n            asset: An asset with a defined quantity.\n\n        Returns:\n            A tuple where the first value is the estimated asset returned and\n            the second value is the price impact ratio.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_amount_in(self, asset: Assets) -&gt; tuple[Assets, float]:\n        \"\"\"Get the input asset amount given a desired output asset amount.\n\n        Args:\n            asset: An asset with a defined quantity.\n\n        Returns:\n           A tuple where the first value is the the estimated asset needed and\n           the second value is the slippage fee.\n        \"\"\"\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def swap_forward(self) -&gt; bool:\n        \"\"\"Returns if swap forwarding is enabled.\"\"\"\n        raise NotImplementedError\n\n    @property\n    def inline_datum(self) -&gt; bool:\n        \"\"\"Determine whether the datum should be inline.\"\"\"\n        return self.plutus_v2\n\n    @classmethod\n    def reference_utxo(cls) -&gt; UTxO | None:\n        \"\"\"Get Reference UTXO.\n\n        Returns:\n            UTxO | None: UTxO object if it exists, otherwise None.\n        \"\"\"\n        return None\n\n    @property\n    @abstractmethod\n    def stake_address(self) -&gt; Address:\n        \"\"\"Return the staking address.\"\"\"\n        raise NotImplementedError\n\n    @classmethod\n    @abstractmethod\n    def order_datum_class(cls) -&gt; type[PlutusData]:\n        \"\"\"Returns data class used for handling order datums.\"\"\"\n        raise NotImplementedError\n\n    @classmethod\n    def default_script_class(cls) -&gt; type[PlutusV1Script] | type[PlutusV2Script]:\n        \"\"\"Get default script class as Plutus V1 unless overridden.\n\n        Returns:\n            type[PlutusV1Script] | type[PlutusV2Script]: The default script class.\n        \"\"\"\n        return PlutusV1Script\n\n    @property\n    def script_class(self) -&gt; type[PlutusV1Script] | type[PlutusV2Script]:\n        \"\"\"Returns the script class based on the Plutus version being used.\"\"\"\n        if self.plutus_v2:\n            return PlutusV2Script\n        return PlutusV1Script\n\n    def swap_datum(\n        self,\n        address_source: Address,\n        in_assets: Assets,\n        out_assets: Assets,\n        extra_assets: Assets | None = None,\n        address_target: Address | None = None,\n        datum_target: PlutusData | None = None,\n    ) -&gt; PlutusData:\n        \"\"\"Constructs the datum for a swap transaction.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def swap_utxo(\n        self,\n        address_source: Address,\n        in_assets: Assets,\n        out_assets: Assets,\n        extra_assets: Assets | None = None,\n        address_target: Address | None = None,\n        datum_target: PlutusData | None = None,\n    ) -&gt; TransactionOutput:\n        \"\"\"Constructs the transaction output for a swap.\"\"\"\n        raise NotImplementedError\n\n    @property\n    def volume_fee(self) -&gt; int | float | list[int] | list[float] | None:\n        \"\"\"Swap fee of swap in basis points.\"\"\"\n        return self.fee\n\n    @classmethod\n    def cancel_redeemer(cls) -&gt; PlutusData:\n        \"\"\"Returns the redeemer data for canceling transaction.\"\"\"\n        return Redeemer(CancelRedeemer())\n\n    def batcher_fee(\n        self,\n        in_assets: Assets | None = None,\n        out_assets: Assets | None = None,\n        extra_assets: Assets | None = None,\n    ) -&gt; Assets:\n        \"\"\"Batcher fee.\n\n        Args:\n            in_assets: The input assets for the swap\n            out_assets: The output assets for the swap\n            extra_assets: Extra assets included in the transaction\n        \"\"\"\n        return self._batcher\n\n    def deposit(\n        self,\n        in_assets: Assets | None = None,\n        out_assets: Assets | None = None,\n    ) -&gt; Assets:\n        \"\"\"Batcher fee.\"\"\"\n        return self._deposit\n\n    @classmethod\n    def dex_policy(cls) -&gt; list[str] | None:\n        \"\"\"The dex nft policy.\n\n        This should be the policy or policy+name of the dex nft.\n\n        If None, then the default dex nft check is skipped.\n\n        Returns:\n            Optional[str]: policy or policy+name of dex nft\n        \"\"\"\n        return None\n\n    @property\n    def unit_a(self) -&gt; str:\n        \"\"\"Token name of asset A.\"\"\"\n        return self.assets.unit(0)\n\n    @property\n    def unit_b(self) -&gt; str:\n        \"\"\"Token name of asset b.\"\"\"\n        return self.assets.unit(1)\n\n    @property\n    def reserve_a(self) -&gt; int:\n        \"\"\"Reserve amount of asset A.\"\"\"\n        return self.assets.quantity(0)\n\n    @property\n    def reserve_b(self) -&gt; int:\n        \"\"\"Reserve amount of asset B.\"\"\"\n        return self.assets.quantity(1)\n\n    @property\n    @abstractmethod\n    def price(self) -&gt; tuple[Decimal, Decimal]:\n        \"\"\"Price of assets.\n\n        Returns:\n            A `Tuple[Decimal, Decimal] where the first `Decimal` is the price to buy\n                1 of token B in units of token A, and the second `Decimal` is the price\n                to buy 1 of token A in units of token B.\n        \"\"\"\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def tvl(self) -&gt; Decimal:\n        \"\"\"Return the total value locked for the pool.\n\n        Raises:\n            NotImplementedError: Only ADA pool TVL is implemented.\n        \"\"\"\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def pool_id(self) -&gt; str:\n        \"\"\"A unique identifier for the pool or ob.\n\n        Raises:\n            NotImplementedError: Only ADA pool TVL is implemented.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.inline_datum","title":"<code>inline_datum: bool</code>  <code>property</code>","text":"<p>Determine whether the datum should be inline.</p>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.pool_id","title":"<code>pool_id: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>A unique identifier for the pool or ob.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Only ADA pool TVL is implemented.</p>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.price","title":"<code>price: tuple[Decimal, Decimal]</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Price of assets.</p> <p>Returns:</p> Type Description <code>tuple[Decimal, Decimal]</code> <p>A <code>Tuple[Decimal, Decimal] where the first</code>Decimal<code>is the price to buy 1 of token B in units of token A, and the second</code>Decimal` is the price to buy 1 of token A in units of token B.</p>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.reserve_a","title":"<code>reserve_a: int</code>  <code>property</code>","text":"<p>Reserve amount of asset A.</p>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.reserve_b","title":"<code>reserve_b: int</code>  <code>property</code>","text":"<p>Reserve amount of asset B.</p>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.script_class","title":"<code>script_class: type[PlutusV1Script] | type[PlutusV2Script]</code>  <code>property</code>","text":"<p>Returns the script class based on the Plutus version being used.</p>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.stake_address","title":"<code>stake_address: Address</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Return the staking address.</p>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.swap_forward","title":"<code>swap_forward: bool</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Returns if swap forwarding is enabled.</p>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.tvl","title":"<code>tvl: Decimal</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Return the total value locked for the pool.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Only ADA pool TVL is implemented.</p>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.unit_a","title":"<code>unit_a: str</code>  <code>property</code>","text":"<p>Token name of asset A.</p>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.unit_b","title":"<code>unit_b: str</code>  <code>property</code>","text":"<p>Token name of asset b.</p>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.volume_fee","title":"<code>volume_fee: int | float | list[int] | list[float] | None</code>  <code>property</code>","text":"<p>Swap fee of swap in basis points.</p>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.batcher_fee","title":"<code>batcher_fee(in_assets: Assets | None = None, out_assets: Assets | None = None, extra_assets: Assets | None = None) -&gt; Assets</code>","text":"<p>Batcher fee.</p> <p>Parameters:</p> Name Type Description Default <code>in_assets</code> <code>Assets | None</code> <p>The input assets for the swap</p> <code>None</code> <code>out_assets</code> <code>Assets | None</code> <p>The output assets for the swap</p> <code>None</code> <code>extra_assets</code> <code>Assets | None</code> <p>Extra assets included in the transaction</p> <code>None</code> Source code in <code>src/charli3_dendrite/dexs/core/base.py</code> <pre><code>def batcher_fee(\n    self,\n    in_assets: Assets | None = None,\n    out_assets: Assets | None = None,\n    extra_assets: Assets | None = None,\n) -&gt; Assets:\n    \"\"\"Batcher fee.\n\n    Args:\n        in_assets: The input assets for the swap\n        out_assets: The output assets for the swap\n        extra_assets: Extra assets included in the transaction\n    \"\"\"\n    return self._batcher\n</code></pre>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.cancel_redeemer","title":"<code>cancel_redeemer() -&gt; PlutusData</code>  <code>classmethod</code>","text":"<p>Returns the redeemer data for canceling transaction.</p> Source code in <code>src/charli3_dendrite/dexs/core/base.py</code> <pre><code>@classmethod\ndef cancel_redeemer(cls) -&gt; PlutusData:\n    \"\"\"Returns the redeemer data for canceling transaction.\"\"\"\n    return Redeemer(CancelRedeemer())\n</code></pre>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.default_script_class","title":"<code>default_script_class() -&gt; type[PlutusV1Script] | type[PlutusV2Script]</code>  <code>classmethod</code>","text":"<p>Get default script class as Plutus V1 unless overridden.</p> <p>Returns:</p> Type Description <code>type[PlutusV1Script] | type[PlutusV2Script]</code> <p>type[PlutusV1Script] | type[PlutusV2Script]: The default script class.</p> Source code in <code>src/charli3_dendrite/dexs/core/base.py</code> <pre><code>@classmethod\ndef default_script_class(cls) -&gt; type[PlutusV1Script] | type[PlutusV2Script]:\n    \"\"\"Get default script class as Plutus V1 unless overridden.\n\n    Returns:\n        type[PlutusV1Script] | type[PlutusV2Script]: The default script class.\n    \"\"\"\n    return PlutusV1Script\n</code></pre>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.deposit","title":"<code>deposit(in_assets: Assets | None = None, out_assets: Assets | None = None) -&gt; Assets</code>","text":"<p>Batcher fee.</p> Source code in <code>src/charli3_dendrite/dexs/core/base.py</code> <pre><code>def deposit(\n    self,\n    in_assets: Assets | None = None,\n    out_assets: Assets | None = None,\n) -&gt; Assets:\n    \"\"\"Batcher fee.\"\"\"\n    return self._deposit\n</code></pre>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.dex","title":"<code>dex() -&gt; str</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Official dex name.</p> Source code in <code>src/charli3_dendrite/dexs/core/base.py</code> <pre><code>@classmethod\n@abstractmethod\ndef dex(cls) -&gt; str:\n    \"\"\"Official dex name.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.dex_policy","title":"<code>dex_policy() -&gt; list[str] | None</code>  <code>classmethod</code>","text":"<p>The dex nft policy.</p> <p>This should be the policy or policy+name of the dex nft.</p> <p>If None, then the default dex nft check is skipped.</p> <p>Returns:</p> Type Description <code>list[str] | None</code> <p>Optional[str]: policy or policy+name of dex nft</p> Source code in <code>src/charli3_dendrite/dexs/core/base.py</code> <pre><code>@classmethod\ndef dex_policy(cls) -&gt; list[str] | None:\n    \"\"\"The dex nft policy.\n\n    This should be the policy or policy+name of the dex nft.\n\n    If None, then the default dex nft check is skipped.\n\n    Returns:\n        Optional[str]: policy or policy+name of dex nft\n    \"\"\"\n    return None\n</code></pre>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.get_amount_in","title":"<code>get_amount_in(asset: Assets) -&gt; tuple[Assets, float]</code>  <code>abstractmethod</code>","text":"<p>Get the input asset amount given a desired output asset amount.</p> <p>Parameters:</p> Name Type Description Default <code>asset</code> <code>Assets</code> <p>An asset with a defined quantity.</p> required <p>Returns:</p> Type Description <code>Assets</code> <p>A tuple where the first value is the the estimated asset needed and</p> <code>float</code> <p>the second value is the slippage fee.</p> Source code in <code>src/charli3_dendrite/dexs/core/base.py</code> <pre><code>@abstractmethod\ndef get_amount_in(self, asset: Assets) -&gt; tuple[Assets, float]:\n    \"\"\"Get the input asset amount given a desired output asset amount.\n\n    Args:\n        asset: An asset with a defined quantity.\n\n    Returns:\n       A tuple where the first value is the the estimated asset needed and\n       the second value is the slippage fee.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.get_amount_out","title":"<code>get_amount_out(asset: Assets) -&gt; tuple[Assets, float]</code>  <code>abstractmethod</code>","text":"<p>Calculate the output amount of assets for given input.</p> <p>Parameters:</p> Name Type Description Default <code>asset</code> <code>Assets</code> <p>An asset with a defined quantity.</p> required <p>Returns:</p> Type Description <code>Assets</code> <p>A tuple where the first value is the estimated asset returned and</p> <code>float</code> <p>the second value is the price impact ratio.</p> Source code in <code>src/charli3_dendrite/dexs/core/base.py</code> <pre><code>@abstractmethod\ndef get_amount_out(self, asset: Assets) -&gt; tuple[Assets, float]:\n    \"\"\"Calculate the output amount of assets for given input.\n\n    Args:\n        asset: An asset with a defined quantity.\n\n    Returns:\n        A tuple where the first value is the estimated asset returned and\n        the second value is the price impact ratio.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.order_datum_class","title":"<code>order_datum_class() -&gt; type[PlutusData]</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Returns data class used for handling order datums.</p> Source code in <code>src/charli3_dendrite/dexs/core/base.py</code> <pre><code>@classmethod\n@abstractmethod\ndef order_datum_class(cls) -&gt; type[PlutusData]:\n    \"\"\"Returns data class used for handling order datums.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.order_selector","title":"<code>order_selector() -&gt; list[str]</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Order selection information.</p> Source code in <code>src/charli3_dendrite/dexs/core/base.py</code> <pre><code>@classmethod\n@abstractmethod\ndef order_selector(cls) -&gt; list[str]:\n    \"\"\"Order selection information.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.pool_selector","title":"<code>pool_selector() -&gt; PoolSelector</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Pool selection information.</p> Source code in <code>src/charli3_dendrite/dexs/core/base.py</code> <pre><code>@classmethod\n@abstractmethod\ndef pool_selector(cls) -&gt; PoolSelector:\n    \"\"\"Pool selection information.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.reference_utxo","title":"<code>reference_utxo() -&gt; UTxO | None</code>  <code>classmethod</code>","text":"<p>Get Reference UTXO.</p> <p>Returns:</p> Type Description <code>UTxO | None</code> <p>UTxO | None: UTxO object if it exists, otherwise None.</p> Source code in <code>src/charli3_dendrite/dexs/core/base.py</code> <pre><code>@classmethod\ndef reference_utxo(cls) -&gt; UTxO | None:\n    \"\"\"Get Reference UTXO.\n\n    Returns:\n        UTxO | None: UTxO object if it exists, otherwise None.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.swap_datum","title":"<code>swap_datum(address_source: Address, in_assets: Assets, out_assets: Assets, extra_assets: Assets | None = None, address_target: Address | None = None, datum_target: PlutusData | None = None) -&gt; PlutusData</code>","text":"<p>Constructs the datum for a swap transaction.</p> Source code in <code>src/charli3_dendrite/dexs/core/base.py</code> <pre><code>def swap_datum(\n    self,\n    address_source: Address,\n    in_assets: Assets,\n    out_assets: Assets,\n    extra_assets: Assets | None = None,\n    address_target: Address | None = None,\n    datum_target: PlutusData | None = None,\n) -&gt; PlutusData:\n    \"\"\"Constructs the datum for a swap transaction.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"core_base/#charli3_dendrite.dexs.core.base.AbstractPairState.swap_utxo","title":"<code>swap_utxo(address_source: Address, in_assets: Assets, out_assets: Assets, extra_assets: Assets | None = None, address_target: Address | None = None, datum_target: PlutusData | None = None) -&gt; TransactionOutput</code>  <code>abstractmethod</code>","text":"<p>Constructs the transaction output for a swap.</p> Source code in <code>src/charli3_dendrite/dexs/core/base.py</code> <pre><code>@abstractmethod\ndef swap_utxo(\n    self,\n    address_source: Address,\n    in_assets: Assets,\n    out_assets: Assets,\n    extra_assets: Assets | None = None,\n    address_target: Address | None = None,\n    datum_target: PlutusData | None = None,\n) -&gt; TransactionOutput:\n    \"\"\"Constructs the transaction output for a swap.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"datums/","title":"Datums","text":"<p>Dataclasses for the different datums used in the Charli3 Dendrite project.</p>"},{"location":"datums/#charli3_dendrite.dataclasses.datums.AssetClass","title":"<code>AssetClass</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>An asset class. Separates out token policy and asset name.</p> Source code in <code>src/charli3_dendrite/dataclasses/datums.py</code> <pre><code>@dataclass\nclass AssetClass(PlutusData):\n    \"\"\"An asset class. Separates out token policy and asset name.\"\"\"\n\n    CONSTR_ID = 0\n\n    policy: bytes\n    asset_name: bytes\n\n    @classmethod\n    def from_assets(cls, asset: Assets) -&gt; \"AssetClass\":\n        \"\"\"Parse an Assets object into an AssetClass object.\"\"\"\n        error_msg = \"Only one asset may be supplied.\"\n        if len(asset) != 1:\n            raise ValueError(error_msg)\n\n        if asset.unit() == \"lovelace\":\n            policy = b\"\"\n            asset_name = b\"\"\n        else:\n            policy = bytes.fromhex(asset.unit()[:56])\n            asset_name = bytes.fromhex(asset.unit()[56:])\n\n        return AssetClass(policy=policy, asset_name=asset_name)\n\n    @property\n    def assets(self) -&gt; Assets:\n        \"\"\"Convert back to assets.\"\"\"\n        if self.policy.hex() == \"\":\n            asset = \"lovelace\"\n        else:\n            asset = self.policy.hex() + self.asset_name.hex()\n\n        return Assets(root={asset: 0})\n</code></pre>"},{"location":"datums/#charli3_dendrite.dataclasses.datums.AssetClass.assets","title":"<code>assets: Assets</code>  <code>property</code>","text":"<p>Convert back to assets.</p>"},{"location":"datums/#charli3_dendrite.dataclasses.datums.AssetClass.from_assets","title":"<code>from_assets(asset: Assets) -&gt; AssetClass</code>  <code>classmethod</code>","text":"<p>Parse an Assets object into an AssetClass object.</p> Source code in <code>src/charli3_dendrite/dataclasses/datums.py</code> <pre><code>@classmethod\ndef from_assets(cls, asset: Assets) -&gt; \"AssetClass\":\n    \"\"\"Parse an Assets object into an AssetClass object.\"\"\"\n    error_msg = \"Only one asset may be supplied.\"\n    if len(asset) != 1:\n        raise ValueError(error_msg)\n\n    if asset.unit() == \"lovelace\":\n        policy = b\"\"\n        asset_name = b\"\"\n    else:\n        policy = bytes.fromhex(asset.unit()[:56])\n        asset_name = bytes.fromhex(asset.unit()[56:])\n\n    return AssetClass(policy=policy, asset_name=asset_name)\n</code></pre>"},{"location":"datums/#charli3_dendrite.dataclasses.datums.CancelRedeemer","title":"<code>CancelRedeemer</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Cancel datum.</p> Source code in <code>src/charli3_dendrite/dataclasses/datums.py</code> <pre><code>@dataclass\nclass CancelRedeemer(PlutusData):\n    \"\"\"Cancel datum.\"\"\"\n\n    CONSTR_ID = 1\n</code></pre>"},{"location":"datums/#charli3_dendrite.dataclasses.datums.OrderDatum","title":"<code>OrderDatum</code>","text":"<p>               Bases: <code>PlutusData</code>, <code>ABC</code></p> <p>Abstract base class for all order datum types.</p> Source code in <code>src/charli3_dendrite/dataclasses/datums.py</code> <pre><code>class OrderDatum(PlutusData, ABC):\n    \"\"\"Abstract base class for all order datum types.\"\"\"\n\n    CONSTR_ID: int = 0\n\n    @abstractmethod\n    def address_source(self) -&gt; Address:\n        \"\"\"This method should return the source address associated with the order.\"\"\"\n        pass\n\n    @abstractmethod\n    def requested_amount(self) -&gt; Assets:\n        \"\"\"This method should return the amount requested in the order.\"\"\"\n        pass\n\n    @abstractmethod\n    def order_type(self) -&gt; OrderType:\n        \"\"\"This method should return the type of the order.\"\"\"\n        pass\n</code></pre>"},{"location":"datums/#charli3_dendrite.dataclasses.datums.OrderDatum.address_source","title":"<code>address_source() -&gt; Address</code>  <code>abstractmethod</code>","text":"<p>This method should return the source address associated with the order.</p> Source code in <code>src/charli3_dendrite/dataclasses/datums.py</code> <pre><code>@abstractmethod\ndef address_source(self) -&gt; Address:\n    \"\"\"This method should return the source address associated with the order.\"\"\"\n    pass\n</code></pre>"},{"location":"datums/#charli3_dendrite.dataclasses.datums.OrderDatum.order_type","title":"<code>order_type() -&gt; OrderType</code>  <code>abstractmethod</code>","text":"<p>This method should return the type of the order.</p> Source code in <code>src/charli3_dendrite/dataclasses/datums.py</code> <pre><code>@abstractmethod\ndef order_type(self) -&gt; OrderType:\n    \"\"\"This method should return the type of the order.\"\"\"\n    pass\n</code></pre>"},{"location":"datums/#charli3_dendrite.dataclasses.datums.OrderDatum.requested_amount","title":"<code>requested_amount() -&gt; Assets</code>  <code>abstractmethod</code>","text":"<p>This method should return the amount requested in the order.</p> Source code in <code>src/charli3_dendrite/dataclasses/datums.py</code> <pre><code>@abstractmethod\ndef requested_amount(self) -&gt; Assets:\n    \"\"\"This method should return the amount requested in the order.\"\"\"\n    pass\n</code></pre>"},{"location":"datums/#charli3_dendrite.dataclasses.datums.PlutusFullAddress","title":"<code>PlutusFullAddress</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>A full address, including payment and staking keys.</p> Source code in <code>src/charli3_dendrite/dataclasses/datums.py</code> <pre><code>@dataclass\nclass PlutusFullAddress(PlutusData):\n    \"\"\"A full address, including payment and staking keys.\"\"\"\n\n    CONSTR_ID = 0\n    payment: Union[PlutusPartAddress, PlutusScriptPartAddress]\n    stake: Union[_PlutusConstrWrapper, PlutusNone, None] = None\n\n    @classmethod\n    def from_address(cls, address: Address) -&gt; \"PlutusFullAddress\":\n        \"\"\"Parse an Address object to a PlutusFullAddress.\"\"\"\n        error_msg = \"Only addresses with staking and payment parts are accepted.\"\n        if None in [address.staking_part, address.payment_part]:\n            raise ValueError(error_msg)\n        if address.staking_part is not None:\n            stake = _PlutusConstrWrapper(\n                _PlutusConstrWrapper(\n                    PlutusPartAddress(bytes.fromhex(str(address.staking_part))),\n                ),\n            )\n        else:\n            stake = PlutusNone\n        return PlutusFullAddress(\n            PlutusPartAddress(bytes.fromhex(str(address.payment_part))),\n            stake=stake,\n        )\n\n    def to_address(self) -&gt; Address:\n        \"\"\"Convert back to an address.\"\"\"\n        payment_part = VerificationKeyHash(self.payment.address[:28])\n        if isinstance(self.stake, PlutusNone):\n            stake_part = None\n        else:\n            stake_part = VerificationKeyHash(self.stake.wrapped.wrapped.address[:28])\n        return Address(payment_part=payment_part, staking_part=stake_part)\n</code></pre>"},{"location":"datums/#charli3_dendrite.dataclasses.datums.PlutusFullAddress.from_address","title":"<code>from_address(address: Address) -&gt; PlutusFullAddress</code>  <code>classmethod</code>","text":"<p>Parse an Address object to a PlutusFullAddress.</p> Source code in <code>src/charli3_dendrite/dataclasses/datums.py</code> <pre><code>@classmethod\ndef from_address(cls, address: Address) -&gt; \"PlutusFullAddress\":\n    \"\"\"Parse an Address object to a PlutusFullAddress.\"\"\"\n    error_msg = \"Only addresses with staking and payment parts are accepted.\"\n    if None in [address.staking_part, address.payment_part]:\n        raise ValueError(error_msg)\n    if address.staking_part is not None:\n        stake = _PlutusConstrWrapper(\n            _PlutusConstrWrapper(\n                PlutusPartAddress(bytes.fromhex(str(address.staking_part))),\n            ),\n        )\n    else:\n        stake = PlutusNone\n    return PlutusFullAddress(\n        PlutusPartAddress(bytes.fromhex(str(address.payment_part))),\n        stake=stake,\n    )\n</code></pre>"},{"location":"datums/#charli3_dendrite.dataclasses.datums.PlutusFullAddress.to_address","title":"<code>to_address() -&gt; Address</code>","text":"<p>Convert back to an address.</p> Source code in <code>src/charli3_dendrite/dataclasses/datums.py</code> <pre><code>def to_address(self) -&gt; Address:\n    \"\"\"Convert back to an address.\"\"\"\n    payment_part = VerificationKeyHash(self.payment.address[:28])\n    if isinstance(self.stake, PlutusNone):\n        stake_part = None\n    else:\n        stake_part = VerificationKeyHash(self.stake.wrapped.wrapped.address[:28])\n    return Address(payment_part=payment_part, staking_part=stake_part)\n</code></pre>"},{"location":"datums/#charli3_dendrite.dataclasses.datums.PlutusNone","title":"<code>PlutusNone</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Placeholder for a receiver datum.</p> Source code in <code>src/charli3_dendrite/dataclasses/datums.py</code> <pre><code>@dataclass\nclass PlutusNone(PlutusData):\n    \"\"\"Placeholder for a receiver datum.\"\"\"\n\n    CONSTR_ID = 1\n</code></pre>"},{"location":"datums/#charli3_dendrite.dataclasses.datums.PlutusPartAddress","title":"<code>PlutusPartAddress</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Encode a plutus address part (i.e. payment, stake, etc).</p> Source code in <code>src/charli3_dendrite/dataclasses/datums.py</code> <pre><code>@dataclass\nclass PlutusPartAddress(PlutusData):\n    \"\"\"Encode a plutus address part (i.e. payment, stake, etc).\"\"\"\n\n    CONSTR_ID = 0\n    address: bytes\n</code></pre>"},{"location":"datums/#charli3_dendrite.dataclasses.datums.PlutusScriptAddress","title":"<code>PlutusScriptAddress</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusFullAddress</code></p> <p>A full address, including payment and staking keys.</p> Source code in <code>src/charli3_dendrite/dataclasses/datums.py</code> <pre><code>@dataclass\nclass PlutusScriptAddress(PlutusFullAddress):\n    \"\"\"A full address, including payment and staking keys.\"\"\"\n\n    payment: PlutusScriptPartAddress\n</code></pre>"},{"location":"datums/#charli3_dendrite.dataclasses.datums.PlutusScriptPartAddress","title":"<code>PlutusScriptPartAddress</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusPartAddress</code></p> <p>Encode a plutus address part (i.e. payment, stake, etc).</p> Source code in <code>src/charli3_dendrite/dataclasses/datums.py</code> <pre><code>@dataclass\nclass PlutusScriptPartAddress(PlutusPartAddress):\n    \"\"\"Encode a plutus address part (i.e. payment, stake, etc).\"\"\"\n\n    CONSTR_ID = 1\n</code></pre>"},{"location":"datums/#charli3_dendrite.dataclasses.datums.PoolDatum","title":"<code>PoolDatum</code>","text":"<p>               Bases: <code>PlutusData</code>, <code>ABC</code></p> <p>Abstract base class for all pool datum types.</p> Source code in <code>src/charli3_dendrite/dataclasses/datums.py</code> <pre><code>class PoolDatum(PlutusData, ABC):\n    \"\"\"Abstract base class for all pool datum types.\"\"\"\n\n    CONSTR_ID = 0\n\n    @abstractmethod\n    def pool_pair(self) -&gt; Union[Assets, None]:\n        \"\"\"Return the asset pair associated with the pool.\"\"\"\n        pass\n</code></pre>"},{"location":"datums/#charli3_dendrite.dataclasses.datums.PoolDatum.pool_pair","title":"<code>pool_pair() -&gt; Union[Assets, None]</code>  <code>abstractmethod</code>","text":"<p>Return the asset pair associated with the pool.</p> Source code in <code>src/charli3_dendrite/dataclasses/datums.py</code> <pre><code>@abstractmethod\ndef pool_pair(self) -&gt; Union[Assets, None]:\n    \"\"\"Return the asset pair associated with the pool.\"\"\"\n    pass\n</code></pre>"},{"location":"datums/#charli3_dendrite.dataclasses.datums.ReceiverDatum","title":"<code>ReceiverDatum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>The receiver address.</p> Source code in <code>src/charli3_dendrite/dataclasses/datums.py</code> <pre><code>@dataclass\nclass ReceiverDatum(PlutusData):\n    \"\"\"The receiver address.\"\"\"\n\n    CONSTR_ID = 0\n    datum_hash: Union[DatumHash, None] = None\n</code></pre>"},{"location":"dbsync_models/","title":"Models","text":""},{"location":"dbsync_models/#charli3_dendrite.backend.dbsync.models.AbstractDBSyncStructure","title":"<code>AbstractDBSyncStructure</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>src/charli3_dendrite/backend/dbsync/models.py</code> <pre><code>class AbstractDBSyncStructure(ABC):\n    @abstractclassmethod\n    def select(cls) -&gt; str:\n        \"\"\"The selectin part of a DBSync query.\"\"\"\n        raise NotImplementedError\n\n    @abstractclassmethod\n    def parse(cls, data: dict) -&gt; DendriteBaseModel:\n        \"\"\"Parse data returned from a dbsync query.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"dbsync_models/#charli3_dendrite.backend.dbsync.models.AbstractDBSyncStructure.parse","title":"<code>parse(data: dict) -&gt; DendriteBaseModel</code>","text":"<p>Parse data returned from a dbsync query.</p> Source code in <code>src/charli3_dendrite/backend/dbsync/models.py</code> <pre><code>@abstractclassmethod\ndef parse(cls, data: dict) -&gt; DendriteBaseModel:\n    \"\"\"Parse data returned from a dbsync query.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"dbsync_models/#charli3_dendrite.backend.dbsync.models.AbstractDBSyncStructure.select","title":"<code>select() -&gt; str</code>","text":"<p>The selectin part of a DBSync query.</p> Source code in <code>src/charli3_dendrite/backend/dbsync/models.py</code> <pre><code>@abstractclassmethod\ndef select(cls) -&gt; str:\n    \"\"\"The selectin part of a DBSync query.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"errors/","title":"Errors","text":"<p>Module defining custom exceptions for handling errors.</p>"},{"location":"errors/#charli3_dendrite.dexs.core.errors.InvalidLPError","title":"<code>InvalidLPError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Error raised when no LP is found in a pool utxo, and LP is expected.</p> Source code in <code>src/charli3_dendrite/dexs/core/errors.py</code> <pre><code>class InvalidLPError(Exception):\n    \"\"\"Error raised when no LP is found in a pool utxo, and LP is expected.\"\"\"\n\n    pass\n</code></pre>"},{"location":"errors/#charli3_dendrite.dexs.core.errors.InvalidPoolError","title":"<code>InvalidPoolError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Error raised when a utxo has pool data, but it is formatted incorrectly.</p> Source code in <code>src/charli3_dendrite/dexs/core/errors.py</code> <pre><code>class InvalidPoolError(Exception):\n    \"\"\"Error raised when a utxo has pool data, but it is formatted incorrectly.\"\"\"\n\n    pass\n</code></pre>"},{"location":"errors/#charli3_dendrite.dexs.core.errors.NoAssetsError","title":"<code>NoAssetsError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Error raised when no assets are in the pool, or it only contains lovelace.</p> Source code in <code>src/charli3_dendrite/dexs/core/errors.py</code> <pre><code>class NoAssetsError(Exception):\n    \"\"\"Error raised when no assets are in the pool, or it only contains lovelace.\"\"\"\n\n    pass\n</code></pre>"},{"location":"errors/#charli3_dendrite.dexs.core.errors.NotAPoolError","title":"<code>NotAPoolError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Error raised when a utxo is supplied and it does not contain pool data.</p> Source code in <code>src/charli3_dendrite/dexs/core/errors.py</code> <pre><code>class NotAPoolError(Exception):\n    \"\"\"Error raised when a utxo is supplied and it does not contain pool data.\"\"\"\n\n    pass\n</code></pre>"},{"location":"geniusyield/","title":"Genius Yield","text":"<p>Geniues Yield Order Book Module.</p>"},{"location":"geniusyield/#charli3_dendrite.dexs.ob.geniusyield.GeniusYieldOrderBook","title":"<code>GeniusYieldOrderBook</code>","text":"<p>               Bases: <code>AbstractOrderBookState</code></p> Source code in <code>src/charli3_dendrite/dexs/ob/geniusyield.py</code> <pre><code>class GeniusYieldOrderBook(AbstractOrderBookState):\n    fee: int = 30 / 1.003\n    _deposit: Assets = Assets(lovelace=0)\n\n    @classmethod\n    def get_book(cls, assets: Assets, orders: list[GeniusYieldOrderState] | None):\n        if orders is None:\n            selector = GeniusYieldOrderState.pool_selector()\n\n            result = get_pool_utxos(\n                limit=10000,\n                historical=False,\n                **selector.model_dump(),\n            )\n\n            orders = [\n                GeniusYieldOrderState.model_validate(r.model_dump()) for r in result\n            ]\n\n        # sort orders into buy and sell\n        buy_orders = []\n        sell_orders = []\n        for order in orders:\n            if order.inactive:\n                continue\n            price = order.price[0] / order.price[1]\n            o = OrderBookOrder(\n                price=price,\n                quantity=int(order.available.quantity()),\n                state=order,\n            )\n            if order.in_unit == assets.unit() and order.out_unit == assets.unit(1):\n                sell_orders.append(o)\n            elif order.in_unit == assets.unit(1) and order.out_unit == assets.unit(0):\n                buy_orders.append(o)\n\n        ob = GeniusYieldOrderBook(\n            assets=assets,\n            plutus_v2=False,\n            block_time=int(time.time()),\n            block_index=0,\n            sell_book_full=SellOrderBook(sell_orders),\n            buy_book_full=BuyOrderBook(buy_orders),\n        )\n\n        # GeniusYield recommends using a max of 3 orders in one tx because of mem limits\n        ob.sell_book_full = ob.sell_book_full[:3]\n        ob.buy_book_full = ob.buy_book_full[:3]\n\n        return ob\n\n    @classmethod\n    def dex(cls) -&gt; str:\n        return \"GeniusYield\"\n\n    @classmethod\n    def order_selector(self) -&gt; list[str]:\n        \"\"\"Order selection information.\"\"\"\n        return GeniusYieldOrderState.order_selector()\n\n    @classmethod\n    def pool_selector(self) -&gt; PoolSelector:\n        \"\"\"Pool selection information.\"\"\"\n        return GeniusYieldOrderState.pool_selector()\n\n    @property\n    def swap_forward(self) -&gt; bool:\n        return False\n\n    @classmethod\n    def default_script_class(cls):\n        return GeniusYieldOrderState.default_script_class\n\n    @classmethod\n    def order_datum_class(cls):\n        return GeniusYieldOrderState.order_datum_class()\n\n    @property\n    def pool_id(self) -&gt; str:\n        return \"GeniusYield\"\n\n    @property\n    def stake_address(self) -&gt; Address | None:\n        return None\n\n    def get_amount_out(\n        self,\n        asset: Assets,\n        precise: bool = True,\n        apply_fee: bool = True,\n    ) -&gt; tuple[Assets, float]:\n        return super().get_amount_out(asset=asset, precise=precise, apply_fee=apply_fee)\n\n    def get_amount_in(\n        self,\n        asset: Assets,\n        precise: bool = True,\n        apply_fee: bool = True,\n    ) -&gt; tuple[Assets, float]:\n        return super().get_amount_in(asset=asset, precise=precise, apply_fee=apply_fee)\n\n    def swap_utxo(\n        self,\n        address_source: Address,\n        in_assets: Assets,\n        out_assets: Assets,\n        tx_builder: TransactionBuilder,\n        extra_assets: Assets | None = None,\n        address_target: Address | None = None,\n        datum_target: PlutusData | None = None,\n    ) -&gt; tuple[TransactionOutput | None, PlutusData]:\n        if in_assets.unit() == self.assets.unit():\n            book = self.sell_book_full\n        else:\n            book = self.buy_book_full\n\n        in_total = Assets.model_validate(in_assets.model_dump())\n        fee_txo: TransactionOutput | None = None\n        fee_datum: GeniusYieldFeeDatum | None = None\n        txo: TransactionOutput | None = None\n        datum = None\n        for order in book:\n            if txo is not None:\n                if fee_txo is None:\n                    fee_txo = txo\n                    fee_datum = datum\n                else:\n                    fee_txo.amount += txo.amount\n                    fee_datum.fees.update(datum.fees)\n                    tx_builder._minting_script_to_redeemers.pop()\n\n            state = order.state\n\n            order_out, _ = state.get_amount_out(in_total)\n            order_in, _ = state.get_amount_in(order_out)\n\n            txo, datum = state.swap_utxo(\n                address_source=address_source,\n                in_assets=order_in,\n                out_assets=order_out,\n                tx_builder=tx_builder,\n            )\n\n            if fee_txo is not None:\n                txo.amount.coin -= 1000000\n\n                if not isinstance(datum, GeniusYieldFeeDatum):\n                    datum.contained_fee.lovelaces -= 1000000\n\n            in_total -= order_in\n\n            if in_total.quantity() &lt;= state.price[0] / state.price[1]:\n                break\n\n        if fee_txo is not None:\n            if isinstance(datum, GeniusYieldFeeDatum):\n                fee_txo.amount += txo.amount\n                fee_datum.fees.update(datum.fees)\n                tx_builder._minting_script_to_redeemers.pop()\n                txo = fee_txo\n                datum = fee_datum\n            else:\n                tx_builder.add_output(\n                    tx_out=fee_txo,\n                    datum=fee_datum,\n                    add_datum_to_witness=True,\n                )\n\n        return txo, datum\n</code></pre>"},{"location":"geniusyield/#charli3_dendrite.dexs.ob.geniusyield.GeniusYieldOrderBook.order_selector","title":"<code>order_selector() -&gt; list[str]</code>  <code>classmethod</code>","text":"<p>Order selection information.</p> Source code in <code>src/charli3_dendrite/dexs/ob/geniusyield.py</code> <pre><code>@classmethod\ndef order_selector(self) -&gt; list[str]:\n    \"\"\"Order selection information.\"\"\"\n    return GeniusYieldOrderState.order_selector()\n</code></pre>"},{"location":"geniusyield/#charli3_dendrite.dexs.ob.geniusyield.GeniusYieldOrderBook.pool_selector","title":"<code>pool_selector() -&gt; PoolSelector</code>  <code>classmethod</code>","text":"<p>Pool selection information.</p> Source code in <code>src/charli3_dendrite/dexs/ob/geniusyield.py</code> <pre><code>@classmethod\ndef pool_selector(self) -&gt; PoolSelector:\n    \"\"\"Pool selection information.\"\"\"\n    return GeniusYieldOrderState.pool_selector()\n</code></pre>"},{"location":"geniusyield/#charli3_dendrite.dexs.ob.geniusyield.GeniusYieldOrderState","title":"<code>GeniusYieldOrderState</code>","text":"<p>               Bases: <code>AbstractOrderState</code></p> <p>This class is largely used for OB dexes that allow direct script inputs.</p> Source code in <code>src/charli3_dendrite/dexs/ob/geniusyield.py</code> <pre><code>class GeniusYieldOrderState(AbstractOrderState):\n    \"\"\"This class is largely used for OB dexes that allow direct script inputs.\"\"\"\n\n    tx_hash: str\n    tx_index: int\n    datum_cbor: str\n    datum_hash: str\n    inactive: bool = False\n    fee: int = 30 / 1.003\n\n    _batcher: Assets = Assets(lovelace=1000000)\n    _datum_parsed: PlutusData | None = None\n    _deposit: Assets = Assets(lovelace=0)\n\n    @classmethod\n    def dex_policy(cls) -&gt; list[str] | None:\n        \"\"\"The dex nft policy.\n\n        This should be the policy or policy+name of the dex nft.\n\n        If None, then the default dex nft check is skipped.\n\n        Returns:\n            Optional[str]: policy or policy+name of dex nft\n        \"\"\"\n        return [\n            \"22f6999d4effc0ade05f6e1a70b702c65d6b3cdf0e301e4a8267f585\",\n            \"642c1f7bf79ca48c0f97239fcb2f3b42b92f2548184ab394e1e1e503\",\n        ]\n\n    @classmethod\n    def dex(cls) -&gt; str:\n        \"\"\"Official dex name.\"\"\"\n        return \"GeniusYield\"\n\n    @property\n    def volume_fee(self) -&gt; float:\n        return 30 / 1.003\n\n    @property\n    def reference_utxo(self) -&gt; UTxO | None:\n        order_info = get_backend().get_pool_in_tx(\n            self.tx_hash,\n            assets=[self.dex_nft.unit()],\n            addresses=self.pool_selector().addresses,\n        )\n\n        script = get_backend().get_script_from_address(\n            Address.decode(order_info[0].address),\n        )\n\n        return UTxO(\n            input=TransactionInput(\n                TransactionId(bytes.fromhex(script.tx_hash)),\n                index=script.tx_index,\n            ),\n            output=TransactionOutput(\n                address=script.address,\n                amount=asset_to_value(script.assets),\n                script=PlutusV2Script(bytes.fromhex(script.script)),\n            ),\n        )\n\n    @property\n    def fee_reference_utxo(self) -&gt; UTxO | None:\n        order_info = get_backend().get_pool_in_tx(\n            self.tx_hash,\n            assets=[self.dex_nft.unit()],\n            addresses=self.pool_selector().addresses,\n        )\n\n        if (\n            Address.decode(order_info[0].address).payment_part.payload.hex()\n            == \"a8d7ff5cf4c117270288372f9ac8e1ce5b758ae15a7851c41661a48c\"\n        ):\n            address = Address.decode(\n                \"addr1wxcqkdhe7qcfkqcnhlvepe7zmevdtsttv8vdfqlxrztaq2gge58rd\",\n            )\n            asset = \"fae686ea8f21d567841d703dea4d4221c2af071a6f2b433ff07c0af2682fd5d4b0d834a3aa219880fa193869b946ffb80dba5532abca0910c55ad5cd\"\n        else:\n            address = Address.decode(\n                \"addr1w9zr09hgj7z6vz3d7wnxw0u4x30arsp5k8avlcm84utptls8uqd0z\",\n            )\n            asset = \"fae686ea8f21d567841d703dea4d4221c2af071a6f2b433ff07c0af24aff78908ef2dce98bfe435fb3fd2529747b1c4564dff5adebedf4e46d0fc63d\"\n\n        script = get_backend().get_datum_from_address(address, asset=asset)\n\n        return UTxO(\n            input=TransactionInput(\n                TransactionId(bytes.fromhex(script.tx_hash)),\n                index=script.tx_index,\n            ),\n            output=TransactionOutput(\n                address=script.address,\n                amount=asset_to_value(script.assets),\n                datum=RawPlutusData.from_cbor(script.datum_cbor),\n            ),\n        )\n\n    @property\n    def mint_reference_utxo(self) -&gt; UTxO | None:\n        order_info = get_pool_in_tx(\n            self.tx_hash,\n            assets=[self.dex_nft.unit()],\n            **self.pool_selector().model_dump(exclude_defaults=True),\n        )\n        script = get_script_from_address(\n            Address(\n                payment_part=ScriptHash(\n                    payload=bytes.fromhex(self.dex_nft.unit()[:56]),\n                ),\n            ),\n        )\n\n        return UTxO(\n            input=TransactionInput(\n                TransactionId(bytes.fromhex(script.tx_hash)),\n                index=1,\n            ),\n            output=TransactionOutput(\n                address=script.address,\n                amount=asset_to_value(script.assets),\n                script=PlutusV2Script(bytes.fromhex(script.script)),\n            ),\n        )\n\n    @property\n    def settings_datum(self) -&gt; GeniusYieldSettings:\n        script = get_datum_from_address(\n            address=Address.decode(\n                \"addr1wxcqkdhe7qcfkqcnhlvepe7zmevdtsttv8vdfqlxrztaq2gge58rd\",\n            ),\n            asset=\"fae686ea8f21d567841d703dea4d4221c2af071a6f2b433ff07c0af2682fd5d4b0d834a3aa219880fa193869b946ffb80dba5532abca0910c55ad5cd\",\n        )\n\n        datum = RawPlutusData.from_cbor(script.datum_cbor)\n        return GeniusYieldSettings.from_cbor(script.datum_cbor)\n\n    def swap_utxo(\n        self,\n        address_source: Address,\n        in_assets: Assets,\n        out_assets: Assets,\n        tx_builder: TransactionBuilder,\n        extra_assets: Assets | None = None,\n        address_target: Address | None = None,\n        datum_target: PlutusData | None = None,\n    ) -&gt; tuple[TransactionOutput | None, PlutusData]:\n        order_info = get_backend().get_pool_in_tx(\n            self.tx_hash,\n            assets=[self.dex_nft.unit()],\n            addresses=self.pool_selector().addresses,\n        )\n\n        # Ensure the output matches required outputs\n        out_check, _ = self.get_amount_out(asset=in_assets)\n        assert out_check.quantity() == out_assets.quantity()\n\n        # Ensure user is not overpaying\n        in_check, _ = self.get_amount_in(asset=out_assets)\n        assert (\n            in_assets.quantity() - in_check.quantity()\n            == 0  # &lt;= self.price[0] / self.price[1]\n        )\n        original_assets = in_assets\n        in_assets = in_check\n\n        assets = self.assets + Assets(**{self.dex_nft.unit(): 1})\n        input_utxo = UTxO(\n            TransactionInput(\n                transaction_id=TransactionId(bytes.fromhex(self.tx_hash)),\n                index=self.tx_index,\n            ),\n            output=TransactionOutput(\n                address=order_info[0].address,\n                amount=asset_to_value(assets),\n                datum_hash=self.order_datum.hash(),\n            ),\n        )\n\n        if out_assets.quantity() &lt; self.available.quantity():\n            redeemer = Redeemer(\n                GeniusSubmitRedeemer(spend_amount=out_assets.quantity()),\n            )\n        else:\n            redeemer = Redeemer(GeniusCompleteRedeemer())\n        tx_builder.add_script_input(\n            utxo=input_utxo,\n            script=self.reference_utxo,\n            redeemer=redeemer,\n        )\n\n        tx_builder.reference_inputs.add(self.fee_reference_utxo)\n\n        order_datum = self.order_datum_class().from_cbor(self.order_datum.to_cbor())\n        order_datum.offered_amount -= out_assets.quantity()\n        order_datum.partial_fills += 1\n        order_datum.contained_fee.lovelaces += self.order_datum.maker_lovelace_fee\n        order_datum.contained_fee.asked_tokens += (\n            int(in_assets.quantity() * self.volume_fee) // 10000\n        )\n        order_datum.contained_payment += (\n            original_assets.quantity()\n            - int(in_assets.quantity() * self.volume_fee) // 10000\n        )\n        assets.root[in_assets.unit()] += original_assets.quantity()\n        assets.root[out_assets.unit()] -= out_assets.quantity()\n        assets += self._batcher\n\n        if out_assets.quantity() &lt; self.available.quantity():\n            txo = TransactionOutput(\n                address=order_info[0].address,\n                amount=asset_to_value(assets),\n                datum_hash=order_datum.hash(),\n            )\n        else:\n            settings = self.settings_datum\n\n            # Burn the beacon token\n            tx_builder.add_minting_script(\n                script=self.mint_reference_utxo,\n                redeemer=Redeemer(CancelRedeemer()),\n            )\n            if tx_builder.mint is None:\n                tx_builder.mint = asset_to_value(\n                    Assets(**{self.dex_nft.unit(): -1}),\n                ).multi_asset\n            else:\n                tx_builder.mint += asset_to_value(\n                    Assets(**{self.dex_nft.unit(): -1}),\n                ).multi_asset\n\n            # Pay the order owner\n            payment_assets = Assets(**{\"lovelace\": settings.min_deposit})\n\n            payment_assets += Assets(\n                **{\n                    self.in_unit: ceil(order_datum.contained_payment),\n                },\n            )\n            pay_datum = GeniusUTxORef(\n                tx_ref=GeniusTxRef(tx_hash=bytes.fromhex(self.tx_hash)),\n                index=self.tx_index,\n            )\n            txo = TransactionOutput(\n                address=order_datum.owner_address.to_address(),\n                amount=asset_to_value(payment_assets),\n                datum_hash=pay_datum.hash(),\n            )\n            tx_builder.datums.update({pay_datum.hash(): pay_datum})\n            tx_builder.add_output(txo)\n\n            # Pay the protocol fees\n            fee_assets = Assets(\n                **{\n                    \"lovelace\": self.order_datum.contained_fee.lovelaces,\n                },\n            )\n            fee_assets += Assets(\n                **{\n                    self.out_unit: self.order_datum.contained_fee.offered_tokens,\n                },\n            )\n            fee_assets += Assets(\n                **{self.in_unit: self.order_datum.contained_fee.asked_tokens},\n            )\n            fee_address = settings.fee_address.to_address()\n            asset_value = asset_to_value(fee_assets).to_primitive()\n            asset_dict = {b\"\": {b\"\": asset_value[0]}}\n            # asset_dict.update(asset_value[1])\n            for policy, v in asset_value[1].items():\n                for name, quantity in v.items():\n                    if quantity &gt; 0:\n                        asset_dict.update(asset_value[1])\n            fee_datum = GeniusYieldFeeDatum(\n                fees={pay_datum: asset_dict},\n                reserved_value={},\n            )\n            fee_assets.root[\"lovelace\"] += 1000000\n            fee_assets += Assets(\n                **{self.in_unit: (in_assets.quantity() * self.volume_fee) // 10000},\n            )\n            fee_txo = TransactionOutput(\n                address=fee_address,\n                amount=asset_to_value(assets=fee_assets),\n                datum_hash=fee_datum.hash(),\n            )\n            min_ada = min_lovelace(tx_builder.context, output=fee_txo)\n            if fee_txo.amount.coin &lt; min_ada:\n                fee_txo.amount.coin = min_ada\n\n            txo = fee_txo\n            order_datum = fee_datum\n\n        tx_builder.datums.update({self.order_datum.hash(): self.order_datum})\n\n        return txo, order_datum\n\n    @classmethod\n    def post_init(cls, values: dict[str, ...]):\n        super().post_init(values)\n        datum = cls.order_datum_class().from_cbor(values[\"datum_cbor\"])\n\n        ask_unit = datum.asked_asset.assets.unit()\n        offer_unit = datum.offered_asset.assets.unit()\n\n        if values[\"assets\"].unit() != ask_unit:\n            quantity = values[\"assets\"].root.pop(offer_unit)\n            values[\"assets\"].root[offer_unit] = quantity\n\n        values[\"inactive\"] = False\n        if (\n            datum.start_time.CONSTR_ID == 0\n            and datum.start_time.timestamp / 1000 &gt; time.time()\n        ):\n            values[\"inactive\"] = True\n        if (\n            datum.end_time.CONSTR_ID == 0\n            and datum.end_time.timestamp / 1000 &lt; time.time()\n        ):\n            values[\"inactive\"] = True\n\n        return values\n\n    def get_amount_out(self, asset: Assets, precise=True) -&gt; tuple[Assets, float]:\n        amount_out, slippage = super().get_amount_out(asset=asset, precise=precise)\n\n        if self.price[0] / self.price[1] &gt; 1:\n            new_asset = Assets.model_validate(asset.model_dump())\n            new_asset.root[self.in_unit] += 1\n            new_amount_out, _ = super().get_amount_out(asset=new_asset, precise=precise)\n\n            if new_amount_out.quantity() == amount_out.quantity():\n                while amount_out.quantity() == new_amount_out.quantity():\n                    new_asset.root[self.in_unit] -= 1\n                    new_amount_out, _ = super().get_amount_out(\n                        asset=new_asset,\n                        precise=precise,\n                    )\n\n                amount_out = new_amount_out\n\n        return amount_out, slippage\n\n    def get_amount_in(self, asset: Assets, precise=False) -&gt; tuple[Assets, float]:\n        fee = self.fee\n        self.fee *= 1.003\n        amount_in, slippage = super().get_amount_in(asset=asset, precise=precise)\n        self.fee = fee\n\n        amount_in.root[self.in_unit] = ceil(amount_in.quantity())\n\n        # get_amount_out is correct, this corrects nominal errors\n        amount_out, _ = self.get_amount_out(asset=amount_in)\n        while (\n            amount_out.quantity() &lt; asset.quantity()\n            and amount_out.quantity() &lt; self.available.quantity()\n        ):\n            amount_in.root[self.in_unit] += 1\n            amount_out, _ = self.get_amount_out(asset=amount_in)\n\n        temp_amount_in = Assets.model_validate(amount_in.model_dump())\n        amount_out, _ = self.get_amount_out(asset=amount_in)\n        temp_amount_in.root[temp_amount_in.unit()] -= 1\n        temp_amount_out, _ = self.get_amount_out(asset=temp_amount_in)\n        while temp_amount_out.quantity() == amount_out.quantity():\n            amount_in.root[self.in_unit] += temp_amount_out.quantity()\n            temp_amount_in.root[temp_amount_in.unit()] -= 1\n            temp_amount_out, _ = self.get_amount_out(asset=temp_amount_in)\n\n        return amount_in, slippage\n\n    @classmethod\n    def order_selector(cls) -&gt; list[str]:\n        \"\"\"Order selection information.\"\"\"\n        return [\n            \"addr1wx5d0l6u7nq3wfcz3qmjlxkgu889kav2u9d8s5wyzes6frqktgru2\",\n            \"addr1w8kllanr6dlut7t480zzytsd52l7pz4y3kcgxlfvx2ddavcshakwd\",\n        ]\n\n    @classmethod\n    def pool_selector(cls) -&gt; PoolSelector:\n        return PoolSelector(\n            addresses=[\n                \"addr1wx5d0l6u7nq3wfcz3qmjlxkgu889kav2u9d8s5wyzes6frqktgru2\",\n                \"addr1w8kllanr6dlut7t480zzytsd52l7pz4y3kcgxlfvx2ddavcshakwd\",\n            ],\n        )\n\n    @property\n    def swap_forward(self) -&gt; bool:\n        return True\n\n    @property\n    def stake_address(self) -&gt; Address | None:\n        return None\n\n    @classmethod\n    def order_datum_class(self) -&gt; type[PlutusData]:\n        return GeniusYieldOrder\n\n    @classmethod\n    def default_script_class(self) -&gt; type[PlutusV1Script] | type[PlutusV2Script]:\n        return PlutusV2Script\n\n    @property\n    def price(self) -&gt; tuple[int, int]:\n        # if self.assets.unit() == Assets.model_validate(self.assets.model_dump()).unit():\n        return [\n            self.order_datum.price.numerator,\n            self.order_datum.price.denominator,\n        ]\n\n    @property\n    def available(self) -&gt; Assets:\n        \"\"\"Max amount of output asset that can be used to fill the order.\"\"\"\n        return Assets(**{self.out_unit: self.order_datum.offered_amount})\n\n    @property\n    def tvl(self) -&gt; int:\n        \"\"\"Return the total value locked in the order\n\n        Raises:\n            NotImplementedError: Only ADA pool TVL is implemented.\n        \"\"\"\n        return self.available\n\n    @property\n    def pool_id(self) -&gt; str:\n        \"\"\"A unique identifier for the pool or ob.\n\n        Raises:\n            NotImplementedError: Only ADA pool TVL is implemented.\n        \"\"\"\n        return self.dex_nft.unit()\n</code></pre>"},{"location":"geniusyield/#charli3_dendrite.dexs.ob.geniusyield.GeniusYieldOrderState.available","title":"<code>available: Assets</code>  <code>property</code>","text":"<p>Max amount of output asset that can be used to fill the order.</p>"},{"location":"geniusyield/#charli3_dendrite.dexs.ob.geniusyield.GeniusYieldOrderState.pool_id","title":"<code>pool_id: str</code>  <code>property</code>","text":"<p>A unique identifier for the pool or ob.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Only ADA pool TVL is implemented.</p>"},{"location":"geniusyield/#charli3_dendrite.dexs.ob.geniusyield.GeniusYieldOrderState.tvl","title":"<code>tvl: int</code>  <code>property</code>","text":"<p>Return the total value locked in the order</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Only ADA pool TVL is implemented.</p>"},{"location":"geniusyield/#charli3_dendrite.dexs.ob.geniusyield.GeniusYieldOrderState.dex","title":"<code>dex() -&gt; str</code>  <code>classmethod</code>","text":"<p>Official dex name.</p> Source code in <code>src/charli3_dendrite/dexs/ob/geniusyield.py</code> <pre><code>@classmethod\ndef dex(cls) -&gt; str:\n    \"\"\"Official dex name.\"\"\"\n    return \"GeniusYield\"\n</code></pre>"},{"location":"geniusyield/#charli3_dendrite.dexs.ob.geniusyield.GeniusYieldOrderState.dex_policy","title":"<code>dex_policy() -&gt; list[str] | None</code>  <code>classmethod</code>","text":"<p>The dex nft policy.</p> <p>This should be the policy or policy+name of the dex nft.</p> <p>If None, then the default dex nft check is skipped.</p> <p>Returns:</p> Type Description <code>list[str] | None</code> <p>Optional[str]: policy or policy+name of dex nft</p> Source code in <code>src/charli3_dendrite/dexs/ob/geniusyield.py</code> <pre><code>@classmethod\ndef dex_policy(cls) -&gt; list[str] | None:\n    \"\"\"The dex nft policy.\n\n    This should be the policy or policy+name of the dex nft.\n\n    If None, then the default dex nft check is skipped.\n\n    Returns:\n        Optional[str]: policy or policy+name of dex nft\n    \"\"\"\n    return [\n        \"22f6999d4effc0ade05f6e1a70b702c65d6b3cdf0e301e4a8267f585\",\n        \"642c1f7bf79ca48c0f97239fcb2f3b42b92f2548184ab394e1e1e503\",\n    ]\n</code></pre>"},{"location":"geniusyield/#charli3_dendrite.dexs.ob.geniusyield.GeniusYieldOrderState.order_selector","title":"<code>order_selector() -&gt; list[str]</code>  <code>classmethod</code>","text":"<p>Order selection information.</p> Source code in <code>src/charli3_dendrite/dexs/ob/geniusyield.py</code> <pre><code>@classmethod\ndef order_selector(cls) -&gt; list[str]:\n    \"\"\"Order selection information.\"\"\"\n    return [\n        \"addr1wx5d0l6u7nq3wfcz3qmjlxkgu889kav2u9d8s5wyzes6frqktgru2\",\n        \"addr1w8kllanr6dlut7t480zzytsd52l7pz4y3kcgxlfvx2ddavcshakwd\",\n    ]\n</code></pre>"},{"location":"minswap/","title":"Minswap","text":"<p>Minswap DEX Module.</p>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.Deposit","title":"<code>Deposit</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Swap exact in order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass Deposit(PlutusData):\n    \"\"\"Swap exact in order datum.\"\"\"\n\n    CONSTR_ID = 2\n    minimum_lp: int\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.DepositV2","title":"<code>DepositV2</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>DepositV2 order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass DepositV2(PlutusData):\n    \"\"\"DepositV2 order datum.\"\"\"\n\n    CONSTR_ID = 4\n    deposit_amount_option: Datum\n    minimum_lp: int\n    killable: Union[BoolTrue, BoolFalse]\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.DonationV2","title":"<code>DonationV2</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>SwapMultiRoutingV2 order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass DonationV2(PlutusData):\n    \"\"\"SwapMultiRoutingV2 order datum.\"\"\"\n\n    CONSTR_ID = 10\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.Expire","title":"<code>Expire</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>SwapMultiRoutingV2 order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass Expire(PlutusData):\n    \"\"\"SwapMultiRoutingV2 order datum.\"\"\"\n\n    CONSTR_ID = 0\n\n    ttl: List[int]\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.FeeDatumHash","title":"<code>FeeDatumHash</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Fee datum hash.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass FeeDatumHash(PlutusData):\n    \"\"\"Fee datum hash.\"\"\"\n\n    CONSTR_ID = 0\n    fee_hash: bytes\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.FeeSwitchOn","title":"<code>FeeSwitchOn</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Fee switch on.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass FeeSwitchOn(PlutusData):\n    \"\"\"Fee switch on.\"\"\"\n\n    CONSTR_ID = 0\n    address: PlutusFullAddress\n    fee_to_datum_hash: PlutusNone\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapCPPState","title":"<code>MinswapCPPState</code>","text":"<p>               Bases: <code>AbstractConstantProductPoolState</code></p> <p>Minswap Constant Product Pool State.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>class MinswapCPPState(AbstractConstantProductPoolState):\n    \"\"\"Minswap Constant Product Pool State.\"\"\"\n\n    fee: int = 30\n    _batcher = Assets(lovelace=2000000)\n    _deposit = Assets(lovelace=2000000)\n    _stake_address: ClassVar[Address] = [\n        Address.from_primitive(\n            \"addr1zxn9efv2f6w82hagxqtn62ju4m293tqvw0uhmdl64ch8uw6j2c79gy9l76sdg0xwhd7r0c0kna0tycz4y5s6mlenh8pq6s3z70\",\n        ),\n        Address.from_primitive(\n            \"addr1wxn9efv2f6w82hagxqtn62ju4m293tqvw0uhmdl64ch8uwc0h43gt\",\n        ),\n    ]\n\n    @classmethod\n    def dex(cls) -&gt; str:\n        return \"Minswap\"\n\n    @classmethod\n    def order_selector(self) -&gt; list[str]:\n        return [s.encode() for s in self._stake_address]\n\n    @classmethod\n    def pool_selector(cls) -&gt; PoolSelector:\n        return PoolSelector(\n            addresses=[\"addr1w8snz7c4974vzdpxu65ruphl3zjdvtxw8strf2c2tmqnxzgusf9xw\"],\n            assets=[\n                \"13aa2accf2e1561723aa26871e071fdf32c867cff7e7d50ad470d62f4d494e53574150\",\n            ],\n        )\n\n    @property\n    def swap_forward(self) -&gt; bool:\n        return True\n\n    @property\n    def stake_address(self) -&gt; Address:\n        return self._stake_address[0]\n\n    @classmethod\n    def order_datum_class(self) -&gt; type[MinswapOrderDatum]:\n        return MinswapOrderDatum\n\n    @classmethod\n    def script_class(self) -&gt; type[MinswapOrderDatum]:\n        return PlutusV1Script\n\n    @classmethod\n    def pool_datum_class(self) -&gt; type[MinswapPoolDatum]:\n        return MinswapPoolDatum\n\n    def batcher_fee(\n        self,\n        in_assets: Assets | None = None,\n        out_assets: Assets | None = None,\n        extra_assets: Assets | None = None,\n    ) -&gt; Assets:\n        \"\"\"Batcher fee.\n\n        For Minswap, the batcher fee decreases linearly from 2.0 ADA to 1.5 ADA as the\n        MIN in the input assets from 0 - 50,000 MIN.\n        \"\"\"\n        MIN = \"29d222ce763455e3d7a09a665ce554f00ac89d2e99a1a83d267170c64d494e\"\n        if extra_assets is not None and MIN in extra_assets:\n            fee_reduction = min(extra_assets[MIN] // 10**5, 500000)\n        else:\n            fee_reduction = 0\n        return self._batcher - Assets(lovelace=fee_reduction)\n\n    @property\n    def pool_id(self) -&gt; str:\n        \"\"\"A unique identifier for the pool.\"\"\"\n        return self.pool_nft.unit()\n\n    @classmethod\n    def pool_policy(cls) -&gt; list[str]:\n        return [\"0be55d262b29f564998ff81efe21bdc0022621c12f15af08d0f2ddb1\"]\n\n    @classmethod\n    def lp_policy(cls) -&gt; list[str]:\n        return [\"e4214b7cce62ac6fbba385d164df48e157eae5863521b4b67ca71d86\"]\n\n    @classmethod\n    def dex_policy(cls) -&gt; list[str]:\n        return [\"13aa2accf2e1561723aa26871e071fdf32c867cff7e7d50ad470d62f\"]\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapCPPState.pool_id","title":"<code>pool_id: str</code>  <code>property</code>","text":"<p>A unique identifier for the pool.</p>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapCPPState.batcher_fee","title":"<code>batcher_fee(in_assets: Assets | None = None, out_assets: Assets | None = None, extra_assets: Assets | None = None) -&gt; Assets</code>","text":"<p>Batcher fee.</p> <p>For Minswap, the batcher fee decreases linearly from 2.0 ADA to 1.5 ADA as the MIN in the input assets from 0 - 50,000 MIN.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>def batcher_fee(\n    self,\n    in_assets: Assets | None = None,\n    out_assets: Assets | None = None,\n    extra_assets: Assets | None = None,\n) -&gt; Assets:\n    \"\"\"Batcher fee.\n\n    For Minswap, the batcher fee decreases linearly from 2.0 ADA to 1.5 ADA as the\n    MIN in the input assets from 0 - 50,000 MIN.\n    \"\"\"\n    MIN = \"29d222ce763455e3d7a09a665ce554f00ac89d2e99a1a83d267170c64d494e\"\n    if extra_assets is not None and MIN in extra_assets:\n        fee_reduction = min(extra_assets[MIN] // 10**5, 500000)\n    else:\n        fee_reduction = 0\n    return self._batcher - Assets(lovelace=fee_reduction)\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapDJEDUSDCStablePoolDatum","title":"<code>MinswapDJEDUSDCStablePoolDatum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MinswapStablePoolDatum</code></p> <p>Pool Datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass MinswapDJEDUSDCStablePoolDatum(MinswapStablePoolDatum):\n    \"\"\"Pool Datum.\"\"\"\n\n    CONSTR_ID = 0\n\n    def pool_pair(self) -&gt; Assets | None:\n        \"\"\"Return the asset pair associated with the pool.\"\"\"\n        return Assets(\n            **{\n                \"8db269c3ec630e06ae29f74bc39edd1f87c819f1056206e879a1cd61446a65644d6963726f555344\": 0,\n                \"25c5de5f5b286073c593edfd77b48abc7a48e5a4f3d4cd9d428ff93555534443\": 0,\n            },\n        )\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapDJEDUSDCStablePoolDatum.pool_pair","title":"<code>pool_pair() -&gt; Assets | None</code>","text":"<p>Return the asset pair associated with the pool.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>def pool_pair(self) -&gt; Assets | None:\n    \"\"\"Return the asset pair associated with the pool.\"\"\"\n    return Assets(\n        **{\n            \"8db269c3ec630e06ae29f74bc39edd1f87c819f1056206e879a1cd61446a65644d6963726f555344\": 0,\n            \"25c5de5f5b286073c593edfd77b48abc7a48e5a4f3d4cd9d428ff93555534443\": 0,\n        },\n    )\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapDJEDUSDCStableState","title":"<code>MinswapDJEDUSDCStableState</code>","text":"<p>               Bases: <code>MinswapDJEDiUSDStableState</code></p> <p>Minswap DJED/USDC Stable State.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>class MinswapDJEDUSDCStableState(MinswapDJEDiUSDStableState):\n    \"\"\"Minswap DJED/USDC Stable State.\"\"\"\n\n    asset_mulitipliers: list[int] = [1, 100]\n\n    _stake_address: ClassVar[Address] = [\n        Address.from_primitive(\n            \"addr1w93d8cuht3hvqt2qqfjqgyek3gk5d6ss2j93e5sh505m0ng8cmze2\",\n        ),\n    ]\n\n    @classmethod\n    def pool_selector(cls) -&gt; PoolSelector:\n        return PoolSelector(\n            addresses=[\"addr1wx8d45xlfrlxd7tctve8xgdtk59j849n00zz2pgyvv47t8sxa6t53\"],\n            assets=[\n                \"d97fa91daaf63559a253970365fb219dc4364c028e5fe0606cdbfff9555344432d444a45442d534c50\",\n            ],\n        )\n\n    @classmethod\n    def pool_datum_class(self) -&gt; type[MinswapDJEDUSDCStablePoolDatum]:\n        return MinswapDJEDUSDCStablePoolDatum\n\n    @classmethod\n    def pool_policy(cls) -&gt; list[str]:\n        return [\n            \"d97fa91daaf63559a253970365fb219dc4364c028e5fe0606cdbfff9555344432d444a45442d534c50\",\n        ]\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapDJEDUSDMStablePoolDatum","title":"<code>MinswapDJEDUSDMStablePoolDatum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MinswapStablePoolDatum</code></p> <p>Pool Datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass MinswapDJEDUSDMStablePoolDatum(MinswapStablePoolDatum):\n    \"\"\"Pool Datum.\"\"\"\n\n    CONSTR_ID = 0\n\n    def pool_pair(self) -&gt; Assets | None:\n        return Assets(\n            **{\n                \"8db269c3ec630e06ae29f74bc39edd1f87c819f1056206e879a1cd61446a65644d6963726f555344\": 0,\n                \"c48cbb3d5e57ed56e276bc45f99ab39abe94e6cd7ac39fb402da47ad0014df105553444d\": 0,\n            },\n        )\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapDJEDiUSDStablePoolDatum","title":"<code>MinswapDJEDiUSDStablePoolDatum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MinswapStablePoolDatum</code></p> <p>Pool Datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass MinswapDJEDiUSDStablePoolDatum(MinswapStablePoolDatum):\n    \"\"\"Pool Datum.\"\"\"\n\n    CONSTR_ID = 0\n\n    def pool_pair(self) -&gt; Assets | None:\n        \"\"\"Return the asset pair associated with the pool.\"\"\"\n        return Assets(\n            **{\n                \"8db269c3ec630e06ae29f74bc39edd1f87c819f1056206e879a1cd61446a65644d6963726f555344\": 0,\n                \"f66d78b4a3cb3d37afa0ec36461e51ecbde00f26c8f0a68f94b6988069555344\": 0,\n            },\n        )\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapDJEDiUSDStablePoolDatum.pool_pair","title":"<code>pool_pair() -&gt; Assets | None</code>","text":"<p>Return the asset pair associated with the pool.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>def pool_pair(self) -&gt; Assets | None:\n    \"\"\"Return the asset pair associated with the pool.\"\"\"\n    return Assets(\n        **{\n            \"8db269c3ec630e06ae29f74bc39edd1f87c819f1056206e879a1cd61446a65644d6963726f555344\": 0,\n            \"f66d78b4a3cb3d37afa0ec36461e51ecbde00f26c8f0a68f94b6988069555344\": 0,\n        },\n    )\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapDJEDiUSDStableState","title":"<code>MinswapDJEDiUSDStableState</code>","text":"<p>               Bases: <code>AbstractCommonStableSwapPoolState</code>, <code>MinswapCPPState</code></p> <p>Minswap DJED/iUSD Stable State.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>class MinswapDJEDiUSDStableState(AbstractCommonStableSwapPoolState, MinswapCPPState):\n    \"\"\"Minswap DJED/iUSD Stable State.\"\"\"\n\n    fee: float = 1\n    _batcher = Assets(lovelace=2000000)\n    _deposit = Assets(lovelace=2000000)\n    _stake_address: ClassVar[Address] = [\n        Address.from_primitive(\n            \"addr1w9xy6edqv9hkptwzewns75ehq53nk8t73je7np5vmj3emps698n9g\",\n        ),\n    ]\n\n    @classmethod\n    def order_datum_class(cls) -&gt; type[MinswapStableOrderDatum]:\n        return MinswapStableOrderDatum\n\n    def get_amount_out(\n        self,\n        asset: Assets,\n        precise: bool = True,\n    ) -&gt; tuple[Assets, float]:\n        out_asset, slippage = super().get_amount_out(\n            asset=asset,\n            precise=precise,\n            fee_on_input=False,\n        )\n\n        return out_asset, slippage\n\n    def get_amount_in(\n        self,\n        asset: Assets,\n        precise: bool = True,\n    ) -&gt; tuple[Assets, float]:\n        in_asset, slippage = super().get_amount_in(\n            asset=asset,\n            precise=precise,\n            fee_on_input=False,\n        )\n\n        return in_asset, slippage\n\n    @classmethod\n    def post_init(cls, values: dict[str, ...]):\n        \"\"\"Post initialization checks.\n\n        Args:\n            values: The pool initialization parameters\n        \"\"\"\n        super().post_init(values)\n        assets = values[\"assets\"]\n\n        datum = cls.pool_datum_class().from_cbor(values[\"datum_cbor\"])\n\n        assets.root[assets.unit()] = datum.balances[0]\n        assets.root[assets.unit(1)] = datum.balances[1]\n\n        return values\n\n    @property\n    def amp(self) -&gt; int:\n        return self.pool_datum.amp\n\n    @classmethod\n    def pool_selector(cls) -&gt; PoolSelector:\n        return PoolSelector(\n            addresses=[\"addr1wy7kkcpuf39tusnnyga5t2zcul65dwx9yqzg7sep3cjscesx2q5m5\"],\n            assets=[\n                \"5d4b6afd3344adcf37ccef5558bb87f522874578c32f17160512e398444a45442d695553442d534c50\",\n            ],\n        )\n\n    @classmethod\n    def pool_datum_class(self) -&gt; type[MinswapDJEDiUSDStablePoolDatum]:\n        return MinswapDJEDiUSDStablePoolDatum\n\n    @property\n    def pool_id(self) -&gt; str:\n        \"\"\"A unique identifier for the pool.\"\"\"\n        return self.pool_nft.unit()\n\n    @classmethod\n    def pool_policy(cls) -&gt; list[str]:\n        return [\n            \"5d4b6afd3344adcf37ccef5558bb87f522874578c32f17160512e398444a45442d695553442d534c50\",\n        ]\n\n    @classmethod\n    def lp_policy(cls) -&gt; list[str] | None:\n        return None\n\n    @classmethod\n    def dex_policy(cls) -&gt; list[str] | None:\n        return None\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapDJEDiUSDStableState.pool_id","title":"<code>pool_id: str</code>  <code>property</code>","text":"<p>A unique identifier for the pool.</p>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapDJEDiUSDStableState.post_init","title":"<code>post_init(values: dict[str, ...])</code>  <code>classmethod</code>","text":"<p>Post initialization checks.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>dict[str, ...]</code> <p>The pool initialization parameters</p> required Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@classmethod\ndef post_init(cls, values: dict[str, ...]):\n    \"\"\"Post initialization checks.\n\n    Args:\n        values: The pool initialization parameters\n    \"\"\"\n    super().post_init(values)\n    assets = values[\"assets\"]\n\n    datum = cls.pool_datum_class().from_cbor(values[\"datum_cbor\"])\n\n    assets.root[assets.unit()] = datum.balances[0]\n    assets.root[assets.unit(1)] = datum.balances[1]\n\n    return values\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapOrderDatum","title":"<code>MinswapOrderDatum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OrderDatum</code></p> <p>An order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass MinswapOrderDatum(OrderDatum):\n    \"\"\"An order datum.\"\"\"\n\n    sender: PlutusFullAddress\n    receiver: PlutusFullAddress\n    receiver_datum_hash: Union[ReceiverDatum, PlutusNone]\n    step: Union[\n        SwapExactIn,\n        SwapExactOut,\n        Deposit,\n        Withdraw,\n        ZapIn,\n        StableSwapExactIn,\n        StableSwapDeposit,\n        StableSwapWithdraw,\n        StableSwapWithdrawOneCoin,\n    ]\n    batcher_fee: int\n    deposit: int\n\n    @classmethod\n    def create_datum(\n        cls,\n        address_source: Address,\n        in_assets: Assets,\n        out_assets: Assets,\n        batcher_fee: Assets,\n        deposit: Assets,\n        address_target: Address | None = None,\n        datum_target: PlutusData | None = None,\n    ):\n        \"\"\"Create an order datum.\"\"\"\n        full_address_source = PlutusFullAddress.from_address(address_source)\n        step = SwapExactIn.from_assets(out_assets)\n\n        if address_target is None:\n            address_target = address_source\n            datum_target = PlutusNone()\n        elif datum_target is None:\n            datum_target = PlutusNone()\n\n        full_address_target = PlutusFullAddress.from_address(address_target)\n\n        return cls(\n            full_address_source,\n            full_address_target,\n            datum_target,\n            step,\n            batcher_fee.quantity(),\n            deposit.quantity(),\n        )\n\n    def address_source(self) -&gt; Address:\n        \"\"\"The source address.\"\"\"\n        return self.sender.to_address()\n\n    def requested_amount(self) -&gt; Assets:\n        \"\"\"The requested amount.\"\"\"\n        if isinstance(self.step, SwapExactIn):\n            return Assets(\n                {self.step.desired_coin.assets.unit(): self.step.minimum_receive},\n            )\n        elif isinstance(self.step, SwapExactOut):\n            return Assets(\n                {self.step.desired_coin.assets.unit(): self.step.expected_receive},\n            )\n        elif isinstance(self.step, Deposit):\n            return Assets({\"lp\": self.step.minimum_lp})\n        elif isinstance(self.step, Withdraw):\n            return Assets(\n                {\"asset_a\": self.step.min_asset_a, \"asset_b\": self.step.min_asset_a},\n            )\n        elif isinstance(self.step, ZapIn):\n            return Assets({self.step.desired_coin.assets.unit(): self.step.minimum_lp})\n\n    def order_type(self) -&gt; OrderType | None:\n        \"\"\"The order type.\"\"\"\n        order_type = None\n        if isinstance(self.step, (SwapExactIn, SwapExactOut, StableSwapExactIn)):\n            order_type = OrderType.swap\n        elif isinstance(self.step, (Deposit, StableSwapDeposit, ZapIn)):\n            order_type = OrderType.deposit\n        elif isinstance(\n            self.step,\n            (Withdraw, StableSwapWithdraw, StableSwapWithdrawOneCoin),\n        ):\n            order_type = OrderType.withdraw\n\n        return order_type\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapOrderDatum.address_source","title":"<code>address_source() -&gt; Address</code>","text":"<p>The source address.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>def address_source(self) -&gt; Address:\n    \"\"\"The source address.\"\"\"\n    return self.sender.to_address()\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapOrderDatum.create_datum","title":"<code>create_datum(address_source: Address, in_assets: Assets, out_assets: Assets, batcher_fee: Assets, deposit: Assets, address_target: Address | None = None, datum_target: PlutusData | None = None)</code>  <code>classmethod</code>","text":"<p>Create an order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@classmethod\ndef create_datum(\n    cls,\n    address_source: Address,\n    in_assets: Assets,\n    out_assets: Assets,\n    batcher_fee: Assets,\n    deposit: Assets,\n    address_target: Address | None = None,\n    datum_target: PlutusData | None = None,\n):\n    \"\"\"Create an order datum.\"\"\"\n    full_address_source = PlutusFullAddress.from_address(address_source)\n    step = SwapExactIn.from_assets(out_assets)\n\n    if address_target is None:\n        address_target = address_source\n        datum_target = PlutusNone()\n    elif datum_target is None:\n        datum_target = PlutusNone()\n\n    full_address_target = PlutusFullAddress.from_address(address_target)\n\n    return cls(\n        full_address_source,\n        full_address_target,\n        datum_target,\n        step,\n        batcher_fee.quantity(),\n        deposit.quantity(),\n    )\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapOrderDatum.order_type","title":"<code>order_type() -&gt; OrderType | None</code>","text":"<p>The order type.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>def order_type(self) -&gt; OrderType | None:\n    \"\"\"The order type.\"\"\"\n    order_type = None\n    if isinstance(self.step, (SwapExactIn, SwapExactOut, StableSwapExactIn)):\n        order_type = OrderType.swap\n    elif isinstance(self.step, (Deposit, StableSwapDeposit, ZapIn)):\n        order_type = OrderType.deposit\n    elif isinstance(\n        self.step,\n        (Withdraw, StableSwapWithdraw, StableSwapWithdrawOneCoin),\n    ):\n        order_type = OrderType.withdraw\n\n    return order_type\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapOrderDatum.requested_amount","title":"<code>requested_amount() -&gt; Assets</code>","text":"<p>The requested amount.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>def requested_amount(self) -&gt; Assets:\n    \"\"\"The requested amount.\"\"\"\n    if isinstance(self.step, SwapExactIn):\n        return Assets(\n            {self.step.desired_coin.assets.unit(): self.step.minimum_receive},\n        )\n    elif isinstance(self.step, SwapExactOut):\n        return Assets(\n            {self.step.desired_coin.assets.unit(): self.step.expected_receive},\n        )\n    elif isinstance(self.step, Deposit):\n        return Assets({\"lp\": self.step.minimum_lp})\n    elif isinstance(self.step, Withdraw):\n        return Assets(\n            {\"asset_a\": self.step.min_asset_a, \"asset_b\": self.step.min_asset_a},\n        )\n    elif isinstance(self.step, ZapIn):\n        return Assets({self.step.desired_coin.assets.unit(): self.step.minimum_lp})\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapPoolDatum","title":"<code>MinswapPoolDatum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PoolDatum</code></p> <p>Pool Datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass MinswapPoolDatum(PoolDatum):\n    \"\"\"Pool Datum.\"\"\"\n\n    CONSTR_ID = 0\n\n    asset_a: AssetClass\n    asset_b: AssetClass\n    total_liquidity: int\n    root_k_last: int\n    fee_sharing: Union[_FeeSwitchWrapper, PlutusNone]\n\n    def pool_pair(self) -&gt; Assets | None:\n        \"\"\"Return the asset pair associated with the pool.\"\"\"\n        return self.asset_a.assets + self.asset_b.assets\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapPoolDatum.pool_pair","title":"<code>pool_pair() -&gt; Assets | None</code>","text":"<p>Return the asset pair associated with the pool.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>def pool_pair(self) -&gt; Assets | None:\n    \"\"\"Return the asset pair associated with the pool.\"\"\"\n    return self.asset_a.assets + self.asset_b.assets\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapStableOrderDatum","title":"<code>MinswapStableOrderDatum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MinswapOrderDatum</code></p> <p>MinSwap Stable Order Datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass MinswapStableOrderDatum(MinswapOrderDatum):\n    \"\"\"MinSwap Stable Order Datum.\"\"\"\n\n    @classmethod\n    def create_datum(\n        cls,\n        address_source: Address,\n        in_assets: Assets,\n        out_assets: Assets,\n        batcher_fee: Assets,\n        deposit: Assets,\n        address_target: Address | None = None,\n        datum_target: PlutusData | None = None,\n    ):\n        \"\"\"Create an order datum.\"\"\"\n        full_address_source = PlutusFullAddress.from_address(address_source)\n        step = StableSwapExactIn.from_assets(in_assets=in_assets, out_assets=out_assets)\n\n        if address_target is None:\n            address_target = address_source\n            datum_target = PlutusNone()\n        elif datum_target is None:\n            datum_target = PlutusNone()\n\n        full_address_target = PlutusFullAddress.from_address(address_target)\n\n        return cls(\n            full_address_source,\n            full_address_target,\n            datum_target,\n            step,\n            batcher_fee.quantity(),\n            deposit.quantity(),\n        )\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapStableOrderDatum.create_datum","title":"<code>create_datum(address_source: Address, in_assets: Assets, out_assets: Assets, batcher_fee: Assets, deposit: Assets, address_target: Address | None = None, datum_target: PlutusData | None = None)</code>  <code>classmethod</code>","text":"<p>Create an order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@classmethod\ndef create_datum(\n    cls,\n    address_source: Address,\n    in_assets: Assets,\n    out_assets: Assets,\n    batcher_fee: Assets,\n    deposit: Assets,\n    address_target: Address | None = None,\n    datum_target: PlutusData | None = None,\n):\n    \"\"\"Create an order datum.\"\"\"\n    full_address_source = PlutusFullAddress.from_address(address_source)\n    step = StableSwapExactIn.from_assets(in_assets=in_assets, out_assets=out_assets)\n\n    if address_target is None:\n        address_target = address_source\n        datum_target = PlutusNone()\n    elif datum_target is None:\n        datum_target = PlutusNone()\n\n    full_address_target = PlutusFullAddress.from_address(address_target)\n\n    return cls(\n        full_address_source,\n        full_address_target,\n        datum_target,\n        step,\n        batcher_fee.quantity(),\n        deposit.quantity(),\n    )\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapStablePoolDatum","title":"<code>MinswapStablePoolDatum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Stable Pool Datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass MinswapStablePoolDatum(PlutusData):\n    \"\"\"Stable Pool Datum.\"\"\"\n\n    CONSTR_ID = 0\n\n    balances: List[int]\n    total_liquidity: int\n    amp: int\n    order_hash: bytes\n\n    def pool_pair(self) -&gt; Assets | None:\n        \"\"\"Return the asset pair associated with the pool.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapStablePoolDatum.pool_pair","title":"<code>pool_pair() -&gt; Assets | None</code>","text":"<p>Return the asset pair associated with the pool.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>def pool_pair(self) -&gt; Assets | None:\n    \"\"\"Return the asset pair associated with the pool.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapV2CPPState","title":"<code>MinswapV2CPPState</code>","text":"<p>               Bases: <code>AbstractConstantProductPoolState</code></p> <p>Minswap Constant Product Pool State.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>class MinswapV2CPPState(AbstractConstantProductPoolState):\n    \"\"\"Minswap Constant Product Pool State.\"\"\"\n\n    fee: int | list[int] = [30, 30]\n    _batcher = Assets(lovelace=1000000)\n    _deposit = Assets(lovelace=2000000)\n    _stake_address: ClassVar[Address] = [\n        Address.from_primitive(\n            \"addr1z8p79rpkcdz8x9d6tft0x0dx5mwuzac2sa4gm8cvkw5hcn864negmna25tfcqjjxj65tnk0d0fmkza3gjdrxweaff35q0ym7k8\",\n        ),\n    ]\n\n    @classmethod\n    def dex(cls) -&gt; str:\n        return \"MinswapV2\"\n\n    @classmethod\n    def order_selector(self) -&gt; list[str]:\n        return [s.encode() for s in self._stake_address]\n\n    @classmethod\n    def pool_selector(cls) -&gt; PoolSelector:\n        return PoolSelector(\n            addresses=[\"addr1w84q0denmyep98ph3tmzwsmw0j7zau9ljmsqx6a4rvaau6ca7j5v4\"],\n            assets=[\n                \"f5808c2c990d86da54bfc97d89cee6efa20cd8461616359478d96b4c4d5350\",\n            ],\n        )\n\n    @property\n    def swap_forward(self) -&gt; bool:\n        return True\n\n    @property\n    def stake_address(self) -&gt; Address:\n        return self._stake_address[0]\n\n    @classmethod\n    def order_datum_class(self) -&gt; type[MinswapV2OrderDatum]:\n        return MinswapV2OrderDatum\n\n    @classmethod\n    def script_class(self) -&gt; type[PlutusV2Script]:\n        return PlutusV2Script\n\n    @classmethod\n    def pool_datum_class(self) -&gt; type[MinswapV2PoolDatum]:\n        return MinswapV2PoolDatum\n\n    def batcher_fee(\n        self,\n        in_assets: Assets | None = None,\n        out_assets: Assets | None = None,\n        extra_assets: Assets | None = None,\n    ) -&gt; Assets:\n        \"\"\"Batcher fee.\n\n        For Minswap, the batcher fee decreases linearly from 2.0 ADA to 1.5 ADA as the\n        MIN in the input assets from 0 - 25,000 MIN.\n        \"\"\"\n        MIN = \"29d222ce763455e3d7a09a665ce554f00ac89d2e99a1a83d267170c64d494e\"\n        if extra_assets is not None and MIN in extra_assets:\n            fee_reduction = min(extra_assets[MIN] // (2 * 10**5), 250000)\n        else:\n            fee_reduction = 0\n        return self._batcher - Assets(lovelace=fee_reduction)\n\n    @property\n    def pool_id(self) -&gt; str:\n        \"\"\"A unique identifier for the pool.\"\"\"\n        return self.lp_tokens.unit()\n\n    @classmethod\n    def lp_policy(cls) -&gt; list[str]:\n        return [\"f5808c2c990d86da54bfc97d89cee6efa20cd8461616359478d96b4c\"]\n\n    @classmethod\n    def dex_policy(cls) -&gt; list[str]:\n        return [\"f5808c2c990d86da54bfc97d89cee6efa20cd8461616359478d96b4c4d5350\"]\n\n    @classmethod\n    def post_init(cls, values):\n        super().post_init(values)\n\n        datum = MinswapV2PoolDatum.from_cbor(values[\"datum_cbor\"])\n\n        assets = values[\"assets\"]\n        assets.root[assets.unit()] = datum.reserve_a\n        assets.root[assets.unit(1)] = datum.reserve_b\n\n        values[\"fee\"] = [datum.base_fee_a_numerator, datum.base_fee_b_numerator]\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapV2CPPState.pool_id","title":"<code>pool_id: str</code>  <code>property</code>","text":"<p>A unique identifier for the pool.</p>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapV2CPPState.batcher_fee","title":"<code>batcher_fee(in_assets: Assets | None = None, out_assets: Assets | None = None, extra_assets: Assets | None = None) -&gt; Assets</code>","text":"<p>Batcher fee.</p> <p>For Minswap, the batcher fee decreases linearly from 2.0 ADA to 1.5 ADA as the MIN in the input assets from 0 - 25,000 MIN.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>def batcher_fee(\n    self,\n    in_assets: Assets | None = None,\n    out_assets: Assets | None = None,\n    extra_assets: Assets | None = None,\n) -&gt; Assets:\n    \"\"\"Batcher fee.\n\n    For Minswap, the batcher fee decreases linearly from 2.0 ADA to 1.5 ADA as the\n    MIN in the input assets from 0 - 25,000 MIN.\n    \"\"\"\n    MIN = \"29d222ce763455e3d7a09a665ce554f00ac89d2e99a1a83d267170c64d494e\"\n    if extra_assets is not None and MIN in extra_assets:\n        fee_reduction = min(extra_assets[MIN] // (2 * 10**5), 250000)\n    else:\n        fee_reduction = 0\n    return self._batcher - Assets(lovelace=fee_reduction)\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapV2OrderDatum","title":"<code>MinswapV2OrderDatum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OrderDatum</code></p> <p>An order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass MinswapV2OrderDatum(OrderDatum):\n    \"\"\"An order datum.\"\"\"\n\n    owner: Union[OAMMint, OAMSignature, OAMSpend, OAMWithdraw]\n    refund_address: PlutusFullAddress\n    refund_datum_hash: Union[\n        SundaeV3PlutusNone,\n        SundaeV3ReceiverDatumHash,\n        SundaeV3ReceiverInlineDatum,\n    ]\n    receiver_address: PlutusFullAddress\n    receiver_datum_hash: Union[\n        SundaeV3PlutusNone,\n        SundaeV3ReceiverDatumHash,\n        SundaeV3ReceiverInlineDatum,\n    ]\n    lp_asset: AssetClass\n    step: Union[\n        SwapExactInV2,\n        StopLossV2,\n        OCOV2,\n        SwapExactOutV2,\n        DepositV2,\n        WithdrawV2,\n        ZapOutV2,\n        PartialSwapV2,\n        WithdrawImbalanceV2,\n        SwapMultiRoutingV2,\n        DonationV2,\n    ]\n    max_batcher_fee: int\n    expiration_setting: Union[PlutusNone, Expire]\n\n    @classmethod\n    def create_datum(\n        cls,\n        address_source: Address,\n        in_assets: Assets,\n        out_assets: Assets,\n        batcher_fee: Assets,\n        deposit: Assets,\n        address_target: Address | None = None,\n        datum_target: PlutusData | None = None,\n    ):\n        \"\"\"Create an order datum.\"\"\"\n        full_address_source = PlutusFullAddress.from_address(address_source)\n        step = SwapExactInV2.from_assets(in_asset=in_assets, out_asset=out_assets)\n\n        if address_target is None:\n            address_target = address_source\n            datum_target = SundaeV3PlutusNone()\n        elif datum_target is None:\n            datum_target = SundaeV3PlutusNone()\n\n        full_address_target = PlutusFullAddress.from_address(address_target)\n\n        merged_assets = in_assets + out_assets\n\n        if merged_assets.unit() == \"lovelace\":\n            token_a = sha3_256(bytes.fromhex(\"\")).digest()\n        else:\n            token_a = sha3_256(bytes.fromhex(merged_assets.unit())).digest()\n        token_b = sha3_256(bytes.fromhex(merged_assets.unit(1))).digest()\n        pool_name = sha3_256(token_a + token_b).hexdigest()\n        lp_asset = AssetClass.from_assets(\n            Assets(\n                **{\n                    \"f5808c2c990d86da54bfc97d89cee6efa20cd8461616359478d96b4c\"\n                    + pool_name: 0,\n                },\n            ),\n        )\n\n        return cls(\n            owner=OAMSignature(address_source.payment_part.payload),\n            refund_address=full_address_source,\n            refund_datum_hash=datum_target,\n            receiver_address=full_address_target,\n            receiver_datum_hash=datum_target,\n            lp_asset=lp_asset,\n            step=step,\n            max_batcher_fee=batcher_fee.quantity(),\n            expiration_setting=PlutusNone(),\n        )\n\n    def address_source(self) -&gt; Address:\n        \"\"\"The source address.\"\"\"\n        if isinstance(self.owner, OAMSignature):\n            h = self.owner.pub_key_hash\n        else:\n            h = self.owner.script_hash\n\n        return Address(payment_part=VerificationKeyHash(h))\n\n    def requested_amount(self) -&gt; Assets:\n        \"\"\"The requested amount.\"\"\"\n        if isinstance(self.step, SwapExactInV2):\n            if isinstance(self.step.a_to_b_direction, BoolTrue):\n                return Assets({\"asset_a\": self.step.minimum_receive})\n            else:\n                return Assets({\"asset_b\": self.step.minimum_receive})\n        elif isinstance(self.step, SwapExactOutV2):\n            if isinstance(self.step.a_to_b_direction, BoolTrue):\n                return Assets({\"asset_a\": self.step.expected_receive})\n            else:\n                return Assets({\"asset_b\": self.step.expected_receive})\n        elif isinstance(self.step, DepositV2):\n            return Assets({\"lp\": self.step.minimum_lp})\n        elif isinstance(self.step, WithdrawV2):\n            return Assets(\n                {\n                    \"asset_a\": self.step.minimum_asset_a,\n                    \"asset_b\": self.step.minimum_asset_b,\n                },\n            )\n        else:\n            return Assets({})\n\n    def order_type(self) -&gt; OrderType | None:\n        \"\"\"The order type.\"\"\"\n        order_type = None\n        if isinstance(\n            self.step,\n            (\n                SwapExactInV2,\n                StopLossV2,\n                OCOV2,\n                SwapExactOutV2,\n                PartialSwapV2,\n                SwapMultiRoutingV2,\n            ),\n        ):\n            order_type = OrderType.swap\n        elif isinstance(self.step, (DepositV2, DonationV2)):\n            order_type = OrderType.deposit\n        elif isinstance(self.step, (WithdrawV2, ZapOutV2, WithdrawImbalanceV2)):\n            order_type = OrderType.withdraw\n\n        return order_type\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapV2OrderDatum.address_source","title":"<code>address_source() -&gt; Address</code>","text":"<p>The source address.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>def address_source(self) -&gt; Address:\n    \"\"\"The source address.\"\"\"\n    if isinstance(self.owner, OAMSignature):\n        h = self.owner.pub_key_hash\n    else:\n        h = self.owner.script_hash\n\n    return Address(payment_part=VerificationKeyHash(h))\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapV2OrderDatum.create_datum","title":"<code>create_datum(address_source: Address, in_assets: Assets, out_assets: Assets, batcher_fee: Assets, deposit: Assets, address_target: Address | None = None, datum_target: PlutusData | None = None)</code>  <code>classmethod</code>","text":"<p>Create an order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@classmethod\ndef create_datum(\n    cls,\n    address_source: Address,\n    in_assets: Assets,\n    out_assets: Assets,\n    batcher_fee: Assets,\n    deposit: Assets,\n    address_target: Address | None = None,\n    datum_target: PlutusData | None = None,\n):\n    \"\"\"Create an order datum.\"\"\"\n    full_address_source = PlutusFullAddress.from_address(address_source)\n    step = SwapExactInV2.from_assets(in_asset=in_assets, out_asset=out_assets)\n\n    if address_target is None:\n        address_target = address_source\n        datum_target = SundaeV3PlutusNone()\n    elif datum_target is None:\n        datum_target = SundaeV3PlutusNone()\n\n    full_address_target = PlutusFullAddress.from_address(address_target)\n\n    merged_assets = in_assets + out_assets\n\n    if merged_assets.unit() == \"lovelace\":\n        token_a = sha3_256(bytes.fromhex(\"\")).digest()\n    else:\n        token_a = sha3_256(bytes.fromhex(merged_assets.unit())).digest()\n    token_b = sha3_256(bytes.fromhex(merged_assets.unit(1))).digest()\n    pool_name = sha3_256(token_a + token_b).hexdigest()\n    lp_asset = AssetClass.from_assets(\n        Assets(\n            **{\n                \"f5808c2c990d86da54bfc97d89cee6efa20cd8461616359478d96b4c\"\n                + pool_name: 0,\n            },\n        ),\n    )\n\n    return cls(\n        owner=OAMSignature(address_source.payment_part.payload),\n        refund_address=full_address_source,\n        refund_datum_hash=datum_target,\n        receiver_address=full_address_target,\n        receiver_datum_hash=datum_target,\n        lp_asset=lp_asset,\n        step=step,\n        max_batcher_fee=batcher_fee.quantity(),\n        expiration_setting=PlutusNone(),\n    )\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapV2OrderDatum.order_type","title":"<code>order_type() -&gt; OrderType | None</code>","text":"<p>The order type.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>def order_type(self) -&gt; OrderType | None:\n    \"\"\"The order type.\"\"\"\n    order_type = None\n    if isinstance(\n        self.step,\n        (\n            SwapExactInV2,\n            StopLossV2,\n            OCOV2,\n            SwapExactOutV2,\n            PartialSwapV2,\n            SwapMultiRoutingV2,\n        ),\n    ):\n        order_type = OrderType.swap\n    elif isinstance(self.step, (DepositV2, DonationV2)):\n        order_type = OrderType.deposit\n    elif isinstance(self.step, (WithdrawV2, ZapOutV2, WithdrawImbalanceV2)):\n        order_type = OrderType.withdraw\n\n    return order_type\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapV2OrderDatum.requested_amount","title":"<code>requested_amount() -&gt; Assets</code>","text":"<p>The requested amount.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>def requested_amount(self) -&gt; Assets:\n    \"\"\"The requested amount.\"\"\"\n    if isinstance(self.step, SwapExactInV2):\n        if isinstance(self.step.a_to_b_direction, BoolTrue):\n            return Assets({\"asset_a\": self.step.minimum_receive})\n        else:\n            return Assets({\"asset_b\": self.step.minimum_receive})\n    elif isinstance(self.step, SwapExactOutV2):\n        if isinstance(self.step.a_to_b_direction, BoolTrue):\n            return Assets({\"asset_a\": self.step.expected_receive})\n        else:\n            return Assets({\"asset_b\": self.step.expected_receive})\n    elif isinstance(self.step, DepositV2):\n        return Assets({\"lp\": self.step.minimum_lp})\n    elif isinstance(self.step, WithdrawV2):\n        return Assets(\n            {\n                \"asset_a\": self.step.minimum_asset_a,\n                \"asset_b\": self.step.minimum_asset_b,\n            },\n        )\n    else:\n        return Assets({})\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapV2PoolDatum","title":"<code>MinswapV2PoolDatum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PoolDatum</code></p> <p>Pool Datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass MinswapV2PoolDatum(PoolDatum):\n    \"\"\"Pool Datum.\"\"\"\n\n    CONSTR_ID = 0\n\n    pool_batching_stake_credential: _PlutusConstrWrapper\n    asset_a: AssetClass\n    asset_b: AssetClass\n    total_liquidity: int\n    reserve_a: int\n    reserve_b: int\n    base_fee_a_numerator: int\n    base_fee_b_numerator: int\n    fee_sharing_numerator: Union[PlutusNone, OptionalInt]\n    allow_dynamic_fee: Union[BoolTrue, BoolFalse]\n\n    def pool_pair(self) -&gt; Assets | None:\n        \"\"\"Return the asset pair associated with the pool.\"\"\"\n        return self.asset_a.assets + self.asset_b.assets\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.MinswapV2PoolDatum.pool_pair","title":"<code>pool_pair() -&gt; Assets | None</code>","text":"<p>Return the asset pair associated with the pool.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>def pool_pair(self) -&gt; Assets | None:\n    \"\"\"Return the asset pair associated with the pool.\"\"\"\n    return self.asset_a.assets + self.asset_b.assets\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.OAMMint","title":"<code>OAMMint</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>SwapMultiRoutingV2 order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass OAMMint(PlutusData):\n    \"\"\"SwapMultiRoutingV2 order datum.\"\"\"\n\n    CONSTR_ID = 3\n\n    script_hash: bytes\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.OAMSignature","title":"<code>OAMSignature</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>SwapMultiRoutingV2 order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass OAMSignature(PlutusData):\n    \"\"\"SwapMultiRoutingV2 order datum.\"\"\"\n\n    CONSTR_ID = 0\n\n    pub_key_hash: bytes\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.OAMSpend","title":"<code>OAMSpend</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>SwapMultiRoutingV2 order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass OAMSpend(PlutusData):\n    \"\"\"SwapMultiRoutingV2 order datum.\"\"\"\n\n    CONSTR_ID = 1\n\n    script_hash: bytes\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.OAMWithdraw","title":"<code>OAMWithdraw</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>SwapMultiRoutingV2 order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass OAMWithdraw(PlutusData):\n    \"\"\"SwapMultiRoutingV2 order datum.\"\"\"\n\n    CONSTR_ID = 2\n\n    script_hash: bytes\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.OCOV2","title":"<code>OCOV2</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>OCO order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass OCOV2(PlutusData):\n    \"\"\"OCO order datum.\"\"\"\n\n    CONSTR_ID = 2\n    a_to_b_direction: Union[BoolTrue, BoolFalse]\n    swap_amount_option: Union[SAOSpecificAmount, SAOAll]\n    minimum_receive: int\n    stop_loss_receive: int\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.PartialSwapV2","title":"<code>PartialSwapV2</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>PartialSwapV2 order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass PartialSwapV2(PlutusData):\n    \"\"\"PartialSwapV2 order datum.\"\"\"\n\n    CONSTR_ID = 7\n    a_to_b_direction: Union[BoolTrue, BoolFalse]\n    total_swap_amount: int\n    io_ratio_numerator: int\n    io_ratio_denominator: int\n    hops: int\n    minimum_swap_amount_required: int\n    max_batcher_fee_each_time: int\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.StableSwapDeposit","title":"<code>StableSwapDeposit</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Swap exact out order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass StableSwapDeposit(PlutusData):\n    \"\"\"Swap exact out order datum.\"\"\"\n\n    CONSTR_ID = 1\n    expected_receive: int\n\n    @classmethod\n    def from_assets(cls, asset: Assets):\n        \"\"\"Parse an Assets object into a SwapExactOut datum.\"\"\"\n        assert len(asset) == 1\n\n        return StableSwapDeposit(\n            expected_receive=asset.quantity(),\n        )\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.StableSwapDeposit.from_assets","title":"<code>from_assets(asset: Assets)</code>  <code>classmethod</code>","text":"<p>Parse an Assets object into a SwapExactOut datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@classmethod\ndef from_assets(cls, asset: Assets):\n    \"\"\"Parse an Assets object into a SwapExactOut datum.\"\"\"\n    assert len(asset) == 1\n\n    return StableSwapDeposit(\n        expected_receive=asset.quantity(),\n    )\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.StableSwapExactIn","title":"<code>StableSwapExactIn</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Swap exact in order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass StableSwapExactIn(PlutusData):\n    \"\"\"Swap exact in order datum.\"\"\"\n\n    CONSTR_ID = 0\n    input_coin: int\n    output_coin: int\n    minimum_receive: int\n\n    @classmethod\n    def from_assets(cls, in_assets: Assets, out_assets: Assets):\n        \"\"\"Parse an Assets object into a SwapExactIn datum.\"\"\"\n        assert len(in_assets) == 1\n        assert len(out_assets) == 1\n\n        merged = in_assets + out_assets\n        if in_assets.unit() == merged.unit():\n            input_coin = 0\n            output_coin = 1\n        else:\n            input_coin = 1\n            output_coin = 0\n\n        return StableSwapExactIn(\n            input_coin=input_coin,\n            output_coin=output_coin,\n            minimum_receive=out_assets.quantity(),\n        )\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.StableSwapExactIn.from_assets","title":"<code>from_assets(in_assets: Assets, out_assets: Assets)</code>  <code>classmethod</code>","text":"<p>Parse an Assets object into a SwapExactIn datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@classmethod\ndef from_assets(cls, in_assets: Assets, out_assets: Assets):\n    \"\"\"Parse an Assets object into a SwapExactIn datum.\"\"\"\n    assert len(in_assets) == 1\n    assert len(out_assets) == 1\n\n    merged = in_assets + out_assets\n    if in_assets.unit() == merged.unit():\n        input_coin = 0\n        output_coin = 1\n    else:\n        input_coin = 1\n        output_coin = 0\n\n    return StableSwapExactIn(\n        input_coin=input_coin,\n        output_coin=output_coin,\n        minimum_receive=out_assets.quantity(),\n    )\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.StableSwapWithdraw","title":"<code>StableSwapWithdraw</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Swap exact out order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass StableSwapWithdraw(PlutusData):\n    \"\"\"Swap exact out order datum.\"\"\"\n\n    CONSTR_ID = 2\n    expected_receive: List[int]\n\n    @classmethod\n    def from_assets(cls, asset: Assets):\n        \"\"\"Parse an Assets object into a SwapExactOut datum.\"\"\"\n        assert len(asset) == 2\n\n        return StableSwapWithdraw(\n            expected_receive=[asset.quantity(), asset.quantity(1)],\n        )\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.StableSwapWithdraw.from_assets","title":"<code>from_assets(asset: Assets)</code>  <code>classmethod</code>","text":"<p>Parse an Assets object into a SwapExactOut datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@classmethod\ndef from_assets(cls, asset: Assets):\n    \"\"\"Parse an Assets object into a SwapExactOut datum.\"\"\"\n    assert len(asset) == 2\n\n    return StableSwapWithdraw(\n        expected_receive=[asset.quantity(), asset.quantity(1)],\n    )\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.StableSwapWithdrawOneCoin","title":"<code>StableSwapWithdrawOneCoin</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Swap exact out order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass StableSwapWithdrawOneCoin(PlutusData):\n    \"\"\"Swap exact out order datum.\"\"\"\n\n    CONSTR_ID = 4\n    coin: int\n    expected_receive: int\n\n    @classmethod\n    def from_assets(cls, coin_index: int, asset: Assets):\n        \"\"\"Parse an Assets object into a SwapExactOut datum.\"\"\"\n        assert len(asset) == 1\n\n        return StableSwapWithdrawOneCoin(\n            expected_receive=[coin_index, asset.quantity()],\n        )\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.StableSwapWithdrawOneCoin.from_assets","title":"<code>from_assets(coin_index: int, asset: Assets)</code>  <code>classmethod</code>","text":"<p>Parse an Assets object into a SwapExactOut datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@classmethod\ndef from_assets(cls, coin_index: int, asset: Assets):\n    \"\"\"Parse an Assets object into a SwapExactOut datum.\"\"\"\n    assert len(asset) == 1\n\n    return StableSwapWithdrawOneCoin(\n        expected_receive=[coin_index, asset.quantity()],\n    )\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.StopLossV2","title":"<code>StopLossV2</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Stop loss order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass StopLossV2(PlutusData):\n    \"\"\"Stop loss order datum.\"\"\"\n\n    CONSTR_ID = 1\n    a_to_b_direction: Union[BoolTrue, BoolFalse]\n    swap_amount_option: Union[SAOSpecificAmount, SAOAll]\n    stop_loss_receive: int\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.SwapExactIn","title":"<code>SwapExactIn</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Swap exact in order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass SwapExactIn(PlutusData):\n    \"\"\"Swap exact in order datum.\"\"\"\n\n    CONSTR_ID = 0\n    desired_coin: AssetClass\n    minimum_receive: int\n\n    @classmethod\n    def from_assets(cls, asset: Assets):\n        \"\"\"Parse an Assets object into a SwapExactIn datum.\"\"\"\n        assert len(asset) == 1\n\n        return SwapExactIn(\n            desired_coin=AssetClass.from_assets(asset),\n            minimum_receive=asset.quantity(),\n        )\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.SwapExactIn.from_assets","title":"<code>from_assets(asset: Assets)</code>  <code>classmethod</code>","text":"<p>Parse an Assets object into a SwapExactIn datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@classmethod\ndef from_assets(cls, asset: Assets):\n    \"\"\"Parse an Assets object into a SwapExactIn datum.\"\"\"\n    assert len(asset) == 1\n\n    return SwapExactIn(\n        desired_coin=AssetClass.from_assets(asset),\n        minimum_receive=asset.quantity(),\n    )\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.SwapExactInV2","title":"<code>SwapExactInV2</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Swap exact in order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass SwapExactInV2(PlutusData):\n    \"\"\"Swap exact in order datum.\"\"\"\n\n    CONSTR_ID = 0\n    a_to_b_direction: Union[BoolTrue, BoolFalse]\n    swap_amount_option: Union[SAOSpecificAmount, SAOAll]\n    minimum_receive: int\n    killable: Union[BoolTrue, BoolFalse]\n\n    @classmethod\n    def from_assets(cls, in_asset: Assets, out_asset: Assets) -&gt; \"SwapExactInV2\":\n        \"\"\"Parse an Assets object into a SwapExactInV2 datum.\"\"\"\n        assert len(in_asset) == 1\n\n        merged_assets = in_asset + out_asset\n\n        direction = (\n            BoolTrue() if in_asset.unit() == merged_assets.unit() else BoolFalse()\n        )\n\n        option = SAOSpecificAmount(swap_amount=in_asset.quantity())\n\n        return cls(\n            a_to_b_direction=direction,\n            swap_amount_option=option,\n            minimum_receive=out_asset.quantity(),\n            killable=BoolFalse(),\n        )\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.SwapExactInV2.from_assets","title":"<code>from_assets(in_asset: Assets, out_asset: Assets) -&gt; SwapExactInV2</code>  <code>classmethod</code>","text":"<p>Parse an Assets object into a SwapExactInV2 datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@classmethod\ndef from_assets(cls, in_asset: Assets, out_asset: Assets) -&gt; \"SwapExactInV2\":\n    \"\"\"Parse an Assets object into a SwapExactInV2 datum.\"\"\"\n    assert len(in_asset) == 1\n\n    merged_assets = in_asset + out_asset\n\n    direction = (\n        BoolTrue() if in_asset.unit() == merged_assets.unit() else BoolFalse()\n    )\n\n    option = SAOSpecificAmount(swap_amount=in_asset.quantity())\n\n    return cls(\n        a_to_b_direction=direction,\n        swap_amount_option=option,\n        minimum_receive=out_asset.quantity(),\n        killable=BoolFalse(),\n    )\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.SwapExactOut","title":"<code>SwapExactOut</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Swap exact out order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass SwapExactOut(PlutusData):\n    \"\"\"Swap exact out order datum.\"\"\"\n\n    CONSTR_ID = 1\n    desired_coin: AssetClass\n    expected_receive: int\n\n    @classmethod\n    def from_assets(cls, asset: Assets):\n        \"\"\"Parse an Assets object into a SwapExactOut datum.\"\"\"\n        assert len(asset) == 1\n\n        return SwapExactOut(\n            desired_coin=AssetClass.from_assets(asset),\n            expected_receive=asset.quantity(),\n        )\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.SwapExactOut.from_assets","title":"<code>from_assets(asset: Assets)</code>  <code>classmethod</code>","text":"<p>Parse an Assets object into a SwapExactOut datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@classmethod\ndef from_assets(cls, asset: Assets):\n    \"\"\"Parse an Assets object into a SwapExactOut datum.\"\"\"\n    assert len(asset) == 1\n\n    return SwapExactOut(\n        desired_coin=AssetClass.from_assets(asset),\n        expected_receive=asset.quantity(),\n    )\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.SwapExactOutV2","title":"<code>SwapExactOutV2</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Swap exact out order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass SwapExactOutV2(PlutusData):\n    \"\"\"Swap exact out order datum.\"\"\"\n\n    CONSTR_ID = 3\n    a_to_b_direction: Union[BoolTrue, BoolFalse]\n    swap_amount_option: Union[SAOSpecificAmount, SAOAll]\n    expected_receive: int\n    killable: Union[BoolTrue, BoolFalse]\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.SwapMultiRoutingV2","title":"<code>SwapMultiRoutingV2</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>SwapMultiRoutingV2 order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass SwapMultiRoutingV2(PlutusData):\n    \"\"\"SwapMultiRoutingV2 order datum.\"\"\"\n\n    CONSTR_ID = 9\n    routings: List[Datum]\n    swap_amount_option: Union[SAOSpecificAmount, SAOAll]\n    minimum_receive: int\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.Withdraw","title":"<code>Withdraw</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Swap exact in order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass Withdraw(PlutusData):\n    \"\"\"Swap exact in order datum.\"\"\"\n\n    CONSTR_ID = 3\n    min_asset_a: int\n    min_asset_b: int\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.WithdrawImbalanceV2","title":"<code>WithdrawImbalanceV2</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>WithdrawImbalanceV2 order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass WithdrawImbalanceV2(PlutusData):\n    \"\"\"WithdrawImbalanceV2 order datum.\"\"\"\n\n    CONSTR_ID = 8\n    withdrawal_amount_optino: Datum\n    ratio_asset_a: int\n    ratio_asset_b: int\n    minimum_asset_a: int\n    killable: Union[BoolTrue, BoolFalse]\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.WithdrawV2","title":"<code>WithdrawV2</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>WithdrawV2 order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass WithdrawV2(PlutusData):\n    \"\"\"WithdrawV2 order datum.\"\"\"\n\n    CONSTR_ID = 5\n    withdrawal_amount_option: Datum\n    minimum_asset_a: int\n    minimum_asset_b: int\n    killable: Union[BoolTrue, BoolFalse]\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.ZapIn","title":"<code>ZapIn</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Swap exact in order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass ZapIn(PlutusData):\n    \"\"\"Swap exact in order datum.\"\"\"\n\n    CONSTR_ID = 4\n    desired_coin: AssetClass\n    minimum_lp: int\n</code></pre>"},{"location":"minswap/#charli3_dendrite.dexs.amm.minswap.ZapOutV2","title":"<code>ZapOutV2</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>ZapOutV2 order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/minswap.py</code> <pre><code>@dataclass\nclass ZapOutV2(PlutusData):\n    \"\"\"ZapOutV2 order datum.\"\"\"\n\n    CONSTR_ID = 6\n    a_to_b_direction: Union[BoolTrue, BoolFalse]\n    withdrawal_amount_option: Datum\n    minimum_receive: int\n    killable: Union[BoolTrue, BoolFalse]\n</code></pre>"},{"location":"models/","title":"Models","text":""},{"location":"models/#charli3_dendrite.dataclasses.models.Assets","title":"<code>Assets</code>","text":"<p>               Bases: <code>BaseDict</code></p> <p>Contains all tokens and quantities.</p> Source code in <code>src/charli3_dendrite/dataclasses/models.py</code> <pre><code>class Assets(BaseDict):\n    \"\"\"Contains all tokens and quantities.\"\"\"\n\n    root: dict[str, int]\n\n    def unit(self, index: int = 0) -&gt; str:\n        \"\"\"Units of asset at `index`.\"\"\"\n        return list(self.keys())[index]\n\n    def quantity(self, index: int = 0) -&gt; int:\n        \"\"\"Quantity of the asset at `index`.\"\"\"\n        return list(self.values())[index]\n\n    @model_validator(mode=\"before\")\n    def _digest_assets(cls, values: dict) -&gt; dict:\n        if hasattr(values, \"root\"):\n            root = values.root\n        elif \"values\" in values and isinstance(values[\"values\"], list):\n            root = {v.unit: v.quantity for v in values[\"values\"]}\n        elif isinstance(values, list) and isinstance(values[0], dict):\n            if not all(len(v) == 1 for v in values):\n                raise ValueError(\n                    \"For a list of dictionaries, each dictionary must be of length 1.\",\n                )\n            root = {k: v for d in values for k, v in d.items()}\n        else:\n            root = dict(values.items())\n        return dict(\n            sorted(root.items(), key=lambda x: \"\" if x[0] == \"lovelace\" else x[0]),\n        )\n\n    def __add__(a: \"Assets\", b: \"Assets\") -&gt; \"Assets\":\n        \"\"\"Add two assets.\"\"\"\n        intersection = set(a.keys()) | set(b.keys())\n\n        result = {key: a[key] + b[key] for key in intersection}\n\n        return Assets(**result)\n\n    def __sub__(a: \"Assets\", b: \"Assets\") -&gt; \"Assets\":\n        \"\"\"Subtract two assets.\"\"\"\n        intersection = set(a.keys()) | set(b.keys())\n\n        result = {key: a[key] - b[key] for key in intersection}\n\n        return Assets(**result)\n</code></pre>"},{"location":"models/#charli3_dendrite.dataclasses.models.Assets.__add__","title":"<code>__add__(a: Assets, b: Assets) -&gt; Assets</code>","text":"<p>Add two assets.</p> Source code in <code>src/charli3_dendrite/dataclasses/models.py</code> <pre><code>def __add__(a: \"Assets\", b: \"Assets\") -&gt; \"Assets\":\n    \"\"\"Add two assets.\"\"\"\n    intersection = set(a.keys()) | set(b.keys())\n\n    result = {key: a[key] + b[key] for key in intersection}\n\n    return Assets(**result)\n</code></pre>"},{"location":"models/#charli3_dendrite.dataclasses.models.Assets.__sub__","title":"<code>__sub__(a: Assets, b: Assets) -&gt; Assets</code>","text":"<p>Subtract two assets.</p> Source code in <code>src/charli3_dendrite/dataclasses/models.py</code> <pre><code>def __sub__(a: \"Assets\", b: \"Assets\") -&gt; \"Assets\":\n    \"\"\"Subtract two assets.\"\"\"\n    intersection = set(a.keys()) | set(b.keys())\n\n    result = {key: a[key] - b[key] for key in intersection}\n\n    return Assets(**result)\n</code></pre>"},{"location":"models/#charli3_dendrite.dataclasses.models.Assets.quantity","title":"<code>quantity(index: int = 0) -&gt; int</code>","text":"<p>Quantity of the asset at <code>index</code>.</p> Source code in <code>src/charli3_dendrite/dataclasses/models.py</code> <pre><code>def quantity(self, index: int = 0) -&gt; int:\n    \"\"\"Quantity of the asset at `index`.\"\"\"\n    return list(self.values())[index]\n</code></pre>"},{"location":"models/#charli3_dendrite.dataclasses.models.Assets.unit","title":"<code>unit(index: int = 0) -&gt; str</code>","text":"<p>Units of asset at <code>index</code>.</p> Source code in <code>src/charli3_dendrite/dataclasses/models.py</code> <pre><code>def unit(self, index: int = 0) -&gt; str:\n    \"\"\"Units of asset at `index`.\"\"\"\n    return list(self.keys())[index]\n</code></pre>"},{"location":"models/#charli3_dendrite.dataclasses.models.BaseDict","title":"<code>BaseDict</code>","text":"<p>               Bases: <code>BaseList</code></p> <p>Utility class for dict models.</p> Source code in <code>src/charli3_dendrite/dataclasses/models.py</code> <pre><code>class BaseDict(BaseList):\n    \"\"\"Utility class for dict models.\"\"\"\n\n    def items(self):  # noqa: ANN201\n        \"\"\"Return iterable of key-value pairs.\"\"\"\n        return self.root.items()\n\n    def keys(self):  # noqa: ANN201\n        \"\"\"Return iterable of keys.\"\"\"\n        return self.root.keys()\n\n    def values(self):  # noqa: ANN201\n        \"\"\"Return iterable of values.\"\"\"\n        return self.root.values()\n\n    def __getitem__(self, item: str):  # noqa: ANN204\n        \"\"\"Get item by key.\"\"\"\n        return self.root.get(item, 0)\n</code></pre>"},{"location":"models/#charli3_dendrite.dataclasses.models.BaseDict.__getitem__","title":"<code>__getitem__(item: str)</code>","text":"<p>Get item by key.</p> Source code in <code>src/charli3_dendrite/dataclasses/models.py</code> <pre><code>def __getitem__(self, item: str):  # noqa: ANN204\n    \"\"\"Get item by key.\"\"\"\n    return self.root.get(item, 0)\n</code></pre>"},{"location":"models/#charli3_dendrite.dataclasses.models.BaseDict.items","title":"<code>items()</code>","text":"<p>Return iterable of key-value pairs.</p> Source code in <code>src/charli3_dendrite/dataclasses/models.py</code> <pre><code>def items(self):  # noqa: ANN201\n    \"\"\"Return iterable of key-value pairs.\"\"\"\n    return self.root.items()\n</code></pre>"},{"location":"models/#charli3_dendrite.dataclasses.models.BaseDict.keys","title":"<code>keys()</code>","text":"<p>Return iterable of keys.</p> Source code in <code>src/charli3_dendrite/dataclasses/models.py</code> <pre><code>def keys(self):  # noqa: ANN201\n    \"\"\"Return iterable of keys.\"\"\"\n    return self.root.keys()\n</code></pre>"},{"location":"models/#charli3_dendrite.dataclasses.models.BaseDict.values","title":"<code>values()</code>","text":"<p>Return iterable of values.</p> Source code in <code>src/charli3_dendrite/dataclasses/models.py</code> <pre><code>def values(self):  # noqa: ANN201\n    \"\"\"Return iterable of values.\"\"\"\n    return self.root.values()\n</code></pre>"},{"location":"models/#charli3_dendrite.dataclasses.models.BaseList","title":"<code>BaseList</code>","text":"<p>               Bases: <code>RootModel</code></p> <p>Utility class for list models.</p> Source code in <code>src/charli3_dendrite/dataclasses/models.py</code> <pre><code>class BaseList(RootModel):\n    \"\"\"Utility class for list models.\"\"\"\n\n    def __hash__(self) -&gt; int:\n        return hash(self.model_dump_json())\n\n    def __iter__(self):  # noqa\n        return iter(self.root)\n\n    def __getitem__(self, item):  # noqa\n        return self.root[item]\n\n    def __len__(self):  # noqa\n        return len(self.root)\n</code></pre>"},{"location":"models/#charli3_dendrite.dataclasses.models.PoolSelector","title":"<code>PoolSelector</code>","text":"<p>               Bases: <code>DendriteBaseModel</code></p> <p>Pool selection information for dbsync.</p> Source code in <code>src/charli3_dendrite/dataclasses/models.py</code> <pre><code>class PoolSelector(DendriteBaseModel):\n    \"\"\"Pool selection information for dbsync.\"\"\"\n\n    addresses: list[str]\n    assets: list[str] | None = None\n</code></pre>"},{"location":"models/#charli3_dendrite.dataclasses.models.PoolSelectorType","title":"<code>PoolSelectorType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>How to identify a pool.</p> <p>DEX pools are generally identified by one of two mechanism: 1. An address 2. Presence of one or more NFTs (asset policy, with or without asset name)</p> Source code in <code>src/charli3_dendrite/dataclasses/models.py</code> <pre><code>class PoolSelectorType(Enum):\n    \"\"\"How to identify a pool.\n\n    DEX pools are generally identified by one of two mechanism:\n    1. An address\n    2. Presence of one or more NFTs (asset policy, with or without asset name)\n    \"\"\"\n\n    address = \"addresses\"\n    asset = \"assets\"\n</code></pre>"},{"location":"models/#charli3_dendrite.dataclasses.models.TokenSummary","title":"<code>TokenSummary</code>","text":"<p>               Bases: <code>DendriteBaseModel</code></p> <p>Summary of token information.</p> Source code in <code>src/charli3_dendrite/dataclasses/models.py</code> <pre><code>class TokenSummary(DendriteBaseModel):\n    \"\"\"Summary of token information.\"\"\"\n\n    ticker: str\n    name: str\n    policy_id: str\n    policy_name: str\n    decimals: int\n    price_numerator: int = 0\n    price_denominator: int = 0\n</code></pre>"},{"location":"muesliswap/","title":"Muesliswap","text":"<p>MuesliSwap DEX Module.</p>"},{"location":"muesliswap/#charli3_dendrite.dexs.amm.muesli.MuesliCLPoolDatum","title":"<code>MuesliCLPoolDatum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MuesliPoolDatum</code></p> <p>The pool datum for MuesliSwap constant liquidity pools.</p> Source code in <code>src/charli3_dendrite/dexs/amm/muesli.py</code> <pre><code>@dataclass\nclass MuesliCLPoolDatum(MuesliPoolDatum):\n    \"\"\"The pool datum for MuesliSwap constant liquidity pools.\"\"\"\n\n    upper: PreciseFloat\n    lower: PreciseFloat\n    price_sqrt: PreciseFloat\n    unknown: int\n</code></pre>"},{"location":"muesliswap/#charli3_dendrite.dexs.amm.muesli.MuesliCancelRedeemer","title":"<code>MuesliCancelRedeemer</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>The cancel redeemer for MuesliSwap.</p> Source code in <code>src/charli3_dendrite/dexs/amm/muesli.py</code> <pre><code>@dataclass\nclass MuesliCancelRedeemer(PlutusData):\n    \"\"\"The cancel redeemer for MuesliSwap.\"\"\"\n\n    CONSTR_ID = 0\n</code></pre>"},{"location":"muesliswap/#charli3_dendrite.dexs.amm.muesli.MuesliOrderConfig","title":"<code>MuesliOrderConfig</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>The order configuration for MuesliSwap.</p> Source code in <code>src/charli3_dendrite/dexs/amm/muesli.py</code> <pre><code>@dataclass\nclass MuesliOrderConfig(PlutusData):\n    \"\"\"The order configuration for MuesliSwap.\"\"\"\n\n    CONSTR_ID = 0\n\n    full_address: PlutusFullAddress\n    token_out_policy: bytes\n    token_out_name: bytes\n    token_in_policy: bytes\n    token_in_name: bytes\n    min_receive: int\n    unknown: Union[MuesliSometimesNone, PlutusNone]\n    in_amount: int\n</code></pre>"},{"location":"muesliswap/#charli3_dendrite.dexs.amm.muesli.MuesliOrderDatum","title":"<code>MuesliOrderDatum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OrderDatum</code></p> <p>The order datum for MuesliSwap.</p> Source code in <code>src/charli3_dendrite/dexs/amm/muesli.py</code> <pre><code>@dataclass\nclass MuesliOrderDatum(OrderDatum):\n    \"\"\"The order datum for MuesliSwap.\"\"\"\n\n    value: MuesliOrderConfig\n\n    @classmethod\n    def create_datum(\n        cls,\n        address_source: Address,\n        in_assets: Assets,\n        out_assets: Assets,\n        batcher_fee: Assets,\n        deposit: Assets,\n        address_target: Address | None = None,\n        datum_target: PlutusData | None = None,\n    ):\n        \"\"\"Create a MuesliSwap order datum.\"\"\"\n        full_address = PlutusFullAddress.from_address(address_source)\n\n        if in_assets.unit() == \"lovelace\":\n            token_in_policy = b\"\"\n            token_in_name = b\"\"\n        else:\n            token_in_policy = bytes.fromhex(in_assets.unit()[:56])\n            token_in_name = bytes.fromhex(in_assets.unit()[56:])\n\n        if out_assets.unit() == \"lovelace\":\n            token_out_policy = b\"\"\n            token_out_name = b\"\"\n        else:\n            token_out_policy = bytes.fromhex(out_assets.unit()[:56])\n            token_out_name = bytes.fromhex(out_assets.unit()[56:])\n\n        config = MuesliOrderConfig(\n            full_address=full_address,\n            token_in_policy=token_in_policy,\n            token_in_name=token_in_name,\n            token_out_policy=token_out_policy,\n            token_out_name=token_out_name,\n            min_receive=out_assets.quantity(),\n            unknown=PlutusNone(),\n            in_amount=batcher_fee.quantity() + deposit.quantity(),\n        )\n\n        return cls(value=config)\n\n    def address_source(self) -&gt; str:\n        return self.value.full_address.to_address()\n\n    def requested_amount(self) -&gt; Assets:\n        token_out = self.value.token_out_policy.hex() + self.value.token_out_name.hex()\n        if token_out == \"\":\n            token_out = \"lovelace\"\n        return Assets({token_out: self.value.min_receive})\n\n    def order_type(self) -&gt; OrderType:\n        return OrderType.swap\n</code></pre>"},{"location":"muesliswap/#charli3_dendrite.dexs.amm.muesli.MuesliOrderDatum.create_datum","title":"<code>create_datum(address_source: Address, in_assets: Assets, out_assets: Assets, batcher_fee: Assets, deposit: Assets, address_target: Address | None = None, datum_target: PlutusData | None = None)</code>  <code>classmethod</code>","text":"<p>Create a MuesliSwap order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/muesli.py</code> <pre><code>@classmethod\ndef create_datum(\n    cls,\n    address_source: Address,\n    in_assets: Assets,\n    out_assets: Assets,\n    batcher_fee: Assets,\n    deposit: Assets,\n    address_target: Address | None = None,\n    datum_target: PlutusData | None = None,\n):\n    \"\"\"Create a MuesliSwap order datum.\"\"\"\n    full_address = PlutusFullAddress.from_address(address_source)\n\n    if in_assets.unit() == \"lovelace\":\n        token_in_policy = b\"\"\n        token_in_name = b\"\"\n    else:\n        token_in_policy = bytes.fromhex(in_assets.unit()[:56])\n        token_in_name = bytes.fromhex(in_assets.unit()[56:])\n\n    if out_assets.unit() == \"lovelace\":\n        token_out_policy = b\"\"\n        token_out_name = b\"\"\n    else:\n        token_out_policy = bytes.fromhex(out_assets.unit()[:56])\n        token_out_name = bytes.fromhex(out_assets.unit()[56:])\n\n    config = MuesliOrderConfig(\n        full_address=full_address,\n        token_in_policy=token_in_policy,\n        token_in_name=token_in_name,\n        token_out_policy=token_out_policy,\n        token_out_name=token_out_name,\n        min_receive=out_assets.quantity(),\n        unknown=PlutusNone(),\n        in_amount=batcher_fee.quantity() + deposit.quantity(),\n    )\n\n    return cls(value=config)\n</code></pre>"},{"location":"muesliswap/#charli3_dendrite.dexs.amm.muesli.MuesliPoolDatum","title":"<code>MuesliPoolDatum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PoolDatum</code></p> <p>The pool datum for MuesliSwap.</p> Source code in <code>src/charli3_dendrite/dexs/amm/muesli.py</code> <pre><code>@dataclass\nclass MuesliPoolDatum(PoolDatum):\n    \"\"\"The pool datum for MuesliSwap.\"\"\"\n\n    asset_a: AssetClass\n    asset_b: AssetClass\n    lp: int\n    fee: int\n\n    def pool_pair(self) -&gt; Assets | None:\n        return self.asset_a.assets + self.asset_b.assets\n</code></pre>"},{"location":"muesliswap/#charli3_dendrite.dexs.amm.muesli.MuesliSometimesNone","title":"<code>MuesliSometimesNone</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>A dataclass that can be None.</p> Source code in <code>src/charli3_dendrite/dexs/amm/muesli.py</code> <pre><code>@dataclass\nclass MuesliSometimesNone(PlutusData):\n    \"\"\"A dataclass that can be None.\"\"\"\n\n    CONSTR_ID = 0\n</code></pre>"},{"location":"muesliswap/#charli3_dendrite.dexs.amm.muesli.MuesliSwapCLPState","title":"<code>MuesliSwapCLPState</code>","text":"<p>               Bases: <code>AbstractConstantLiquidityPoolState</code>, <code>MuesliSwapCPPState</code></p> <p>The MuesliSwap constant liquidity pool state.</p> Source code in <code>src/charli3_dendrite/dexs/amm/muesli.py</code> <pre><code>class MuesliSwapCLPState(AbstractConstantLiquidityPoolState, MuesliSwapCPPState):\n    \"\"\"The MuesliSwap constant liquidity pool state.\"\"\"\n\n    inactive: bool = True\n\n    @classmethod\n    def dex_policy(cls) -&gt; list[str]:\n        return [\n            # \"de9b756719341e79785aa13c164e7fe68c189ed04d61c9876b2fe53f4d7565736c69537761705f414d4d\",\n            # \"ffcdbb9155da0602280c04d8b36efde35e3416567f9241aff09552694d7565736c69537761705f414d4d\",\n            \"f33bf12af1c23d660e29ebb0d3206b0bfc56ffd87ffafe2d36c42a454d7565736c69537761705f634c50\",  # constant liquidity pools\n            # \"a8512101cb1163cc218e616bb4d4070349a1c9395313f1323cc583634d7565736c695377617054657374506f6f6c\",  # test pool policy\n        ]\n\n    @classmethod\n    def pool_datum_class(cls) -&gt; type[MuesliCLPoolDatum]:\n        return MuesliCLPoolDatum\n</code></pre>"},{"location":"muesliswap/#charli3_dendrite.dexs.amm.muesli.MuesliSwapCPPState","title":"<code>MuesliSwapCPPState</code>","text":"<p>               Bases: <code>AbstractConstantProductPoolState</code></p> <p>The MuesliSwap constant product pool state.</p> Source code in <code>src/charli3_dendrite/dexs/amm/muesli.py</code> <pre><code>class MuesliSwapCPPState(AbstractConstantProductPoolState):\n    \"\"\"The MuesliSwap constant product pool state.\"\"\"\n\n    fee: int = 30\n    _batcher = Assets(lovelace=950000)\n    _deposit = Assets(lovelace=1700000)\n    _test_pool: ClassVar[\n        str\n    ] = \"a8512101cb1163cc218e616bb4d4070349a1c9395313f1323cc583634d7565736c695377617054657374506f6f6c\"\n    _stake_address: ClassVar[Address] = Address.from_primitive(\n        \"addr1zyq0kyrml023kwjk8zr86d5gaxrt5w8lxnah8r6m6s4jp4g3r6dxnzml343sx8jweqn4vn3fz2kj8kgu9czghx0jrsyqqktyhv\",\n    )\n    _reference_utxo: ClassVar[UTxO | None] = None\n\n    @classmethod\n    def dex(cls) -&gt; str:\n        return \"MuesliSwap\"\n\n    @classmethod\n    def order_selector(self) -&gt; list[str]:\n        return [self._stake_address.encode()]\n\n    @classmethod\n    def pool_selector(cls) -&gt; PoolSelector:\n        return PoolSelector(\n            addresses=[\n                \"addr1w9cy2gmar6cpn8yymll93lnd7lw96f27kn2p3eq5d4tjr7qkh3tzd\",\n                \"addr1w85t4tvj3rwf40wqnx6x72kqq6c6stra7jvkupnlqrqyarg2m74rn\",\n                \"addr1w8djr38pct9dpewvv7k67xuh45xpj5f9hyzs3cp939j0csc6nhwme\",\n            ],\n            assets=cls.dex_policy(),\n        )\n\n    @property\n    def swap_forward(self) -&gt; bool:\n        return False\n\n    @classmethod\n    def reference_utxo(cls) -&gt; UTxO | None:\n        if cls._reference_utxo is None:\n            script_reference = get_backend().get_script_from_address(cls._stake_address)\n\n            if script_reference is None:\n                return None\n\n            script_bytes = bytes.fromhex(script_reference.script)\n            script = cls.default_script_class()(script_bytes)\n\n            cls._reference_utxo = UTxO(\n                input=TransactionInput(\n                    transaction_id=TransactionId(\n                        bytes.fromhex(\n                            \"7e4142b7a040eae45d14513000adf91ab42da33a1bd5ccffcfe851b3d93e1e5e\",\n                        ),\n                    ),\n                    index=1,\n                ),\n                output=TransactionOutput(\n                    address=Address.decode(\n                        \"addr1v9p0rc57dzkz7gg97dmsns8hngsuxl956xe6myjldaug7hse4elc6\",\n                    ),\n                    amount=Value(coin=24269610),\n                    script=script,\n                ),\n            )\n\n        return cls._reference_utxo\n\n    @property\n    def stake_address(self) -&gt; Address:\n        return self._stake_address\n\n    @classmethod\n    def order_datum_class(cls) -&gt; type[MuesliOrderDatum]:\n        return MuesliOrderDatum\n\n    @classmethod\n    def pool_datum_class(cls) -&gt; type[MuesliPoolDatum]:\n        return MuesliPoolDatum\n\n    @property\n    def pool_id(self) -&gt; str:\n        \"\"\"A unique identifier for the pool.\"\"\"\n        return self.pool_nft.unit()\n\n    @classmethod\n    def dex_policy(cls) -&gt; list[str]:\n        return [\n            \"de9b756719341e79785aa13c164e7fe68c189ed04d61c9876b2fe53f4d7565736c69537761705f414d4d\",\n            \"ffcdbb9155da0602280c04d8b36efde35e3416567f9241aff09552694d7565736c69537761705f414d4d\",\n            # \"f33bf12af1c23d660e29ebb0d3206b0bfc56ffd87ffafe2d36c42a454d7565736c69537761705f634c50\",  # constant liquidity pools\n            # \"a8512101cb1163cc218e616bb4d4070349a1c9395313f1323cc583634d7565736c695377617054657374506f6f6c\",  # test pool policy\n        ]\n\n    @classmethod\n    def extract_dex_nft(cls, values: dict[str, Any]) -&gt; Optional[Assets]:\n        \"\"\"Extract the dex nft from the UTXO.\n\n        Some DEXs put a DEX nft into the pool UTXO.\n\n        This function checks to see if the DEX nft is in the UTXO if the DEX policy is\n        defined.\n\n        If the dex nft is in the values, this value is skipped because it is assumed\n        that this utxo has already been parsed.\n\n        Args:\n            values: The pool UTXO inputs.\n\n        Returns:\n            Assets: None or the dex nft.\n        \"\"\"\n        dex_nft = super().extract_dex_nft(values)\n\n        if cls._test_pool in dex_nft:\n            raise InvalidPoolError(\"This is a test pool.\")\n\n        return dex_nft\n\n    @classmethod\n    def extract_pool_nft(cls, values: dict[str, Any]) -&gt; Optional[Assets]:\n        \"\"\"Extract the dex nft from the UTXO.\n\n        Some DEXs put a DEX nft into the pool UTXO.\n\n        This function checks to see if the DEX nft is in the UTXO if the DEX policy is\n        defined.\n\n        If the dex nft is in the values, this value is skipped because it is assumed\n        that this utxo has already been parsed.\n\n        Args:\n            values: The pool UTXO inputs.\n\n        Returns:\n            Assets: None or the dex nft.\n        \"\"\"\n        assets = values[\"assets\"]\n\n        if \"pool_nft\" in values:\n            pool_nft = Assets(root=values[\"pool_nft\"])\n        else:\n            nfts = [asset for asset, quantity in assets.items() if quantity == 1]\n            if len(nfts) != 1:\n                raise InvalidPoolError(\n                    f\"MuesliSwap pools must have exactly one pool nft: assets={assets}\",\n                )\n            pool_nft = Assets(**{nfts[0]: assets.root.pop(nfts[0])})\n            values[\"pool_nft\"] = pool_nft\n\n        return pool_nft\n\n    @classmethod\n    def default_script_class(self) -&gt; type[PlutusV1Script] | type[PlutusV2Script]:\n        return PlutusV2Script\n\n    @classmethod\n    def cancel_redeemer(cls) -&gt; PlutusData:\n        return Redeemer(MuesliCancelRedeemer())\n</code></pre>"},{"location":"muesliswap/#charli3_dendrite.dexs.amm.muesli.MuesliSwapCPPState.pool_id","title":"<code>pool_id: str</code>  <code>property</code>","text":"<p>A unique identifier for the pool.</p>"},{"location":"muesliswap/#charli3_dendrite.dexs.amm.muesli.MuesliSwapCPPState.extract_dex_nft","title":"<code>extract_dex_nft(values: dict[str, Any]) -&gt; Optional[Assets]</code>  <code>classmethod</code>","text":"<p>Extract the dex nft from the UTXO.</p> <p>Some DEXs put a DEX nft into the pool UTXO.</p> <p>This function checks to see if the DEX nft is in the UTXO if the DEX policy is defined.</p> <p>If the dex nft is in the values, this value is skipped because it is assumed that this utxo has already been parsed.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>dict[str, Any]</code> <p>The pool UTXO inputs.</p> required <p>Returns:</p> Name Type Description <code>Assets</code> <code>Optional[Assets]</code> <p>None or the dex nft.</p> Source code in <code>src/charli3_dendrite/dexs/amm/muesli.py</code> <pre><code>@classmethod\ndef extract_dex_nft(cls, values: dict[str, Any]) -&gt; Optional[Assets]:\n    \"\"\"Extract the dex nft from the UTXO.\n\n    Some DEXs put a DEX nft into the pool UTXO.\n\n    This function checks to see if the DEX nft is in the UTXO if the DEX policy is\n    defined.\n\n    If the dex nft is in the values, this value is skipped because it is assumed\n    that this utxo has already been parsed.\n\n    Args:\n        values: The pool UTXO inputs.\n\n    Returns:\n        Assets: None or the dex nft.\n    \"\"\"\n    dex_nft = super().extract_dex_nft(values)\n\n    if cls._test_pool in dex_nft:\n        raise InvalidPoolError(\"This is a test pool.\")\n\n    return dex_nft\n</code></pre>"},{"location":"muesliswap/#charli3_dendrite.dexs.amm.muesli.MuesliSwapCPPState.extract_pool_nft","title":"<code>extract_pool_nft(values: dict[str, Any]) -&gt; Optional[Assets]</code>  <code>classmethod</code>","text":"<p>Extract the dex nft from the UTXO.</p> <p>Some DEXs put a DEX nft into the pool UTXO.</p> <p>This function checks to see if the DEX nft is in the UTXO if the DEX policy is defined.</p> <p>If the dex nft is in the values, this value is skipped because it is assumed that this utxo has already been parsed.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>dict[str, Any]</code> <p>The pool UTXO inputs.</p> required <p>Returns:</p> Name Type Description <code>Assets</code> <code>Optional[Assets]</code> <p>None or the dex nft.</p> Source code in <code>src/charli3_dendrite/dexs/amm/muesli.py</code> <pre><code>@classmethod\ndef extract_pool_nft(cls, values: dict[str, Any]) -&gt; Optional[Assets]:\n    \"\"\"Extract the dex nft from the UTXO.\n\n    Some DEXs put a DEX nft into the pool UTXO.\n\n    This function checks to see if the DEX nft is in the UTXO if the DEX policy is\n    defined.\n\n    If the dex nft is in the values, this value is skipped because it is assumed\n    that this utxo has already been parsed.\n\n    Args:\n        values: The pool UTXO inputs.\n\n    Returns:\n        Assets: None or the dex nft.\n    \"\"\"\n    assets = values[\"assets\"]\n\n    if \"pool_nft\" in values:\n        pool_nft = Assets(root=values[\"pool_nft\"])\n    else:\n        nfts = [asset for asset, quantity in assets.items() if quantity == 1]\n        if len(nfts) != 1:\n            raise InvalidPoolError(\n                f\"MuesliSwap pools must have exactly one pool nft: assets={assets}\",\n            )\n        pool_nft = Assets(**{nfts[0]: assets.root.pop(nfts[0])})\n        values[\"pool_nft\"] = pool_nft\n\n    return pool_nft\n</code></pre>"},{"location":"muesliswap/#charli3_dendrite.dexs.amm.muesli.PreciseFloat","title":"<code>PreciseFloat</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>A precise float dataclass.</p> Source code in <code>src/charli3_dendrite/dexs/amm/muesli.py</code> <pre><code>@dataclass\nclass PreciseFloat(PlutusData):\n    \"\"\"A precise float dataclass.\"\"\"\n\n    CONSTR_ID = 0\n\n    numerator: int\n    denominator: int\n</code></pre>"},{"location":"order_book_base/","title":"Order book base","text":"<p>Module providing base classes for OB pools.</p>"},{"location":"order_book_base/#charli3_dendrite.dexs.ob.ob_base.AbstractOrderBookState","title":"<code>AbstractOrderBookState</code>","text":"<p>               Bases: <code>AbstractPairState</code></p> <p>This class is largely used for OB dexes that have a batcher.</p> Source code in <code>src/charli3_dendrite/dexs/ob/ob_base.py</code> <pre><code>class AbstractOrderBookState(AbstractPairState):\n    \"\"\"This class is largely used for OB dexes that have a batcher.\"\"\"\n\n    sell_book: SellOrderBook | None = None\n    buy_book: BuyOrderBook | None = None\n    sell_book_full: SellOrderBook\n    buy_book_full: BuyOrderBook\n\n    def get_amount_out(\n        self,\n        asset: Assets,\n        precise: bool = True,\n        apply_fee: bool = False,\n    ) -&gt; tuple[Assets, float]:\n        \"\"\"Get the amount of token output for the given input.\n\n        Args:\n            asset: The input assets\n            precise: If precise, uses integers. Defaults to True.\n\n        Returns:\n            tuple[Assets, float]: The output assets and slippage.\n        \"\"\"\n        assert len(asset) == 1, \"Asset should only have one token.\"\n        assert asset.unit() in [\n            self.unit_a,\n            self.unit_b,\n        ], f\"Asset {asset.unit} is invalid for pool {self.unit_a}-{self.unit_b}\"\n\n        if asset.unit() == self.unit_a:\n            book = self.sell_book_full\n            unit_out = self.unit_b\n        else:\n            book = self.buy_book_full\n            unit_out = self.unit_a\n\n        in_quantity = asset.quantity()\n        if apply_fee:\n            in_quantity = in_quantity * (10000 - self.fee) // 10000\n\n        index = 0\n        out_assets = Assets({unit_out: 0})\n        while in_quantity &gt; 0 and index &lt; len(book):\n            available = book[index].quantity * book[index].price\n            if available &gt; in_quantity:\n                out_assets.root[unit_out] += in_quantity / book[index].price\n                in_quantity = 0\n            else:\n                out_assets.root[unit_out] += book[index].quantity\n                in_quantity -= book[index].price * book[index].quantity\n            index += 1\n\n        out_assets.root[unit_out] = int(out_assets[unit_out])\n\n        return out_assets, 0\n\n    def get_amount_in(\n        self,\n        asset: Assets,\n        precise: bool = True,\n        apply_fee: bool = False,\n    ) -&gt; tuple[Assets, float]:\n        \"\"\"Get the amount of token input for the given output.\n\n        Args:\n            asset: The input assets\n            precise: If precise, uses integers. Defaults to True.\n\n        Returns:\n            tuple[Assets, float]: The output assets and slippage.\n        \"\"\"\n        assert len(asset) == 1, \"Asset should only have one token.\"\n        assert asset.unit() in [\n            self.unit_a,\n            self.unit_b,\n        ], f\"Asset {asset.unit} is invalid for pool {self.unit_a}-{self.unit_b}\"\n\n        if asset.unit() == self.unit_b:\n            book = self.sell_book_full\n            unit_in = self.unit_a\n        else:\n            book = self.buy_book_full\n            unit_in = self.unit_b\n\n        index = 0\n        out_quantity = asset.quantity()\n        in_assets = Assets({unit_in: 0})\n        while out_quantity &gt; 0 and index &lt; len(book):\n            available = book[index].quantity\n            if available &gt; out_quantity:\n                in_assets.root[unit_in] += out_quantity * book[index].price\n                out_quantity = 0\n            else:\n                in_assets.root[unit_in] += book[index].quantity / book[index].price\n                out_quantity -= book[index].quantity\n            index += 1\n\n        if apply_fee:\n            fees = in_assets[unit_in] * self.fee / 10000\n            in_assets.root[unit_in] += fees\n\n        in_assets.root[unit_in] = int(in_assets[unit_in])\n\n        return in_assets, 0\n\n    @classmethod\n    def reference_utxo(self) -&gt; UTxO | None:\n        return None\n\n    @property\n    def price(self) -&gt; tuple[Decimal, Decimal]:\n        \"\"\"Mid price of assets.\n\n        Returns:\n            A `Tuple[Decimal, Decimal] where the first `Decimal` is the price to buy\n                1 of token B in units of token A, and the second `Decimal` is the price\n                to buy 1 of token A in units of token B.\n        \"\"\"\n        prices = (\n            Decimal((self.buy_book[0].price + 1 / self.sell_book[0].price) / 2),\n            Decimal((self.sell_book[0].price + 1 / self.buy_book[0].price) / 2),\n        )\n\n        return prices\n\n    @property\n    def tvl(self) -&gt; Decimal:\n        \"\"\"Return the total value locked for the pool.\n\n        Raises:\n            NotImplementedError: Only ADA pool TVL is implemented.\n        \"\"\"\n        if self.unit_a != \"lovelace\":\n            raise NotImplementedError(\"tvl for non-ADA pools is not implemented.\")\n\n        tvl = sum(b.quantity / b.price for b in self.buy_book) + sum(\n            s.quantity * s.price for s in self.sell_book\n        )\n\n        return Decimal(int(tvl) / 10**6)\n\n    @classmethod\n    @abstractmethod\n    def get_book(\n        cls,\n        assets: Assets | None = None,\n        orders: list[AbstractOrderState] | None = None,\n    ) -&gt; \"AbstractOrderBookState\":\n        raise NotImplementedError\n</code></pre>"},{"location":"order_book_base/#charli3_dendrite.dexs.ob.ob_base.AbstractOrderBookState.price","title":"<code>price: tuple[Decimal, Decimal]</code>  <code>property</code>","text":"<p>Mid price of assets.</p> <p>Returns:</p> Type Description <code>tuple[Decimal, Decimal]</code> <p>A <code>Tuple[Decimal, Decimal] where the first</code>Decimal<code>is the price to buy 1 of token B in units of token A, and the second</code>Decimal` is the price to buy 1 of token A in units of token B.</p>"},{"location":"order_book_base/#charli3_dendrite.dexs.ob.ob_base.AbstractOrderBookState.tvl","title":"<code>tvl: Decimal</code>  <code>property</code>","text":"<p>Return the total value locked for the pool.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Only ADA pool TVL is implemented.</p>"},{"location":"order_book_base/#charli3_dendrite.dexs.ob.ob_base.AbstractOrderBookState.get_amount_in","title":"<code>get_amount_in(asset: Assets, precise: bool = True, apply_fee: bool = False) -&gt; tuple[Assets, float]</code>","text":"<p>Get the amount of token input for the given output.</p> <p>Parameters:</p> Name Type Description Default <code>asset</code> <code>Assets</code> <p>The input assets</p> required <code>precise</code> <code>bool</code> <p>If precise, uses integers. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[Assets, float]</code> <p>tuple[Assets, float]: The output assets and slippage.</p> Source code in <code>src/charli3_dendrite/dexs/ob/ob_base.py</code> <pre><code>def get_amount_in(\n    self,\n    asset: Assets,\n    precise: bool = True,\n    apply_fee: bool = False,\n) -&gt; tuple[Assets, float]:\n    \"\"\"Get the amount of token input for the given output.\n\n    Args:\n        asset: The input assets\n        precise: If precise, uses integers. Defaults to True.\n\n    Returns:\n        tuple[Assets, float]: The output assets and slippage.\n    \"\"\"\n    assert len(asset) == 1, \"Asset should only have one token.\"\n    assert asset.unit() in [\n        self.unit_a,\n        self.unit_b,\n    ], f\"Asset {asset.unit} is invalid for pool {self.unit_a}-{self.unit_b}\"\n\n    if asset.unit() == self.unit_b:\n        book = self.sell_book_full\n        unit_in = self.unit_a\n    else:\n        book = self.buy_book_full\n        unit_in = self.unit_b\n\n    index = 0\n    out_quantity = asset.quantity()\n    in_assets = Assets({unit_in: 0})\n    while out_quantity &gt; 0 and index &lt; len(book):\n        available = book[index].quantity\n        if available &gt; out_quantity:\n            in_assets.root[unit_in] += out_quantity * book[index].price\n            out_quantity = 0\n        else:\n            in_assets.root[unit_in] += book[index].quantity / book[index].price\n            out_quantity -= book[index].quantity\n        index += 1\n\n    if apply_fee:\n        fees = in_assets[unit_in] * self.fee / 10000\n        in_assets.root[unit_in] += fees\n\n    in_assets.root[unit_in] = int(in_assets[unit_in])\n\n    return in_assets, 0\n</code></pre>"},{"location":"order_book_base/#charli3_dendrite.dexs.ob.ob_base.AbstractOrderBookState.get_amount_out","title":"<code>get_amount_out(asset: Assets, precise: bool = True, apply_fee: bool = False) -&gt; tuple[Assets, float]</code>","text":"<p>Get the amount of token output for the given input.</p> <p>Parameters:</p> Name Type Description Default <code>asset</code> <code>Assets</code> <p>The input assets</p> required <code>precise</code> <code>bool</code> <p>If precise, uses integers. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[Assets, float]</code> <p>tuple[Assets, float]: The output assets and slippage.</p> Source code in <code>src/charli3_dendrite/dexs/ob/ob_base.py</code> <pre><code>def get_amount_out(\n    self,\n    asset: Assets,\n    precise: bool = True,\n    apply_fee: bool = False,\n) -&gt; tuple[Assets, float]:\n    \"\"\"Get the amount of token output for the given input.\n\n    Args:\n        asset: The input assets\n        precise: If precise, uses integers. Defaults to True.\n\n    Returns:\n        tuple[Assets, float]: The output assets and slippage.\n    \"\"\"\n    assert len(asset) == 1, \"Asset should only have one token.\"\n    assert asset.unit() in [\n        self.unit_a,\n        self.unit_b,\n    ], f\"Asset {asset.unit} is invalid for pool {self.unit_a}-{self.unit_b}\"\n\n    if asset.unit() == self.unit_a:\n        book = self.sell_book_full\n        unit_out = self.unit_b\n    else:\n        book = self.buy_book_full\n        unit_out = self.unit_a\n\n    in_quantity = asset.quantity()\n    if apply_fee:\n        in_quantity = in_quantity * (10000 - self.fee) // 10000\n\n    index = 0\n    out_assets = Assets({unit_out: 0})\n    while in_quantity &gt; 0 and index &lt; len(book):\n        available = book[index].quantity * book[index].price\n        if available &gt; in_quantity:\n            out_assets.root[unit_out] += in_quantity / book[index].price\n            in_quantity = 0\n        else:\n            out_assets.root[unit_out] += book[index].quantity\n            in_quantity -= book[index].price * book[index].quantity\n        index += 1\n\n    out_assets.root[unit_out] = int(out_assets[unit_out])\n\n    return out_assets, 0\n</code></pre>"},{"location":"order_book_base/#charli3_dendrite.dexs.ob.ob_base.AbstractOrderState","title":"<code>AbstractOrderState</code>","text":"<p>               Bases: <code>AbstractPairState</code></p> <p>This class is largely used for OB dexes that allow direct script inputs.</p> Source code in <code>src/charli3_dendrite/dexs/ob/ob_base.py</code> <pre><code>class AbstractOrderState(AbstractPairState):\n    \"\"\"This class is largely used for OB dexes that allow direct script inputs.\"\"\"\n\n    tx_hash: str\n    tx_index: int\n    datum_cbor: str\n    datum_hash: str\n    inactive: bool = False\n\n    _batcher_fee: Assets\n    _datum_parsed: PlutusData | None = None\n\n    @property\n    def in_unit(self) -&gt; str:\n        return self.assets.unit()\n\n    @property\n    def out_unit(self) -&gt; str:\n        return self.assets.unit(1)\n\n    @property\n    @abstractmethod\n    def price(self) -&gt; tuple[int, int]:\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def available(self) -&gt; Assets:\n        \"\"\"Max amount of output asset that can be used to fill the order.\"\"\"\n        raise NotImplementedError\n\n    def get_amount_out(self, asset: Assets, precise=True) -&gt; tuple[Assets, float]:\n        assert asset.unit() == self.in_unit and len(asset) == 1\n\n        num, denom = self.price\n        out_assets = Assets(**{self.out_unit: 0})\n        in_quantity = asset.quantity() - ceil(\n            asset.quantity() * self.volume_fee / 10000,\n        )\n        out_assets.root[self.out_unit] = min(\n            ceil(in_quantity * denom / num),\n            self.available.quantity(),\n        )\n\n        if precise:\n            out_assets.root[self.out_unit] = int(out_assets.quantity())\n\n        return out_assets, 0\n\n    def get_amount_in(self, asset: Assets, precise=True) -&gt; tuple[Assets, float]:\n        assert asset.unit() == self.out_unit and len(asset) == 1\n\n        denom, num = self.price\n        in_assets = Assets(**{self.in_unit: 0})\n        out_quantity = asset.quantity()\n        in_assets.root[self.in_unit] = (\n            min(out_quantity, self.available.quantity()) * denom\n        ) / num\n        fees = in_assets[self.in_unit] * self.volume_fee / 10000\n        in_assets.root[self.in_unit] += fees\n\n        if precise:\n            in_assets.root[self.in_unit] = int(in_assets.quantity())\n\n        return in_assets, 0\n\n    @classmethod\n    def skip_init(cls, values: dict[str, ...]) -&gt; bool:\n        \"\"\"An initial check to determine if parsing should be carried out.\n\n        Args:\n            values: The pool initialization parameters.\n\n        Returns:\n            bool: If this returns True, initialization checks will get skipped.\n        \"\"\"\n        return False\n\n    @classmethod\n    def extract_dex_nft(cls, values: dict[str, ...]) -&gt; Assets | None:\n        \"\"\"Extract the dex nft from the UTXO.\n\n        Some DEXs put a DEX nft into the pool UTXO.\n\n        This function checks to see if the DEX nft is in the UTXO if the DEX policy is\n        defined.\n\n        If the dex nft is in the values, this value is skipped because it is assumed\n        that this utxo has already been parsed.\n\n        Args:\n            values: The pool UTXO inputs.\n\n        Returns:\n            Assets: None or the dex nft.\n        \"\"\"\n        assets = values[\"assets\"]\n\n        # If no dex policy id defined, return nothing\n        if cls.dex_policy() is None:\n            dex_nft = None\n\n        # If the dex nft is in the values, it's been parsed already\n        elif \"dex_nft\" in values:\n            if not any(\n                any(p.startswith(d) for d in cls.dex_policy())\n                for p in values[\"dex_nft\"]\n            ):\n                raise NotAPoolError(\"Invalid DEX NFT\")\n            dex_nft = values[\"dex_nft\"]\n\n        # Check for the dex nft\n        else:\n            nfts = [\n                asset\n                for asset in assets\n                if any(asset.startswith(policy) for policy in cls.dex_policy())\n            ]\n            if len(nfts) &lt; 1:\n                raise NotAPoolError(\n                    f\"{cls.__name__}: Pool must have one DEX NFT token.\",\n                )\n            dex_nft = Assets(**{nfts[0]: assets.root.pop(nfts[0])})\n            values[\"dex_nft\"] = dex_nft\n\n        return dex_nft\n\n    @property\n    def order_datum(self) -&gt; PlutusData:\n        if self._datum_parsed is None:\n            self._datum_parsed = self.order_datum_class().from_cbor(self.datum_cbor)\n        return self._datum_parsed\n\n    @classmethod\n    def post_init(cls, values: dict[str, ...]):\n        \"\"\"Post initialization checks.\n\n        Args:\n            values: The pool initialization parameters\n        \"\"\"\n        assets = values[\"assets\"]\n        non_ada_assets = [a for a in assets if a != \"lovelace\"]\n\n        if len(assets) == 2:\n            # ADA pair\n            assert (\n                len(non_ada_assets) == 1\n            ), f\"Pool must only have 1 non-ADA asset: {values}\"\n\n        elif len(assets) == 3:\n            # Non-ADA pair\n            assert len(non_ada_assets) == 2, \"Pool must only have 2 non-ADA assets.\"\n\n            # Send the ADA token to the end\n            values[\"assets\"].root[\"lovelace\"] = values[\"assets\"].root.pop(\"lovelace\")\n\n        else:\n            if len(assets) == 1 and \"lovelace\" in assets:\n                raise NoAssetsError(\n                    f\"Invalid pool, only contains lovelace: assets={assets}\",\n                )\n            else:\n                raise InvalidPoolError(\n                    f\"Pool must have 2 or 3 assets except factor, NFT, and LP tokens: assets={assets}\",\n                )\n        return values\n\n    @model_validator(mode=\"before\")\n    def translate_address(cls, values):\n        \"\"\"The main validation function called when initialized.\n\n        Args:\n            values: The pool initialization values.\n\n        Returns:\n            The parsed/modified pool initialization values.\n        \"\"\"\n        if \"assets\" in values:\n            if values[\"assets\"] is None:\n                raise NoAssetsError(\"No assets in the pool.\")\n            elif not isinstance(values[\"assets\"], Assets):\n                values[\"assets\"] = Assets(**values[\"assets\"])\n\n        if cls.skip_init(values):\n            return values\n\n        # Parse the order datum\n        try:\n            datum = cls.order_datum_class().from_cbor(values[\"datum_cbor\"])\n        except (DeserializeException, TypeError) as e:\n            raise NotAPoolError(\n                \"Order datum could not be deserialized: \\n \"\n                + f\"    error={e}\\n\"\n                + f\"    tx_hash={values['tx_hash']}\\n\"\n                + f\"    datum={values['datum_cbor']}\\n\",\n            )\n\n        # To help prevent edge cases, remove pool tokens while running other checks\n        pair = datum.pool_pair()\n        if datum.pool_pair() is not None:\n            for token in datum.pool_pair():\n                try:\n                    if token in values[\"assets\"]:\n                        pair.root.update({token: values[\"assets\"].root.pop(token)})\n                except KeyError:\n                    raise InvalidPoolError(\n                        \"Order does not contain expected asset.\\n\"\n                        + f\"    Expected: {token}\\n\"\n                        + f\"    Actual: {values['assets']}\",\n                    )\n\n        dex_nft = cls.extract_dex_nft(values)\n\n        # Add the pool tokens back in\n        values[\"assets\"].root.update(pair.root)\n\n        cls.post_init(values)\n\n        return values\n</code></pre>"},{"location":"order_book_base/#charli3_dendrite.dexs.ob.ob_base.AbstractOrderState.available","title":"<code>available: Assets</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Max amount of output asset that can be used to fill the order.</p>"},{"location":"order_book_base/#charli3_dendrite.dexs.ob.ob_base.AbstractOrderState.extract_dex_nft","title":"<code>extract_dex_nft(values: dict[str, ...]) -&gt; Assets | None</code>  <code>classmethod</code>","text":"<p>Extract the dex nft from the UTXO.</p> <p>Some DEXs put a DEX nft into the pool UTXO.</p> <p>This function checks to see if the DEX nft is in the UTXO if the DEX policy is defined.</p> <p>If the dex nft is in the values, this value is skipped because it is assumed that this utxo has already been parsed.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>dict[str, ...]</code> <p>The pool UTXO inputs.</p> required <p>Returns:</p> Name Type Description <code>Assets</code> <code>Assets | None</code> <p>None or the dex nft.</p> Source code in <code>src/charli3_dendrite/dexs/ob/ob_base.py</code> <pre><code>@classmethod\ndef extract_dex_nft(cls, values: dict[str, ...]) -&gt; Assets | None:\n    \"\"\"Extract the dex nft from the UTXO.\n\n    Some DEXs put a DEX nft into the pool UTXO.\n\n    This function checks to see if the DEX nft is in the UTXO if the DEX policy is\n    defined.\n\n    If the dex nft is in the values, this value is skipped because it is assumed\n    that this utxo has already been parsed.\n\n    Args:\n        values: The pool UTXO inputs.\n\n    Returns:\n        Assets: None or the dex nft.\n    \"\"\"\n    assets = values[\"assets\"]\n\n    # If no dex policy id defined, return nothing\n    if cls.dex_policy() is None:\n        dex_nft = None\n\n    # If the dex nft is in the values, it's been parsed already\n    elif \"dex_nft\" in values:\n        if not any(\n            any(p.startswith(d) for d in cls.dex_policy())\n            for p in values[\"dex_nft\"]\n        ):\n            raise NotAPoolError(\"Invalid DEX NFT\")\n        dex_nft = values[\"dex_nft\"]\n\n    # Check for the dex nft\n    else:\n        nfts = [\n            asset\n            for asset in assets\n            if any(asset.startswith(policy) for policy in cls.dex_policy())\n        ]\n        if len(nfts) &lt; 1:\n            raise NotAPoolError(\n                f\"{cls.__name__}: Pool must have one DEX NFT token.\",\n            )\n        dex_nft = Assets(**{nfts[0]: assets.root.pop(nfts[0])})\n        values[\"dex_nft\"] = dex_nft\n\n    return dex_nft\n</code></pre>"},{"location":"order_book_base/#charli3_dendrite.dexs.ob.ob_base.AbstractOrderState.post_init","title":"<code>post_init(values: dict[str, ...])</code>  <code>classmethod</code>","text":"<p>Post initialization checks.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>dict[str, ...]</code> <p>The pool initialization parameters</p> required Source code in <code>src/charli3_dendrite/dexs/ob/ob_base.py</code> <pre><code>@classmethod\ndef post_init(cls, values: dict[str, ...]):\n    \"\"\"Post initialization checks.\n\n    Args:\n        values: The pool initialization parameters\n    \"\"\"\n    assets = values[\"assets\"]\n    non_ada_assets = [a for a in assets if a != \"lovelace\"]\n\n    if len(assets) == 2:\n        # ADA pair\n        assert (\n            len(non_ada_assets) == 1\n        ), f\"Pool must only have 1 non-ADA asset: {values}\"\n\n    elif len(assets) == 3:\n        # Non-ADA pair\n        assert len(non_ada_assets) == 2, \"Pool must only have 2 non-ADA assets.\"\n\n        # Send the ADA token to the end\n        values[\"assets\"].root[\"lovelace\"] = values[\"assets\"].root.pop(\"lovelace\")\n\n    else:\n        if len(assets) == 1 and \"lovelace\" in assets:\n            raise NoAssetsError(\n                f\"Invalid pool, only contains lovelace: assets={assets}\",\n            )\n        else:\n            raise InvalidPoolError(\n                f\"Pool must have 2 or 3 assets except factor, NFT, and LP tokens: assets={assets}\",\n            )\n    return values\n</code></pre>"},{"location":"order_book_base/#charli3_dendrite.dexs.ob.ob_base.AbstractOrderState.skip_init","title":"<code>skip_init(values: dict[str, ...]) -&gt; bool</code>  <code>classmethod</code>","text":"<p>An initial check to determine if parsing should be carried out.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>dict[str, ...]</code> <p>The pool initialization parameters.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>If this returns True, initialization checks will get skipped.</p> Source code in <code>src/charli3_dendrite/dexs/ob/ob_base.py</code> <pre><code>@classmethod\ndef skip_init(cls, values: dict[str, ...]) -&gt; bool:\n    \"\"\"An initial check to determine if parsing should be carried out.\n\n    Args:\n        values: The pool initialization parameters.\n\n    Returns:\n        bool: If this returns True, initialization checks will get skipped.\n    \"\"\"\n    return False\n</code></pre>"},{"location":"order_book_base/#charli3_dendrite.dexs.ob.ob_base.AbstractOrderState.translate_address","title":"<code>translate_address(values)</code>","text":"<p>The main validation function called when initialized.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <p>The pool initialization values.</p> required <p>Returns:</p> Type Description <p>The parsed/modified pool initialization values.</p> Source code in <code>src/charli3_dendrite/dexs/ob/ob_base.py</code> <pre><code>@model_validator(mode=\"before\")\ndef translate_address(cls, values):\n    \"\"\"The main validation function called when initialized.\n\n    Args:\n        values: The pool initialization values.\n\n    Returns:\n        The parsed/modified pool initialization values.\n    \"\"\"\n    if \"assets\" in values:\n        if values[\"assets\"] is None:\n            raise NoAssetsError(\"No assets in the pool.\")\n        elif not isinstance(values[\"assets\"], Assets):\n            values[\"assets\"] = Assets(**values[\"assets\"])\n\n    if cls.skip_init(values):\n        return values\n\n    # Parse the order datum\n    try:\n        datum = cls.order_datum_class().from_cbor(values[\"datum_cbor\"])\n    except (DeserializeException, TypeError) as e:\n        raise NotAPoolError(\n            \"Order datum could not be deserialized: \\n \"\n            + f\"    error={e}\\n\"\n            + f\"    tx_hash={values['tx_hash']}\\n\"\n            + f\"    datum={values['datum_cbor']}\\n\",\n        )\n\n    # To help prevent edge cases, remove pool tokens while running other checks\n    pair = datum.pool_pair()\n    if datum.pool_pair() is not None:\n        for token in datum.pool_pair():\n            try:\n                if token in values[\"assets\"]:\n                    pair.root.update({token: values[\"assets\"].root.pop(token)})\n            except KeyError:\n                raise InvalidPoolError(\n                    \"Order does not contain expected asset.\\n\"\n                    + f\"    Expected: {token}\\n\"\n                    + f\"    Actual: {values['assets']}\",\n                )\n\n    dex_nft = cls.extract_dex_nft(values)\n\n    # Add the pool tokens back in\n    values[\"assets\"].root.update(pair.root)\n\n    cls.post_init(values)\n\n    return values\n</code></pre>"},{"location":"order_book_base/#charli3_dendrite.dexs.ob.ob_base.OrderBookOrder","title":"<code>OrderBookOrder</code>","text":"<p>               Bases: <code>DendriteBaseModel</code></p> <p>Represents an order in the order book.</p> Source code in <code>src/charli3_dendrite/dexs/ob/ob_base.py</code> <pre><code>class OrderBookOrder(DendriteBaseModel):\n    \"\"\"Represents an order in the order book.\"\"\"\n\n    price: float\n    quantity: int\n    state: AbstractOrderState | None = None\n</code></pre>"},{"location":"spectrum/","title":"Spectrum","text":"<p>Spectrum DEX Module.</p>"},{"location":"spectrum/#charli3_dendrite.dexs.amm.spectrum.SpectrumCPPState","title":"<code>SpectrumCPPState</code>","text":"<p>               Bases: <code>AbstractConstantProductPoolState</code></p> <p>The Spectrum DEX constant product pool state.</p> Source code in <code>src/charli3_dendrite/dexs/amm/spectrum.py</code> <pre><code>class SpectrumCPPState(AbstractConstantProductPoolState):\n    \"\"\"The Spectrum DEX constant product pool state.\"\"\"\n\n    fee: int = 0\n    _batcher = Assets(lovelace=1500000)\n    _deposit = Assets(lovelace=2000000)\n    _stake_address: ClassVar[Address] = Address.from_primitive(\n        \"addr1wynp362vmvr8jtc946d3a3utqgclfdl5y9d3kn849e359hsskr20n\",\n    )\n    _reference_utxo: ClassVar[UTxO | None] = None\n\n    @classmethod\n    def dex(cls) -&gt; str:\n        return \"Spectrum\"\n\n    @classmethod\n    def order_selector(self) -&gt; list[str]:\n        return [self._stake_address.encode()]\n\n    @classmethod\n    def pool_selector(cls) -&gt; PoolSelector:\n        return PoolSelector(\n            addresses=[\n                \"addr1x8nz307k3sr60gu0e47cmajssy4fmld7u493a4xztjrll0aj764lvrxdayh2ux30fl0ktuh27csgmpevdu89jlxppvrswgxsta\",\n                \"addr1x94ec3t25egvhqy2n265xfhq882jxhkknurfe9ny4rl9k6dj764lvrxdayh2ux30fl0ktuh27csgmpevdu89jlxppvrst84slu\",\n            ],\n        )\n\n    @property\n    def swap_forward(self) -&gt; bool:\n        return False\n\n    @classmethod\n    def reference_utxo(cls) -&gt; UTxO | None:\n        if cls._reference_utxo is None:\n            script_reference = get_backend().get_script_from_address(cls._stake_address)\n\n            if script_reference is None:\n                return None\n\n            script_bytes = bytes.fromhex(script_reference.script)\n            script = cls.default_script_class()(script_bytes)\n\n            cls._reference_utxo = UTxO(\n                input=TransactionInput(\n                    transaction_id=TransactionId(\n                        bytes.fromhex(\n                            \"fc9e99fd12a13a137725da61e57a410e36747d513b965993d92c32c67df9259a\",\n                        ),\n                    ),\n                    index=2,\n                ),\n                output=TransactionOutput(\n                    address=Address.decode(\n                        \"addr1qxnwr9e72whcp3rnetaj3q34se8kvfqdxpwee6wlnysjt63lwrhst9wmcagdv46as9903ksvmdf7w7x6ujy4ap00yw0q85x25x\",\n                    ),\n                    amount=Value(coin=12266340),\n                    script=script,\n                ),\n            )\n\n        return cls._reference_utxo\n\n    @property\n    def stake_address(self) -&gt; Address:\n        return self._stake_address\n\n    @classmethod\n    def order_datum_class(self) -&gt; type[SpectrumOrderDatum]:\n        return SpectrumOrderDatum\n\n    @classmethod\n    def default_script_class(self) -&gt; type[PlutusV1Script] | type[PlutusV2Script]:\n        return PlutusV2Script\n\n    @classmethod\n    def pool_datum_class(cls) -&gt; type[SpectrumPoolDatum]:\n        return SpectrumPoolDatum\n\n    @property\n    def pool_id(self) -&gt; str:\n        \"\"\"A unique identifier for the pool.\"\"\"\n        return self.pool_nft.unit()\n\n    @classmethod\n    def extract_pool_nft(cls, values) -&gt; Assets:\n        \"\"\"Extract the pool nft from the UTXO.\n\n        Some DEXs put a pool nft into the pool UTXO.\n\n        This function checks to see if the pool nft is in the UTXO if the DEX policy is\n        defined.\n\n        If the pool nft is in the values, this value is skipped because it is assumed\n        that this utxo has already been parsed.\n\n        Args:\n            values: The pool UTXO inputs.\n\n        Returns:\n            Assets: None or the pool nft.\n        \"\"\"\n        assets = values[\"assets\"]\n\n        # If the pool nft is in the values, it's been parsed already\n        if \"pool_nft\" in values:\n            pool_nft = Assets(\n                **{key: value for key, value in values[\"pool_nft\"].items()},\n            )\n            name = bytes.fromhex(pool_nft.unit()[56:]).split(b\"_\")\n            if len(name) != 3 and name[2].decode().lower() != \"nft\":\n                raise NotAPoolError(\"A pool must have one pool NFT token.\")\n\n        # Check for the pool nft\n        else:\n            pool_nft = None\n            for asset in assets:\n                name = bytes.fromhex(asset[56:]).split(b\"_\")\n                if len(name) != 3:\n                    continue\n                if name[2].decode().lower() == \"nft\":\n                    pool_nft = Assets(**{asset: assets.root.pop(asset)})\n                    break\n            if pool_nft is None:\n                raise NotAPoolError(\"A pool must have one pool NFT token.\")\n\n            values[\"pool_nft\"] = pool_nft\n\n        return pool_nft\n\n    @classmethod\n    def extract_lp_tokens(cls, values) -&gt; Assets:\n        \"\"\"Extract the lp tokens from the UTXO.\n\n        Some DEXs put lp tokens into the pool UTXO.\n\n        Args:\n            values: The pool UTXO inputs.\n\n        Returns:\n            Assets: None or the pool nft.\n        \"\"\"\n        assets = values[\"assets\"]\n\n        # If no pool policy id defined, return nothing\n        if \"lp_tokens\" in values:\n            lp_tokens = values[\"lp_tokens\"]\n\n        # Check for the pool nft\n        else:\n            lp_tokens = None\n            for asset in assets:\n                name = bytes.fromhex(asset[56:]).split(b\"_\")\n                if len(name) &lt; 3:\n                    continue\n                if name[2].decode().lower() == \"lq\":\n                    lp_tokens = Assets(**{asset: assets.root.pop(asset)})\n                    break\n            if lp_tokens is None:\n                raise InvalidLPError(\n                    f\"A pool must have pool lp tokens. Token names: {[bytes.fromhex(a[56:]) for a in assets]}\",\n                )\n\n            values[\"lp_tokens\"] = lp_tokens\n\n        # response = requests.post(\n        #     \"https://meta.spectrum.fi/cardano/minting/data/verifyPool/\",\n        #     headers={\"Content-Type\": \"application/json\"},\n        #     data=json.dumps(\n        #         [\n        #             {\n        #                 \"nftCs\": datum.pool_nft.policy.hex(),\n        #                 \"nftTn\": datum.pool_nft.asset_name.hex(),\n        #                 \"lqCs\": datum.pool_lq.policy.hex(),\n        #                 \"lqTn\": datum.pool_lq.asset_name.hex(),\n        #             }\n        #         ]\n        #     ),\n        # ).json()\n        # valid_pool = response[0][1]\n\n        # if not valid_pool:\n        #     raise InvalidPoolError\n\n        return lp_tokens\n\n    @classmethod\n    def post_init(cls, values: dict[str, ...]):\n        super().post_init(values)\n\n        # Check to see if the pool is active\n        datum: SpectrumPoolDatum = SpectrumPoolDatum.from_cbor(values[\"datum_cbor\"])\n\n        assets = values[\"assets\"]\n\n        if len(assets) == 2:\n            quantity = assets.quantity()\n        else:\n            quantity = assets.quantity(1)\n\n        if 2 * quantity &lt;= datum.lq_bound:\n            values[\"inactive\"] = True\n\n        values[\"fee\"] = (1000 - datum.fee_mod) * 10\n\n    def swap_datum(\n        self,\n        address_source: Address,\n        in_assets: Assets,\n        out_assets: Assets,\n        extra_assets: Assets | None = None,\n        address_target: Address | None = None,\n        datum_target: PlutusData | None = None,\n    ) -&gt; PlutusData:\n        if self.swap_forward and address_source is not None:\n            print(f\"{self.__class__.__name__} does not support swap forwarding.\")\n\n        return SpectrumOrderDatum.create_datum(\n            address_source=address_source,\n            in_assets=in_assets,\n            out_assets=out_assets,\n            batcher_fee=self.batcher_fee(in_assets=in_assets, out_assets=out_assets)[\n                \"lovelace\"\n            ],\n            volume_fee=self.volume_fee,\n            pool_token=self.pool_nft,\n        )\n\n    @classmethod\n    def cancel_redeemer(cls) -&gt; PlutusData:\n        return Redeemer(SpectrumCancelRedeemer(0, 0, 0, 1))\n</code></pre>"},{"location":"spectrum/#charli3_dendrite.dexs.amm.spectrum.SpectrumCPPState.pool_id","title":"<code>pool_id: str</code>  <code>property</code>","text":"<p>A unique identifier for the pool.</p>"},{"location":"spectrum/#charli3_dendrite.dexs.amm.spectrum.SpectrumCPPState.extract_lp_tokens","title":"<code>extract_lp_tokens(values) -&gt; Assets</code>  <code>classmethod</code>","text":"<p>Extract the lp tokens from the UTXO.</p> <p>Some DEXs put lp tokens into the pool UTXO.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <p>The pool UTXO inputs.</p> required <p>Returns:</p> Name Type Description <code>Assets</code> <code>Assets</code> <p>None or the pool nft.</p> Source code in <code>src/charli3_dendrite/dexs/amm/spectrum.py</code> <pre><code>@classmethod\ndef extract_lp_tokens(cls, values) -&gt; Assets:\n    \"\"\"Extract the lp tokens from the UTXO.\n\n    Some DEXs put lp tokens into the pool UTXO.\n\n    Args:\n        values: The pool UTXO inputs.\n\n    Returns:\n        Assets: None or the pool nft.\n    \"\"\"\n    assets = values[\"assets\"]\n\n    # If no pool policy id defined, return nothing\n    if \"lp_tokens\" in values:\n        lp_tokens = values[\"lp_tokens\"]\n\n    # Check for the pool nft\n    else:\n        lp_tokens = None\n        for asset in assets:\n            name = bytes.fromhex(asset[56:]).split(b\"_\")\n            if len(name) &lt; 3:\n                continue\n            if name[2].decode().lower() == \"lq\":\n                lp_tokens = Assets(**{asset: assets.root.pop(asset)})\n                break\n        if lp_tokens is None:\n            raise InvalidLPError(\n                f\"A pool must have pool lp tokens. Token names: {[bytes.fromhex(a[56:]) for a in assets]}\",\n            )\n\n        values[\"lp_tokens\"] = lp_tokens\n\n    # response = requests.post(\n    #     \"https://meta.spectrum.fi/cardano/minting/data/verifyPool/\",\n    #     headers={\"Content-Type\": \"application/json\"},\n    #     data=json.dumps(\n    #         [\n    #             {\n    #                 \"nftCs\": datum.pool_nft.policy.hex(),\n    #                 \"nftTn\": datum.pool_nft.asset_name.hex(),\n    #                 \"lqCs\": datum.pool_lq.policy.hex(),\n    #                 \"lqTn\": datum.pool_lq.asset_name.hex(),\n    #             }\n    #         ]\n    #     ),\n    # ).json()\n    # valid_pool = response[0][1]\n\n    # if not valid_pool:\n    #     raise InvalidPoolError\n\n    return lp_tokens\n</code></pre>"},{"location":"spectrum/#charli3_dendrite.dexs.amm.spectrum.SpectrumCPPState.extract_pool_nft","title":"<code>extract_pool_nft(values) -&gt; Assets</code>  <code>classmethod</code>","text":"<p>Extract the pool nft from the UTXO.</p> <p>Some DEXs put a pool nft into the pool UTXO.</p> <p>This function checks to see if the pool nft is in the UTXO if the DEX policy is defined.</p> <p>If the pool nft is in the values, this value is skipped because it is assumed that this utxo has already been parsed.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <p>The pool UTXO inputs.</p> required <p>Returns:</p> Name Type Description <code>Assets</code> <code>Assets</code> <p>None or the pool nft.</p> Source code in <code>src/charli3_dendrite/dexs/amm/spectrum.py</code> <pre><code>@classmethod\ndef extract_pool_nft(cls, values) -&gt; Assets:\n    \"\"\"Extract the pool nft from the UTXO.\n\n    Some DEXs put a pool nft into the pool UTXO.\n\n    This function checks to see if the pool nft is in the UTXO if the DEX policy is\n    defined.\n\n    If the pool nft is in the values, this value is skipped because it is assumed\n    that this utxo has already been parsed.\n\n    Args:\n        values: The pool UTXO inputs.\n\n    Returns:\n        Assets: None or the pool nft.\n    \"\"\"\n    assets = values[\"assets\"]\n\n    # If the pool nft is in the values, it's been parsed already\n    if \"pool_nft\" in values:\n        pool_nft = Assets(\n            **{key: value for key, value in values[\"pool_nft\"].items()},\n        )\n        name = bytes.fromhex(pool_nft.unit()[56:]).split(b\"_\")\n        if len(name) != 3 and name[2].decode().lower() != \"nft\":\n            raise NotAPoolError(\"A pool must have one pool NFT token.\")\n\n    # Check for the pool nft\n    else:\n        pool_nft = None\n        for asset in assets:\n            name = bytes.fromhex(asset[56:]).split(b\"_\")\n            if len(name) != 3:\n                continue\n            if name[2].decode().lower() == \"nft\":\n                pool_nft = Assets(**{asset: assets.root.pop(asset)})\n                break\n        if pool_nft is None:\n            raise NotAPoolError(\"A pool must have one pool NFT token.\")\n\n        values[\"pool_nft\"] = pool_nft\n\n    return pool_nft\n</code></pre>"},{"location":"spectrum/#charli3_dendrite.dexs.amm.spectrum.SpectrumCancelRedeemer","title":"<code>SpectrumCancelRedeemer</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>The cancel redeemer for the Spectrum DEX.</p> Source code in <code>src/charli3_dendrite/dexs/amm/spectrum.py</code> <pre><code>@dataclass\nclass SpectrumCancelRedeemer(PlutusData):\n    \"\"\"The cancel redeemer for the Spectrum DEX.\"\"\"\n\n    CONSTR_ID = 0\n    a: int\n    b: int\n    c: int\n    d: int\n</code></pre>"},{"location":"spectrum/#charli3_dendrite.dexs.amm.spectrum.SpectrumOrderDatum","title":"<code>SpectrumOrderDatum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OrderDatum</code></p> <p>The order datum for the Spectrum DEX.</p> Source code in <code>src/charli3_dendrite/dexs/amm/spectrum.py</code> <pre><code>@dataclass\nclass SpectrumOrderDatum(OrderDatum):\n    \"\"\"The order datum for the Spectrum DEX.\"\"\"\n\n    in_asset: AssetClass\n    out_asset: AssetClass\n    pool_token: AssetClass\n    fee: int\n    numerator: int\n    denominator: int\n    address_payment: bytes\n    address_stake: Union[PlutusPartAddress, PlutusNone]\n    amount: int\n    min_receive: int\n\n    @classmethod\n    def create_datum(\n        cls,\n        address_source: Address,\n        in_assets: Assets,\n        out_assets: Assets,\n        pool_token: Assets,\n        batcher_fee: int,\n        volume_fee: int,\n    ) -&gt; \"SpectrumOrderDatum\":\n        \"\"\"Create a Spectrum order datum.\"\"\"\n        payment_part = bytes.fromhex(str(address_source.payment_part))\n        stake_part = PlutusPartAddress(bytes.fromhex(str(address_source.staking_part)))\n        in_asset = AssetClass.from_assets(in_assets)\n        out_asset = AssetClass.from_assets(out_assets)\n        pool = AssetClass.from_assets(pool_token)\n        fee_mod = (10000 - volume_fee) // 10\n\n        numerator, denominator = float.as_integer_ratio(\n            batcher_fee / out_assets.quantity(),\n        )\n\n        return cls(\n            in_asset=in_asset,\n            out_asset=out_asset,\n            pool_token=pool,\n            fee=fee_mod,\n            numerator=numerator,\n            denominator=denominator,\n            address_payment=payment_part,\n            address_stake=stake_part,\n            amount=in_assets.quantity(),\n            min_receive=out_assets.quantity(),\n        )\n\n    def address_source(self) -&gt; Address:\n        payment_part = VerificationKeyHash(self.address_payment)\n        if isinstance(self.address_stake, PlutusNone):\n            stake_part = None\n        else:\n            stake_part = VerificationKeyHash(self.address_stake.address)\n        return Address(payment_part=payment_part, staking_part=stake_part)\n\n    def requested_amount(self) -&gt; Assets:\n        return Assets({self.out_asset.assets.unit(): self.min_receive})\n\n    def order_type(self) -&gt; OrderType:\n        return OrderType.swap\n</code></pre>"},{"location":"spectrum/#charli3_dendrite.dexs.amm.spectrum.SpectrumOrderDatum.create_datum","title":"<code>create_datum(address_source: Address, in_assets: Assets, out_assets: Assets, pool_token: Assets, batcher_fee: int, volume_fee: int) -&gt; SpectrumOrderDatum</code>  <code>classmethod</code>","text":"<p>Create a Spectrum order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/spectrum.py</code> <pre><code>@classmethod\ndef create_datum(\n    cls,\n    address_source: Address,\n    in_assets: Assets,\n    out_assets: Assets,\n    pool_token: Assets,\n    batcher_fee: int,\n    volume_fee: int,\n) -&gt; \"SpectrumOrderDatum\":\n    \"\"\"Create a Spectrum order datum.\"\"\"\n    payment_part = bytes.fromhex(str(address_source.payment_part))\n    stake_part = PlutusPartAddress(bytes.fromhex(str(address_source.staking_part)))\n    in_asset = AssetClass.from_assets(in_assets)\n    out_asset = AssetClass.from_assets(out_assets)\n    pool = AssetClass.from_assets(pool_token)\n    fee_mod = (10000 - volume_fee) // 10\n\n    numerator, denominator = float.as_integer_ratio(\n        batcher_fee / out_assets.quantity(),\n    )\n\n    return cls(\n        in_asset=in_asset,\n        out_asset=out_asset,\n        pool_token=pool,\n        fee=fee_mod,\n        numerator=numerator,\n        denominator=denominator,\n        address_payment=payment_part,\n        address_stake=stake_part,\n        amount=in_assets.quantity(),\n        min_receive=out_assets.quantity(),\n    )\n</code></pre>"},{"location":"spectrum/#charli3_dendrite.dexs.amm.spectrum.SpectrumPoolDatum","title":"<code>SpectrumPoolDatum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PoolDatum</code></p> <p>The pool datum for the Spectrum DEX.</p> Source code in <code>src/charli3_dendrite/dexs/amm/spectrum.py</code> <pre><code>@dataclass\nclass SpectrumPoolDatum(PoolDatum):\n    \"\"\"The pool datum for the Spectrum DEX.\"\"\"\n\n    pool_nft: AssetClass\n    asset_a: AssetClass\n    asset_b: AssetClass\n    pool_lq: AssetClass\n    fee_mod: int\n    maybe_address: List[bytes]\n    lq_bound: int\n\n    def pool_pair(self) -&gt; Assets | None:\n        return self.asset_a.assets + self.asset_b.assets\n</code></pre>"},{"location":"sundae/","title":"Sundae","text":"<p>SundaeSwap DEX module.</p>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.AmountOut","title":"<code>AmountOut</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Minimum amount to receive.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@dataclass\nclass AmountOut(PlutusData):\n    \"\"\"Minimum amount to receive.\"\"\"\n\n    CONSTR_ID = 0\n    min_receive: int\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.AtoB","title":"<code>AtoB</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>A to B swap direction.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@dataclass\nclass AtoB(PlutusData):\n    \"\"\"A to B swap direction.\"\"\"\n\n    CONSTR_ID = 0\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.BtoA","title":"<code>BtoA</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>B to A swap direction.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@dataclass\nclass BtoA(PlutusData):\n    \"\"\"B to A swap direction.\"\"\"\n\n    CONSTR_ID = 1\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.DepositConfig","title":"<code>DepositConfig</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Deposit configuration.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@dataclass\nclass DepositConfig(PlutusData):\n    \"\"\"Deposit configuration.\"\"\"\n\n    CONSTR_ID = 2\n\n    deposit_pair: DepositPair\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.DepositPair","title":"<code>DepositPair</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Deposit pair.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@dataclass\nclass DepositPair(PlutusData):\n    \"\"\"Deposit pair.\"\"\"\n\n    CONSTR_ID = 1\n    assets: DepositPairQuantity\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.DepositPairQuantity","title":"<code>DepositPairQuantity</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Deposit pair quantity.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@dataclass\nclass DepositPairQuantity(PlutusData):\n    \"\"\"Deposit pair quantity.\"\"\"\n\n    CONSTR_ID = 0\n    amount_a: int\n    amount_b: int\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.LPFee","title":"<code>LPFee</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Liquidity pool fee.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@dataclass\nclass LPFee(PlutusData):\n    \"\"\"Liquidity pool fee.\"\"\"\n\n    CONSTR_ID = 0\n    numerator: int\n    denominator: int\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.LiquidityPoolAssets","title":"<code>LiquidityPoolAssets</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Liquidity pool assets.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@dataclass\nclass LiquidityPoolAssets(PlutusData):\n    \"\"\"Liquidity pool assets.\"\"\"\n\n    CONSTR_ID = 0\n    asset_a: AssetClass\n    asset_b: AssetClass\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeAddressWithDatum","title":"<code>SundaeAddressWithDatum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>SundaeSwap address with datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@dataclass\nclass SundaeAddressWithDatum(PlutusData):\n    \"\"\"SundaeSwap address with datum.\"\"\"\n\n    CONSTR_ID = 0\n\n    address: Union[PlutusFullAddress, PlutusScriptAddress]\n    datum: Union[\n        ReceiverDatum,\n        PlutusNone,\n    ]\n\n    @classmethod\n    def from_address(cls, address: Address) -&gt; \"SundaeAddressWithDatum\":\n        \"\"\"Create a new address with datum.\"\"\"\n        return cls(address=PlutusFullAddress.from_address(address), datum=PlutusNone())\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeAddressWithDatum.from_address","title":"<code>from_address(address: Address) -&gt; SundaeAddressWithDatum</code>  <code>classmethod</code>","text":"<p>Create a new address with datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@classmethod\ndef from_address(cls, address: Address) -&gt; \"SundaeAddressWithDatum\":\n    \"\"\"Create a new address with datum.\"\"\"\n    return cls(address=PlutusFullAddress.from_address(address), datum=PlutusNone())\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeAddressWithDestination","title":"<code>SundaeAddressWithDestination</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>For now, destination is set to none, should be updated.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@dataclass\nclass SundaeAddressWithDestination(PlutusData):\n    \"\"\"For now, destination is set to none, should be updated.\"\"\"\n\n    CONSTR_ID = 0\n\n    address: SundaeAddressWithDatum\n    destination: Union[PlutusPartAddress, PlutusNone]\n\n    @classmethod\n    def from_address(cls, address: Address) -&gt; \"SundaeAddressWithDestination\":\n        \"\"\"Create a new address with destination.\"\"\"\n        null = SundaeAddressWithDatum.from_address(address)\n        return cls(address=null, destination=PlutusNone())\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeAddressWithDestination.from_address","title":"<code>from_address(address: Address) -&gt; SundaeAddressWithDestination</code>  <code>classmethod</code>","text":"<p>Create a new address with destination.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@classmethod\ndef from_address(cls, address: Address) -&gt; \"SundaeAddressWithDestination\":\n    \"\"\"Create a new address with destination.\"\"\"\n    null = SundaeAddressWithDatum.from_address(address)\n    return cls(address=null, destination=PlutusNone())\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeOrderDatum","title":"<code>SundaeOrderDatum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OrderDatum</code></p> <p>SundaeSwap order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@dataclass\nclass SundaeOrderDatum(OrderDatum):\n    \"\"\"SundaeSwap order datum.\"\"\"\n\n    ident: bytes\n    address: SundaeAddressWithDestination\n    fee: int\n    swap: Union[DepositConfig, SwapConfig, WithdrawConfig]\n\n    @classmethod\n    def create_datum(\n        cls,\n        ident: bytes,\n        address_source: Address,\n        in_assets: Assets,\n        out_assets: Assets,\n        fee: int,\n    ) -&gt; \"SundaeOrderDatum\":\n        \"\"\"Create a new order datum.\"\"\"\n        full_address = SundaeAddressWithDestination.from_address(address_source)\n        merged = in_assets + out_assets\n        if in_assets.unit() == merged.unit():\n            direction = AtoB()\n        else:\n            direction = BtoA()\n        swap = SwapConfig(\n            direction=direction,\n            amount_in=in_assets.quantity(),\n            amount_out=AmountOut(min_receive=out_assets.quantity()),\n        )\n\n        return cls(ident=ident, address=full_address, fee=fee, swap=swap)\n\n    def address_source(self) -&gt; Address:\n        \"\"\"Get the source address.\"\"\"\n        return self.address.address.address.to_address()\n\n    def requested_amount(self) -&gt; Assets:\n        \"\"\"Get the requested amount.\"\"\"\n        if isinstance(self.swap, SwapConfig):\n            if isinstance(self.swap.direction, AtoB):\n                return Assets({\"asset_b\": self.swap.amount_out.min_receive})\n            else:\n                return Assets({\"asset_a\": self.swap.amount_out.min_receive})\n        else:\n            return Assets({})\n\n    def order_type(self) -&gt; OrderType | None:\n        \"\"\"Get the order type.\"\"\"\n        order_type = None\n        if isinstance(self.swap, SwapConfig):\n            order_type = OrderType.swap\n        elif isinstance(self.swap, DepositConfig):\n            order_type = OrderType.deposit\n        elif isinstance(self.swap, WithdrawConfig):\n            order_type = OrderType.withdraw\n\n        return order_type\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeOrderDatum.address_source","title":"<code>address_source() -&gt; Address</code>","text":"<p>Get the source address.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>def address_source(self) -&gt; Address:\n    \"\"\"Get the source address.\"\"\"\n    return self.address.address.address.to_address()\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeOrderDatum.create_datum","title":"<code>create_datum(ident: bytes, address_source: Address, in_assets: Assets, out_assets: Assets, fee: int) -&gt; SundaeOrderDatum</code>  <code>classmethod</code>","text":"<p>Create a new order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@classmethod\ndef create_datum(\n    cls,\n    ident: bytes,\n    address_source: Address,\n    in_assets: Assets,\n    out_assets: Assets,\n    fee: int,\n) -&gt; \"SundaeOrderDatum\":\n    \"\"\"Create a new order datum.\"\"\"\n    full_address = SundaeAddressWithDestination.from_address(address_source)\n    merged = in_assets + out_assets\n    if in_assets.unit() == merged.unit():\n        direction = AtoB()\n    else:\n        direction = BtoA()\n    swap = SwapConfig(\n        direction=direction,\n        amount_in=in_assets.quantity(),\n        amount_out=AmountOut(min_receive=out_assets.quantity()),\n    )\n\n    return cls(ident=ident, address=full_address, fee=fee, swap=swap)\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeOrderDatum.order_type","title":"<code>order_type() -&gt; OrderType | None</code>","text":"<p>Get the order type.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>def order_type(self) -&gt; OrderType | None:\n    \"\"\"Get the order type.\"\"\"\n    order_type = None\n    if isinstance(self.swap, SwapConfig):\n        order_type = OrderType.swap\n    elif isinstance(self.swap, DepositConfig):\n        order_type = OrderType.deposit\n    elif isinstance(self.swap, WithdrawConfig):\n        order_type = OrderType.withdraw\n\n    return order_type\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeOrderDatum.requested_amount","title":"<code>requested_amount() -&gt; Assets</code>","text":"<p>Get the requested amount.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>def requested_amount(self) -&gt; Assets:\n    \"\"\"Get the requested amount.\"\"\"\n    if isinstance(self.swap, SwapConfig):\n        if isinstance(self.swap.direction, AtoB):\n            return Assets({\"asset_b\": self.swap.amount_out.min_receive})\n        else:\n            return Assets({\"asset_a\": self.swap.amount_out.min_receive})\n    else:\n        return Assets({})\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaePoolDatum","title":"<code>SundaePoolDatum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PoolDatum</code></p> <p>SundaeSwap pool datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@dataclass\nclass SundaePoolDatum(PoolDatum):\n    \"\"\"SundaeSwap pool datum.\"\"\"\n\n    assets: LiquidityPoolAssets\n    ident: bytes\n    last_swap: int\n    fee: LPFee\n\n    def pool_pair(self) -&gt; Assets | None:\n        return self.assets.asset_a.assets + self.assets.asset_b.assets\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeSwapCPPState","title":"<code>SundaeSwapCPPState</code>","text":"<p>               Bases: <code>AbstractConstantProductPoolState</code></p> <p>SundaeSwap constant product pool state.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>class SundaeSwapCPPState(AbstractConstantProductPoolState):\n    \"\"\"SundaeSwap constant product pool state.\"\"\"\n\n    fee: int = 0\n    _batcher = Assets(lovelace=2500000)\n    _deposit = Assets(lovelace=2000000)\n    _stake_address: ClassVar[Address] = Address.from_primitive(\n        \"addr1wxaptpmxcxawvr3pzlhgnpmzz3ql43n2tc8mn3av5kx0yzs09tqh8\",\n    )\n\n    @classmethod\n    def dex(cls) -&gt; str:\n        \"\"\"Get the DEX name.\"\"\"\n        return \"SundaeSwap\"\n\n    @classmethod\n    def order_selector(self) -&gt; list[str]:\n        \"\"\"Get the order selector.\"\"\"\n        return [self._stake_address.encode()]\n\n    @classmethod\n    def pool_selector(cls) -&gt; PoolSelector:\n        return PoolSelector(\n            addresses=[\"addr1w9qzpelu9hn45pefc0xr4ac4kdxeswq7pndul2vuj59u8tqaxdznu\"],\n        )\n\n    @property\n    def swap_forward(self) -&gt; bool:\n        \"\"\"Check if swap forwarding is enabled.\"\"\"\n        return False\n\n    @property\n    def stake_address(self) -&gt; Address:\n        \"\"\"Get the stake address.\"\"\"\n        return self._stake_address\n\n    @classmethod\n    def order_datum_class(self) -&gt; type[SundaeOrderDatum]:\n        \"\"\"Get the order datum class.\"\"\"\n        return SundaeOrderDatum\n\n    @classmethod\n    def pool_datum_class(cls) -&gt; type[SundaePoolDatum]:\n        \"\"\"Get the pool datum class.\"\"\"\n        return SundaePoolDatum\n\n    @property\n    def pool_id(self) -&gt; str:\n        \"\"\"A unique identifier for the pool.\"\"\"\n        return self.pool_nft.unit()\n\n    @classmethod\n    def skip_init(cls, values) -&gt; bool:\n        \"\"\"Skip the initialization process.\"\"\"\n        if \"pool_nft\" in values and \"dex_nft\" in values and \"fee\" in values:\n            try:\n                super().extract_pool_nft(values)\n            except InvalidPoolError:\n                raise NotAPoolError(\"No pool NFT found.\")\n            if len(values[\"assets\"]) == 3:\n                # Send the ADA token to the end\n                if isinstance(values[\"assets\"], Assets):\n                    values[\"assets\"].root[\"lovelace\"] = values[\"assets\"].root.pop(\n                        \"lovelace\",\n                    )\n                else:\n                    values[\"assets\"][\"lovelace\"] = values[\"assets\"].pop(\"lovelace\")\n            values[\"assets\"] = Assets.model_validate(values[\"assets\"])\n            return True\n        else:\n            return False\n\n    @classmethod\n    def extract_pool_nft(cls, values) -&gt; Assets:\n        \"\"\"Extract the pool NFT.\"\"\"\n        try:\n            super().extract_pool_nft(values)\n        except InvalidPoolError:\n            if len(values[\"assets\"]) == 0:\n                raise NoAssetsError\n            else:\n                raise NotAPoolError(\"No pool NFT found.\")\n\n    @classmethod\n    def pool_policy(cls) -&gt; list[str]:\n        \"\"\"Get the pool policy.\"\"\"\n        return [\"0029cb7c88c7567b63d1a512c0ed626aa169688ec980730c0473b91370\"]\n\n    @classmethod\n    def post_init(cls, values):\n        \"\"\"Post initialization.\"\"\"\n        super().post_init(values)\n\n        assets = values[\"assets\"]\n        datum = SundaePoolDatum.from_cbor(values[\"datum_cbor\"])\n\n        if len(assets) == 2:\n            assets.root[assets.unit(0)] -= 2000000\n        elif len(assets) == 1:\n            msg = \"Reserves contains only 1 token.\"\n            raise InvalidPoolError(msg)\n\n        numerator = datum.fee.numerator\n        denominator = datum.fee.denominator\n        values[\"fee\"] = int(numerator * 10000 / denominator)\n\n    def swap_datum(\n        self,\n        address_source: Address,\n        in_assets: Assets,\n        out_assets: Assets,\n        extra_assets: Assets | None = None,\n        address_target: Address | None = None,\n        datum_target: PlutusData | None = None,\n    ) -&gt; PlutusData:\n        \"\"\"Create a swap datum.\"\"\"\n        if self.swap_forward and address_target is not None:\n            print(f\"{self.__class__.__name__} does not support swap forwarding.\")\n\n        ident = bytes.fromhex(self.pool_nft.unit()[60:])\n\n        return SundaeOrderDatum.create_datum(\n            ident=ident,\n            address_source=address_source,\n            in_assets=in_assets,\n            out_assets=out_assets,\n            fee=self.batcher_fee(in_assets=in_assets, out_assets=out_assets).quantity(),\n        )\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeSwapCPPState.pool_id","title":"<code>pool_id: str</code>  <code>property</code>","text":"<p>A unique identifier for the pool.</p>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeSwapCPPState.stake_address","title":"<code>stake_address: Address</code>  <code>property</code>","text":"<p>Get the stake address.</p>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeSwapCPPState.swap_forward","title":"<code>swap_forward: bool</code>  <code>property</code>","text":"<p>Check if swap forwarding is enabled.</p>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeSwapCPPState.dex","title":"<code>dex() -&gt; str</code>  <code>classmethod</code>","text":"<p>Get the DEX name.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@classmethod\ndef dex(cls) -&gt; str:\n    \"\"\"Get the DEX name.\"\"\"\n    return \"SundaeSwap\"\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeSwapCPPState.extract_pool_nft","title":"<code>extract_pool_nft(values) -&gt; Assets</code>  <code>classmethod</code>","text":"<p>Extract the pool NFT.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@classmethod\ndef extract_pool_nft(cls, values) -&gt; Assets:\n    \"\"\"Extract the pool NFT.\"\"\"\n    try:\n        super().extract_pool_nft(values)\n    except InvalidPoolError:\n        if len(values[\"assets\"]) == 0:\n            raise NoAssetsError\n        else:\n            raise NotAPoolError(\"No pool NFT found.\")\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeSwapCPPState.order_datum_class","title":"<code>order_datum_class() -&gt; type[SundaeOrderDatum]</code>  <code>classmethod</code>","text":"<p>Get the order datum class.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@classmethod\ndef order_datum_class(self) -&gt; type[SundaeOrderDatum]:\n    \"\"\"Get the order datum class.\"\"\"\n    return SundaeOrderDatum\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeSwapCPPState.order_selector","title":"<code>order_selector() -&gt; list[str]</code>  <code>classmethod</code>","text":"<p>Get the order selector.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@classmethod\ndef order_selector(self) -&gt; list[str]:\n    \"\"\"Get the order selector.\"\"\"\n    return [self._stake_address.encode()]\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeSwapCPPState.pool_datum_class","title":"<code>pool_datum_class() -&gt; type[SundaePoolDatum]</code>  <code>classmethod</code>","text":"<p>Get the pool datum class.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@classmethod\ndef pool_datum_class(cls) -&gt; type[SundaePoolDatum]:\n    \"\"\"Get the pool datum class.\"\"\"\n    return SundaePoolDatum\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeSwapCPPState.pool_policy","title":"<code>pool_policy() -&gt; list[str]</code>  <code>classmethod</code>","text":"<p>Get the pool policy.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@classmethod\ndef pool_policy(cls) -&gt; list[str]:\n    \"\"\"Get the pool policy.\"\"\"\n    return [\"0029cb7c88c7567b63d1a512c0ed626aa169688ec980730c0473b91370\"]\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeSwapCPPState.post_init","title":"<code>post_init(values)</code>  <code>classmethod</code>","text":"<p>Post initialization.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@classmethod\ndef post_init(cls, values):\n    \"\"\"Post initialization.\"\"\"\n    super().post_init(values)\n\n    assets = values[\"assets\"]\n    datum = SundaePoolDatum.from_cbor(values[\"datum_cbor\"])\n\n    if len(assets) == 2:\n        assets.root[assets.unit(0)] -= 2000000\n    elif len(assets) == 1:\n        msg = \"Reserves contains only 1 token.\"\n        raise InvalidPoolError(msg)\n\n    numerator = datum.fee.numerator\n    denominator = datum.fee.denominator\n    values[\"fee\"] = int(numerator * 10000 / denominator)\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeSwapCPPState.skip_init","title":"<code>skip_init(values) -&gt; bool</code>  <code>classmethod</code>","text":"<p>Skip the initialization process.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@classmethod\ndef skip_init(cls, values) -&gt; bool:\n    \"\"\"Skip the initialization process.\"\"\"\n    if \"pool_nft\" in values and \"dex_nft\" in values and \"fee\" in values:\n        try:\n            super().extract_pool_nft(values)\n        except InvalidPoolError:\n            raise NotAPoolError(\"No pool NFT found.\")\n        if len(values[\"assets\"]) == 3:\n            # Send the ADA token to the end\n            if isinstance(values[\"assets\"], Assets):\n                values[\"assets\"].root[\"lovelace\"] = values[\"assets\"].root.pop(\n                    \"lovelace\",\n                )\n            else:\n                values[\"assets\"][\"lovelace\"] = values[\"assets\"].pop(\"lovelace\")\n        values[\"assets\"] = Assets.model_validate(values[\"assets\"])\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeSwapCPPState.swap_datum","title":"<code>swap_datum(address_source: Address, in_assets: Assets, out_assets: Assets, extra_assets: Assets | None = None, address_target: Address | None = None, datum_target: PlutusData | None = None) -&gt; PlutusData</code>","text":"<p>Create a swap datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>def swap_datum(\n    self,\n    address_source: Address,\n    in_assets: Assets,\n    out_assets: Assets,\n    extra_assets: Assets | None = None,\n    address_target: Address | None = None,\n    datum_target: PlutusData | None = None,\n) -&gt; PlutusData:\n    \"\"\"Create a swap datum.\"\"\"\n    if self.swap_forward and address_target is not None:\n        print(f\"{self.__class__.__name__} does not support swap forwarding.\")\n\n    ident = bytes.fromhex(self.pool_nft.unit()[60:])\n\n    return SundaeOrderDatum.create_datum(\n        ident=ident,\n        address_source=address_source,\n        in_assets=in_assets,\n        out_assets=out_assets,\n        fee=self.batcher_fee(in_assets=in_assets, out_assets=out_assets).quantity(),\n    )\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeSwapV3CPPState","title":"<code>SundaeSwapV3CPPState</code>","text":"<p>               Bases: <code>AbstractConstantProductPoolState</code></p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>class SundaeSwapV3CPPState(AbstractConstantProductPoolState):\n    fee: int | list[int] = [30, 30]\n    _batcher = Assets(lovelace=1000000)\n    _deposit = Assets(lovelace=2000000)\n    _stake_address: ClassVar[Address] = Address.from_primitive(\n        \"addr1z8ax5k9mutg07p2ngscu3chsauktmstq92z9de938j8nqa7zcka2k2tsgmuedt4xl2j5awftvqzmmv3vs2yduzqxfcmsyun6n3\",\n    )\n\n    @classmethod\n    def dex(cls) -&gt; str:\n        return \"SundaeSwapV3\"\n\n    @classmethod\n    def default_script_class(self) -&gt; type[PlutusV1Script] | type[PlutusV2Script]:\n        return PlutusV2Script\n\n    @classmethod\n    def order_selector(self) -&gt; list[str]:\n        return [self._stake_address.encode()]\n\n    @classmethod\n    def pool_selector(cls) -&gt; PoolSelector:\n        return PoolSelector(\n            addresses=[\"addr1w8srqftqemf0mjlukfszd97ljuxdp44r372txfcr75wrz2cp9h6f8\"],\n        )\n\n    @classmethod\n    def pool_policy(cls) -&gt; list[str]:\n        return [\"e0302560ced2fdcbfcb2602697df970cd0d6a38f94b32703f51c312b\"]\n\n    @property\n    def swap_forward(self) -&gt; bool:\n        return False\n\n    @property\n    def stake_address(self) -&gt; Address:\n        return self._stake_address\n\n    @classmethod\n    def order_datum_class(self) -&gt; type[SundaeV3OrderDatum]:\n        return SundaeV3OrderDatum\n\n    @classmethod\n    def pool_datum_class(self) -&gt; type[SundaeV3PoolDatum]:\n        return SundaeV3PoolDatum\n\n    @property\n    def pool_id(self) -&gt; str:\n        \"\"\"A unique identifier for the pool.\"\"\"\n        return self.pool_nft.unit()\n\n    @classmethod\n    def skip_init(cls, values) -&gt; bool:\n        if \"pool_nft\" in values:\n            try:\n                super().extract_pool_nft(values)\n            except InvalidPoolError:\n                raise NotAPoolError(\"No pool NFT found.\")\n            if len(values[\"assets\"]) == 3:\n                # Send the ADA token to the end\n                if isinstance(values[\"assets\"], Assets):\n                    values[\"assets\"].root[\"lovelace\"] = values[\"assets\"].root.pop(\n                        \"lovelace\",\n                    )\n                else:\n                    values[\"assets\"][\"lovelace\"] = values[\"assets\"].pop(\"lovelace\")\n\n            datum = SundaeV3PoolDatum.from_cbor(values[\"datum_cbor\"])\n            values[\"fee\"] = datum.bid_fees_per_10_thousand\n            values[\"assets\"] = Assets.model_validate(values[\"assets\"])\n\n            settings = get_backend().get_datum_from_address(\n                Address.decode(\n                    \"addr1w9680rk7hkue4e0zkayyh47rxqpg9gzx445mpha3twge75sku2mg0\",\n                ),\n            )\n\n            datum = SundaeV3Settings.from_cbor(settings.datum_cbor)\n            cls._batcher_fee = Assets(lovelace=datum.simple_fee + datum.base_fee)\n            return True\n        else:\n            return False\n\n    @classmethod\n    def extract_pool_nft(cls, values) -&gt; Assets:\n        try:\n            super().extract_pool_nft(values)\n        except InvalidPoolError:\n            if len(values[\"assets\"]) == 0:\n                raise NoAssetsError\n            else:\n                raise NotAPoolError(\"No pool NFT found.\")\n\n    @classmethod\n    def post_init(cls, values):\n        super().post_init(values)\n\n        assets = values[\"assets\"]\n        datum = SundaeV3PoolDatum.from_cbor(values[\"datum_cbor\"])\n\n        if len(assets) == 2:\n            assets.root[assets.unit(0)] -= datum.protocol_fees\n\n        values[\"fee\"] = [datum.bid_fees_per_10_thousand, datum.ask_fees_per_10_thousand]\n\n        settings = get_backend().get_datum_from_address(\n            Address.decode(\n                \"addr1w9680rk7hkue4e0zkayyh47rxqpg9gzx445mpha3twge75sku2mg0\",\n            ),\n        )\n\n        datum = SundaeV3Settings.from_cbor(settings.datum_cbor)\n        cls._batcher_fee = Assets(lovelace=datum.simple_fee + datum.base_fee)\n\n    def swap_datum(\n        self,\n        address_source: Address,\n        in_assets: Assets,\n        out_assets: Assets,\n        extra_assets: Assets | None = None,\n        address_target: Address | None = None,\n        datum_target: PlutusData | None = None,\n    ) -&gt; PlutusData:\n        if self.swap_forward and address_target is not None:\n            print(f\"{self.__class__.__name__} does not support swap forwarding.\")\n\n        ident = bytes.fromhex(self.pool_nft.unit()[64:])\n\n        datum = SundaeV3OrderDatum.create_datum(\n            ident=ident,\n            address_source=address_source,\n            in_assets=in_assets,\n            out_assets=out_assets,\n            fee=self.batcher_fee(in_assets=in_assets, out_assets=out_assets).quantity(),\n        )\n\n        return datum\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SundaeSwapV3CPPState.pool_id","title":"<code>pool_id: str</code>  <code>property</code>","text":"<p>A unique identifier for the pool.</p>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.SwapConfig","title":"<code>SwapConfig</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Swap configuration.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@dataclass\nclass SwapConfig(PlutusData):\n    \"\"\"Swap configuration.\"\"\"\n\n    CONSTR_ID = 0\n\n    direction: Union[AtoB, BtoA]\n    amount_in: int\n    amount_out: AmountOut\n</code></pre>"},{"location":"sundae/#charli3_dendrite.dexs.amm.sundae.WithdrawConfig","title":"<code>WithdrawConfig</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Withdraw configuration.</p> Source code in <code>src/charli3_dendrite/dexs/amm/sundae.py</code> <pre><code>@dataclass\nclass WithdrawConfig(PlutusData):\n    \"\"\"Withdraw configuration.\"\"\"\n\n    CONSTR_ID = 1\n\n    amount_lp: int\n</code></pre>"},{"location":"types/","title":"Types","text":"<p>Module providing types and state classes for AMM pools.</p>"},{"location":"types/#charli3_dendrite.dexs.amm.amm_types.AbstractCommonStableSwapPoolState","title":"<code>AbstractCommonStableSwapPoolState</code>","text":"<p>               Bases: <code>AbstractStableSwapPoolState</code></p> <p>The common variant of StableSwap.</p> <p>This class implements the common variant of the stableswap algorithm. The main difference is the</p> Source code in <code>src/charli3_dendrite/dexs/amm/amm_types.py</code> <pre><code>class AbstractCommonStableSwapPoolState(AbstractStableSwapPoolState):\n    \"\"\"The common variant of StableSwap.\n\n    This class implements the common variant of the stableswap algorithm. The main\n    difference is the\n    \"\"\"\n\n    def _get_ann(self) -&gt; int:\n        \"\"\"The modified amp value.\n\n        This is the ann value in the common stableswap variant.\n        \"\"\"\n        return self.amp * N_COINS\n</code></pre>"},{"location":"types/#charli3_dendrite.dexs.amm.amm_types.AbstractConstantLiquidityPoolState","title":"<code>AbstractConstantLiquidityPoolState</code>","text":"<p>               Bases: <code>AbstractPoolState</code></p> <p>Represents the state of a constant liquidity pool automated market maker (AMM).</p> <p>This class serves as a base for constant liquidity pool implementations, providing methods to calculate the input and output asset amounts for swaps.</p> Source code in <code>src/charli3_dendrite/dexs/amm/amm_types.py</code> <pre><code>class AbstractConstantLiquidityPoolState(AbstractPoolState):\n    \"\"\"Represents the state of a constant liquidity pool automated market maker (AMM).\n\n    This class serves as a base for constant liquidity pool implementations, providing\n    methods to calculate the input and output asset amounts for swaps.\n    \"\"\"\n\n    def get_amount_out(\n        self,\n        asset: Assets,\n        precise: bool = True,\n    ) -&gt; tuple[Assets, float]:\n        \"\"\"Calculate the output amount for a given input in a constant liquidity pool.\n\n        Args:\n            asset (Assets): The input asset amount for the swap.\n            precise (bool): If True: the output rounded to the nearest integer.\n\n        Returns:\n            tuple[Assets, float]: Tuple containing the output asset and float value.\n\n        Raises:\n            NotImplementedError: This method is not implemented in the base class.\n        \"\"\"\n        error_msg = \"CLPP amount out is not yet implemented.\"\n        raise NotImplementedError(error_msg)\n\n    def get_amount_in(\n        self,\n        asset: Assets,\n        precise: bool = True,\n    ) -&gt; tuple[Assets, float]:\n        \"\"\"Calculate input amount needed for desired output in constant liquidity pool.\n\n        Args:\n            asset (Assets): The desired output asset amount for the swap.\n            precise (bool): If True: the output rounded to the nearest integer.\n\n        Returns:\n            tuple[Assets, float]: Tuple containing required input asset and float value.\n\n        Raises:\n            NotImplementedError: This method is not implemented in the base class.\n        \"\"\"\n        error_msg = \"CLPP amount in is not yet implemented.\"\n        raise NotImplementedError(error_msg)\n</code></pre>"},{"location":"types/#charli3_dendrite.dexs.amm.amm_types.AbstractConstantLiquidityPoolState.get_amount_in","title":"<code>get_amount_in(asset: Assets, precise: bool = True) -&gt; tuple[Assets, float]</code>","text":"<p>Calculate input amount needed for desired output in constant liquidity pool.</p> <p>Parameters:</p> Name Type Description Default <code>asset</code> <code>Assets</code> <p>The desired output asset amount for the swap.</p> required <code>precise</code> <code>bool</code> <p>If True: the output rounded to the nearest integer.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[Assets, float]</code> <p>tuple[Assets, float]: Tuple containing required input asset and float value.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method is not implemented in the base class.</p> Source code in <code>src/charli3_dendrite/dexs/amm/amm_types.py</code> <pre><code>def get_amount_in(\n    self,\n    asset: Assets,\n    precise: bool = True,\n) -&gt; tuple[Assets, float]:\n    \"\"\"Calculate input amount needed for desired output in constant liquidity pool.\n\n    Args:\n        asset (Assets): The desired output asset amount for the swap.\n        precise (bool): If True: the output rounded to the nearest integer.\n\n    Returns:\n        tuple[Assets, float]: Tuple containing required input asset and float value.\n\n    Raises:\n        NotImplementedError: This method is not implemented in the base class.\n    \"\"\"\n    error_msg = \"CLPP amount in is not yet implemented.\"\n    raise NotImplementedError(error_msg)\n</code></pre>"},{"location":"types/#charli3_dendrite.dexs.amm.amm_types.AbstractConstantLiquidityPoolState.get_amount_out","title":"<code>get_amount_out(asset: Assets, precise: bool = True) -&gt; tuple[Assets, float]</code>","text":"<p>Calculate the output amount for a given input in a constant liquidity pool.</p> <p>Parameters:</p> Name Type Description Default <code>asset</code> <code>Assets</code> <p>The input asset amount for the swap.</p> required <code>precise</code> <code>bool</code> <p>If True: the output rounded to the nearest integer.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[Assets, float]</code> <p>tuple[Assets, float]: Tuple containing the output asset and float value.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method is not implemented in the base class.</p> Source code in <code>src/charli3_dendrite/dexs/amm/amm_types.py</code> <pre><code>def get_amount_out(\n    self,\n    asset: Assets,\n    precise: bool = True,\n) -&gt; tuple[Assets, float]:\n    \"\"\"Calculate the output amount for a given input in a constant liquidity pool.\n\n    Args:\n        asset (Assets): The input asset amount for the swap.\n        precise (bool): If True: the output rounded to the nearest integer.\n\n    Returns:\n        tuple[Assets, float]: Tuple containing the output asset and float value.\n\n    Raises:\n        NotImplementedError: This method is not implemented in the base class.\n    \"\"\"\n    error_msg = \"CLPP amount out is not yet implemented.\"\n    raise NotImplementedError(error_msg)\n</code></pre>"},{"location":"types/#charli3_dendrite.dexs.amm.amm_types.AbstractConstantProductPoolState","title":"<code>AbstractConstantProductPoolState</code>","text":"<p>               Bases: <code>AbstractPoolState</code></p> <p>Represents the state of a constant product automated market maker (AMM) pool.</p> Source code in <code>src/charli3_dendrite/dexs/amm/amm_types.py</code> <pre><code>class AbstractConstantProductPoolState(AbstractPoolState):\n    \"\"\"Represents the state of a constant product automated market maker (AMM) pool.\"\"\"\n\n    def get_amount_out(\n        self,\n        asset: Assets,\n        precise: bool = True,\n    ) -&gt; tuple[Assets, float]:\n        \"\"\"Get the output asset amount given an input asset amount.\n\n        Args:\n            asset (Assets): An asset with a defined quantity.\n            precise (bool): Whether to return precise calculations.\n\n        Returns:\n            A tuple where the first value is the estimated asset returned from the swap\n                and the second value is the price impact ratio.\n        \"\"\"\n        if len(asset) != 1:\n            error_msg = \"Asset should only have one token.\"\n            raise ValueError(error_msg)\n        if asset.unit() not in [self.unit_a, self.unit_b]:\n            error_msg = (\n                f\"Asset {asset.unit()} is invalid for pool {self.unit_a}-{self.unit_b}\"\n            )\n            raise ValueError(error_msg)\n\n        if asset.unit() == self.unit_a:\n            reserve_in, reserve_out = self.reserve_a, self.reserve_b\n            unit_out = self.unit_b\n        else:\n            reserve_in, reserve_out = self.reserve_b, self.reserve_a\n            unit_out = self.unit_a\n\n        volume_fee: int = 0\n        if self.volume_fee is not None:\n            if isinstance(self.volume_fee, int):\n                volume_fee = self.volume_fee\n            elif asset.unit() == self.unit_a:\n                volume_fee = self.volume_fee[0]\n            else:\n                volume_fee = self.volume_fee[1]\n\n        # Calculate the amount out\n        fee_modifier = 10000 - volume_fee\n        numerator: int = asset.quantity() * fee_modifier * reserve_out\n        denominator: int = asset.quantity() * fee_modifier + reserve_in * 10000\n        amount_out = Assets(**{unit_out: numerator // denominator})\n        if not precise:\n            amount_out.root[unit_out] = numerator // denominator\n\n        if amount_out.quantity() == 0:\n            return amount_out, 0\n\n        # Calculate the price impact\n        price_numerator: int = (\n            reserve_out * asset.quantity() * denominator * fee_modifier\n            - numerator * reserve_in * 10000\n        )\n        price_denominator: int = reserve_out * asset.quantity() * denominator * 10000\n        price_impact: float = price_numerator / price_denominator\n\n        return amount_out, price_impact\n\n    def get_amount_in(\n        self,\n        asset: Assets,\n        precise: bool = True,\n    ) -&gt; tuple[Assets, float]:\n        \"\"\"Get the input asset amount given a desired output asset amount.\n\n        Args:\n            asset (Assets): An asset with a defined quantity.\n            precise (bool): Whether to return precise calculations.\n\n        Returns:\n            The estimated asset needed for input in the swap.\n        \"\"\"\n        if len(asset) != 1:\n            error_msg = \"Asset should only have one token.\"\n            raise ValueError(error_msg)\n        if asset.unit() not in [self.unit_a, self.unit_b]:\n            error_msg = (\n                f\"Asset {asset.unit()} is invalid for pool {self.unit_a}-{self.unit_b}\"\n            )\n            raise ValueError(error_msg)\n\n        if asset.unit() == self.unit_b:\n            reserve_in, reserve_out = self.reserve_a, self.reserve_b\n            unit_out = self.unit_a\n        else:\n            reserve_in, reserve_out = self.reserve_b, self.reserve_a\n            unit_out = self.unit_b\n\n        volume_fee: int = 0\n        if self.volume_fee is not None:\n            if isinstance(self.volume_fee, int):\n                volume_fee = self.volume_fee\n            elif asset.unit() == self.unit_b:\n                volume_fee = self.volume_fee[0]\n            else:\n                volume_fee = self.volume_fee[1]\n\n        # Estimate the required input\n        fee_modifier = 10000 - volume_fee\n        numerator: int = asset.quantity() * 10000 * reserve_in\n        denominator: int = (reserve_out - asset.quantity()) * fee_modifier\n        amount_in = Assets(**{unit_out: numerator // denominator})\n        if not precise:\n            amount_in.root[unit_out] = numerator // denominator\n\n        # Estimate the price impact\n        price_numerator: int = (\n            reserve_out * numerator * fee_modifier\n            - asset.quantity() * denominator * reserve_in * 10000\n        )\n        price_denominator: int = reserve_out * numerator * 10000\n        price_impact: float = price_numerator / price_denominator\n\n        return amount_in, price_impact\n</code></pre>"},{"location":"types/#charli3_dendrite.dexs.amm.amm_types.AbstractConstantProductPoolState.get_amount_in","title":"<code>get_amount_in(asset: Assets, precise: bool = True) -&gt; tuple[Assets, float]</code>","text":"<p>Get the input asset amount given a desired output asset amount.</p> <p>Parameters:</p> Name Type Description Default <code>asset</code> <code>Assets</code> <p>An asset with a defined quantity.</p> required <code>precise</code> <code>bool</code> <p>Whether to return precise calculations.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[Assets, float]</code> <p>The estimated asset needed for input in the swap.</p> Source code in <code>src/charli3_dendrite/dexs/amm/amm_types.py</code> <pre><code>def get_amount_in(\n    self,\n    asset: Assets,\n    precise: bool = True,\n) -&gt; tuple[Assets, float]:\n    \"\"\"Get the input asset amount given a desired output asset amount.\n\n    Args:\n        asset (Assets): An asset with a defined quantity.\n        precise (bool): Whether to return precise calculations.\n\n    Returns:\n        The estimated asset needed for input in the swap.\n    \"\"\"\n    if len(asset) != 1:\n        error_msg = \"Asset should only have one token.\"\n        raise ValueError(error_msg)\n    if asset.unit() not in [self.unit_a, self.unit_b]:\n        error_msg = (\n            f\"Asset {asset.unit()} is invalid for pool {self.unit_a}-{self.unit_b}\"\n        )\n        raise ValueError(error_msg)\n\n    if asset.unit() == self.unit_b:\n        reserve_in, reserve_out = self.reserve_a, self.reserve_b\n        unit_out = self.unit_a\n    else:\n        reserve_in, reserve_out = self.reserve_b, self.reserve_a\n        unit_out = self.unit_b\n\n    volume_fee: int = 0\n    if self.volume_fee is not None:\n        if isinstance(self.volume_fee, int):\n            volume_fee = self.volume_fee\n        elif asset.unit() == self.unit_b:\n            volume_fee = self.volume_fee[0]\n        else:\n            volume_fee = self.volume_fee[1]\n\n    # Estimate the required input\n    fee_modifier = 10000 - volume_fee\n    numerator: int = asset.quantity() * 10000 * reserve_in\n    denominator: int = (reserve_out - asset.quantity()) * fee_modifier\n    amount_in = Assets(**{unit_out: numerator // denominator})\n    if not precise:\n        amount_in.root[unit_out] = numerator // denominator\n\n    # Estimate the price impact\n    price_numerator: int = (\n        reserve_out * numerator * fee_modifier\n        - asset.quantity() * denominator * reserve_in * 10000\n    )\n    price_denominator: int = reserve_out * numerator * 10000\n    price_impact: float = price_numerator / price_denominator\n\n    return amount_in, price_impact\n</code></pre>"},{"location":"types/#charli3_dendrite.dexs.amm.amm_types.AbstractConstantProductPoolState.get_amount_out","title":"<code>get_amount_out(asset: Assets, precise: bool = True) -&gt; tuple[Assets, float]</code>","text":"<p>Get the output asset amount given an input asset amount.</p> <p>Parameters:</p> Name Type Description Default <code>asset</code> <code>Assets</code> <p>An asset with a defined quantity.</p> required <code>precise</code> <code>bool</code> <p>Whether to return precise calculations.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[Assets, float]</code> <p>A tuple where the first value is the estimated asset returned from the swap and the second value is the price impact ratio.</p> Source code in <code>src/charli3_dendrite/dexs/amm/amm_types.py</code> <pre><code>def get_amount_out(\n    self,\n    asset: Assets,\n    precise: bool = True,\n) -&gt; tuple[Assets, float]:\n    \"\"\"Get the output asset amount given an input asset amount.\n\n    Args:\n        asset (Assets): An asset with a defined quantity.\n        precise (bool): Whether to return precise calculations.\n\n    Returns:\n        A tuple where the first value is the estimated asset returned from the swap\n            and the second value is the price impact ratio.\n    \"\"\"\n    if len(asset) != 1:\n        error_msg = \"Asset should only have one token.\"\n        raise ValueError(error_msg)\n    if asset.unit() not in [self.unit_a, self.unit_b]:\n        error_msg = (\n            f\"Asset {asset.unit()} is invalid for pool {self.unit_a}-{self.unit_b}\"\n        )\n        raise ValueError(error_msg)\n\n    if asset.unit() == self.unit_a:\n        reserve_in, reserve_out = self.reserve_a, self.reserve_b\n        unit_out = self.unit_b\n    else:\n        reserve_in, reserve_out = self.reserve_b, self.reserve_a\n        unit_out = self.unit_a\n\n    volume_fee: int = 0\n    if self.volume_fee is not None:\n        if isinstance(self.volume_fee, int):\n            volume_fee = self.volume_fee\n        elif asset.unit() == self.unit_a:\n            volume_fee = self.volume_fee[0]\n        else:\n            volume_fee = self.volume_fee[1]\n\n    # Calculate the amount out\n    fee_modifier = 10000 - volume_fee\n    numerator: int = asset.quantity() * fee_modifier * reserve_out\n    denominator: int = asset.quantity() * fee_modifier + reserve_in * 10000\n    amount_out = Assets(**{unit_out: numerator // denominator})\n    if not precise:\n        amount_out.root[unit_out] = numerator // denominator\n\n    if amount_out.quantity() == 0:\n        return amount_out, 0\n\n    # Calculate the price impact\n    price_numerator: int = (\n        reserve_out * asset.quantity() * denominator * fee_modifier\n        - numerator * reserve_in * 10000\n    )\n    price_denominator: int = reserve_out * asset.quantity() * denominator * 10000\n    price_impact: float = price_numerator / price_denominator\n\n    return amount_out, price_impact\n</code></pre>"},{"location":"types/#charli3_dendrite.dexs.amm.amm_types.AbstractStableSwapPoolState","title":"<code>AbstractStableSwapPoolState</code>","text":"<p>               Bases: <code>AbstractPoolState</code></p> <p>Represents the state of a stable swap automated market maker (AMM) pool.</p> Source code in <code>src/charli3_dendrite/dexs/amm/amm_types.py</code> <pre><code>class AbstractStableSwapPoolState(AbstractPoolState):\n    \"\"\"Represents the state of a stable swap automated market maker (AMM) pool.\"\"\"\n\n    asset_mulitipliers: ClassVar[list[int]] = [1, 1]\n\n    @property\n    def reserve_a(self) -&gt; int:\n        \"\"\"Reserve amount of asset A.\"\"\"\n        return self.assets.quantity(0) * self.asset_mulitipliers[0]\n\n    @property\n    def reserve_b(self) -&gt; int:\n        \"\"\"Reserve amount of asset B.\"\"\"\n        return self.assets.quantity(1) * self.asset_mulitipliers[1]\n\n    @property\n    def amp(self) -&gt; int:\n        \"\"\"Amplification coefficient used in the stable swap algorithm.\"\"\"\n        return 75\n\n    def _get_ann(self) -&gt; int:\n        \"\"\"The modified amp value.\n\n        This is the derived amp value (ann) from the original stableswap paper. This is\n        implemented here as the default, but a common variant of this does not use the\n        exponent. The alternative version is provided in the\n        AbstractCommonStableSwapPoolState class. WingRiders uses this version.\n        \"\"\"\n        return self.amp * N_COINS**N_COINS\n\n    def _get_d(self) -&gt; float:\n        \"\"\"Regression to learn the stability constant.\"\"\"\n        # TODO: Expand this to operate on pools with more than one stable\n        ann = self._get_ann()\n        s = self.reserve_a + self.reserve_b\n        if s == 0:\n            return 0\n\n        # Iterate until the change in value is &lt;1 unit.\n        d = s\n        for _ in range(256):\n            d_p = d**3 / (N_COINS**N_COINS * self.reserve_a * self.reserve_b)\n            d_prev = d\n            d = d * (ann * s + d_p * N_COINS) / ((ann - 1) * d + (N_COINS + 1) * d_p)\n\n            if abs(d - d_prev) &lt; 1:\n                break\n\n        return d\n\n    def _get_y(\n        self,\n        in_assets: Assets,\n        out_unit: str,\n        precise: bool = True,\n        get_input: bool = False,\n    ) -&gt; Assets:\n        \"\"\"Calculate the output amount using a regression.\"\"\"\n        ann = self._get_ann()\n        d = self._get_d()\n\n        subtract = -1 if get_input else 1\n\n        # Make sure only one input supplied\n        if len(in_assets) &gt; 1:\n            error_msg = \"Only one input asset allowed.\"\n            raise ValueError(error_msg)\n        if in_assets.unit() not in [self.unit_a, self.unit_b]:\n            error_msg = \"Invalid input token.\"\n            raise ValueError(error_msg)\n        if out_unit not in [self.unit_a, self.unit_b]:\n            error_msg = \"Invalid output token.\"\n            raise ValueError(error_msg)\n\n        in_quantity = in_assets.quantity()\n        if in_assets.unit() == self.unit_a:\n            in_reserve = (\n                self.reserve_a + in_quantity * self.asset_mulitipliers[0] * subtract\n            )\n            out_multiplier = self.asset_mulitipliers[1]\n        else:\n            in_reserve = (\n                self.reserve_b + in_quantity * self.asset_mulitipliers[1] * subtract\n            )\n            out_multiplier = self.asset_mulitipliers[0]\n\n        s = in_reserve\n        c = d**3 / (N_COINS**2 * ann * in_reserve)\n        b = s + d / ann\n        out_prev = 0\n        out = d\n\n        for _ in range(256):\n            out_prev = int(out)\n            out = (out**2 + c) / (2 * out + b - d)\n\n            if abs(out - out_prev) &lt; 1:\n                break\n\n        out /= out_multiplier\n        out_assets = Assets(**{out_unit: int(out)})\n        if not precise:\n            out_assets.root[out_unit] = int(out)\n\n        return out_assets\n\n    def get_amount_out(\n        self,\n        asset: Assets,\n        precise: bool = True,\n        fee_on_input: bool = True,\n    ) -&gt; tuple[Assets, float]:\n        \"\"\"Calculate the amount of assets received when swapping a given input amount.\n\n        This function computes the output amount for a swap operation in the\n        stable swap pool, taking into account the volume fee and precision settings.\n\n        Args:\n            asset (Assets): The input asset amount for the swap.\n            precise (bool): If True, returns precise integer output. Default True.\n            fee_on_input (bool): If True, applies the fee to the input amount.\n                                        If False, applies the fee to the output amount.\n                                        Defaults to True.\n\n        Returns:\n            tuple[Assets, float]: A tuple containing:\n                - The output asset amount after the swap.\n                - A float value (always 0 in this implementation).\n\n        Raises:\n            ValueError: If the input asset is invalid or if multiple input\n              assets are provided.\n        \"\"\"\n        volume_fee: int = 0\n        if self.volume_fee is not None:\n            if isinstance(self.volume_fee, (int, float)):\n                volume_fee = self.volume_fee\n            elif asset.unit() == self.unit_a:\n                volume_fee = self.volume_fee[0]\n            else:\n                volume_fee = self.volume_fee[1]\n\n        if fee_on_input:\n            in_asset = Assets(\n                **{\n                    asset.unit(): int(\n                        asset.quantity() * (10000 - volume_fee) / 10000,\n                    ),\n                },\n            )\n        else:\n            in_asset = asset\n        out_unit = self.unit_a if asset.unit() == self.unit_b else self.unit_b\n        out_asset = self._get_y(in_asset, out_unit, precise=precise)\n        out_reserve = (\n            self.reserve_b / self.asset_mulitipliers[1]\n            if out_unit == self.unit_b\n            else self.reserve_a / self.asset_mulitipliers[0]\n        )\n\n        out_asset.root[out_asset.unit()] = int(out_reserve - out_asset.quantity())\n        if not fee_on_input:\n            out_asset.root[out_asset.unit()] = int(\n                out_asset.quantity() * (10000 - volume_fee) / 10000,\n            )\n        if precise:\n            out_asset.root[out_asset.unit()] = int(out_asset.quantity())\n\n        return out_asset, 0\n\n    def get_amount_in(\n        self,\n        asset: Assets,\n        precise: bool = True,\n        fee_on_input: bool = True,\n    ) -&gt; tuple[Assets, float]:\n        \"\"\"Calculate the amount of assets required as input to receive a given output.\n\n        This function computes the input amount needed for a swap operation in the\n        stable swap pool to achieve a desired output, taking into account the\n        volume fee and precision settings.\n\n        Args:\n            asset (Assets): The desired output asset amount for the swap.\n            precise (bool): If True, returns precise integer input. Defaults to True.\n            fee_on_input (bool): If True, applies the fee to the calculated input.\n                                        If False, applies the fee to the given output.\n                                        Defaults to True.\n\n        Returns:\n            tuple[Assets, float]: A tuple containing:\n                - The input asset amount required for the swap.\n                - A float value (always 0 in this implementation).\n\n        Raises:\n            ValueError: If the output asset is invalid or if multiple output\n            assets are provided.\n        \"\"\"\n        volume_fee: int = 0\n        if self.volume_fee is not None:\n            if isinstance(self.volume_fee, (int, float)):\n                volume_fee = self.volume_fee\n            elif asset.unit() == self.unit_a:\n                volume_fee = self.volume_fee[0]\n            else:\n                volume_fee = self.volume_fee[1]\n\n        if not fee_on_input:\n            out_asset = Assets(\n                **{\n                    asset.unit(): int(\n                        asset.quantity() * 10000 / (10000 - volume_fee),\n                    ),\n                },\n            )\n        else:\n            out_asset = asset\n        in_unit = self.unit_a if asset.unit() == self.unit_b else self.unit_b\n        in_asset = self._get_y(out_asset, in_unit, precise=precise, get_input=True)\n        in_reserve = (\n            (self.reserve_b / self.asset_mulitipliers[1])\n            if in_unit == self.unit_b\n            else (self.reserve_a / self.asset_mulitipliers[0])\n        )\n        in_asset.root[in_asset.unit()] = int(in_asset.quantity() - in_reserve)\n        if fee_on_input:\n            in_asset.root[in_asset.unit()] = int(\n                in_asset.quantity() * 10000 / (10000 - volume_fee),\n            )\n        if precise:\n            in_asset.root[in_asset.unit()] = int(in_asset.quantity())\n        return in_asset, 0\n</code></pre>"},{"location":"types/#charli3_dendrite.dexs.amm.amm_types.AbstractStableSwapPoolState.amp","title":"<code>amp: int</code>  <code>property</code>","text":"<p>Amplification coefficient used in the stable swap algorithm.</p>"},{"location":"types/#charli3_dendrite.dexs.amm.amm_types.AbstractStableSwapPoolState.reserve_a","title":"<code>reserve_a: int</code>  <code>property</code>","text":"<p>Reserve amount of asset A.</p>"},{"location":"types/#charli3_dendrite.dexs.amm.amm_types.AbstractStableSwapPoolState.reserve_b","title":"<code>reserve_b: int</code>  <code>property</code>","text":"<p>Reserve amount of asset B.</p>"},{"location":"types/#charli3_dendrite.dexs.amm.amm_types.AbstractStableSwapPoolState.get_amount_in","title":"<code>get_amount_in(asset: Assets, precise: bool = True, fee_on_input: bool = True) -&gt; tuple[Assets, float]</code>","text":"<p>Calculate the amount of assets required as input to receive a given output.</p> <p>This function computes the input amount needed for a swap operation in the stable swap pool to achieve a desired output, taking into account the volume fee and precision settings.</p> <p>Parameters:</p> Name Type Description Default <code>asset</code> <code>Assets</code> <p>The desired output asset amount for the swap.</p> required <code>precise</code> <code>bool</code> <p>If True, returns precise integer input. Defaults to True.</p> <code>True</code> <code>fee_on_input</code> <code>bool</code> <p>If True, applies the fee to the calculated input.                         If False, applies the fee to the given output.                         Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[Assets, float]</code> <p>tuple[Assets, float]: A tuple containing: - The input asset amount required for the swap. - A float value (always 0 in this implementation).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the output asset is invalid or if multiple output</p> Source code in <code>src/charli3_dendrite/dexs/amm/amm_types.py</code> <pre><code>def get_amount_in(\n    self,\n    asset: Assets,\n    precise: bool = True,\n    fee_on_input: bool = True,\n) -&gt; tuple[Assets, float]:\n    \"\"\"Calculate the amount of assets required as input to receive a given output.\n\n    This function computes the input amount needed for a swap operation in the\n    stable swap pool to achieve a desired output, taking into account the\n    volume fee and precision settings.\n\n    Args:\n        asset (Assets): The desired output asset amount for the swap.\n        precise (bool): If True, returns precise integer input. Defaults to True.\n        fee_on_input (bool): If True, applies the fee to the calculated input.\n                                    If False, applies the fee to the given output.\n                                    Defaults to True.\n\n    Returns:\n        tuple[Assets, float]: A tuple containing:\n            - The input asset amount required for the swap.\n            - A float value (always 0 in this implementation).\n\n    Raises:\n        ValueError: If the output asset is invalid or if multiple output\n        assets are provided.\n    \"\"\"\n    volume_fee: int = 0\n    if self.volume_fee is not None:\n        if isinstance(self.volume_fee, (int, float)):\n            volume_fee = self.volume_fee\n        elif asset.unit() == self.unit_a:\n            volume_fee = self.volume_fee[0]\n        else:\n            volume_fee = self.volume_fee[1]\n\n    if not fee_on_input:\n        out_asset = Assets(\n            **{\n                asset.unit(): int(\n                    asset.quantity() * 10000 / (10000 - volume_fee),\n                ),\n            },\n        )\n    else:\n        out_asset = asset\n    in_unit = self.unit_a if asset.unit() == self.unit_b else self.unit_b\n    in_asset = self._get_y(out_asset, in_unit, precise=precise, get_input=True)\n    in_reserve = (\n        (self.reserve_b / self.asset_mulitipliers[1])\n        if in_unit == self.unit_b\n        else (self.reserve_a / self.asset_mulitipliers[0])\n    )\n    in_asset.root[in_asset.unit()] = int(in_asset.quantity() - in_reserve)\n    if fee_on_input:\n        in_asset.root[in_asset.unit()] = int(\n            in_asset.quantity() * 10000 / (10000 - volume_fee),\n        )\n    if precise:\n        in_asset.root[in_asset.unit()] = int(in_asset.quantity())\n    return in_asset, 0\n</code></pre>"},{"location":"types/#charli3_dendrite.dexs.amm.amm_types.AbstractStableSwapPoolState.get_amount_out","title":"<code>get_amount_out(asset: Assets, precise: bool = True, fee_on_input: bool = True) -&gt; tuple[Assets, float]</code>","text":"<p>Calculate the amount of assets received when swapping a given input amount.</p> <p>This function computes the output amount for a swap operation in the stable swap pool, taking into account the volume fee and precision settings.</p> <p>Parameters:</p> Name Type Description Default <code>asset</code> <code>Assets</code> <p>The input asset amount for the swap.</p> required <code>precise</code> <code>bool</code> <p>If True, returns precise integer output. Default True.</p> <code>True</code> <code>fee_on_input</code> <code>bool</code> <p>If True, applies the fee to the input amount.                         If False, applies the fee to the output amount.                         Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[Assets, float]</code> <p>tuple[Assets, float]: A tuple containing: - The output asset amount after the swap. - A float value (always 0 in this implementation).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input asset is invalid or if multiple input assets are provided.</p> Source code in <code>src/charli3_dendrite/dexs/amm/amm_types.py</code> <pre><code>def get_amount_out(\n    self,\n    asset: Assets,\n    precise: bool = True,\n    fee_on_input: bool = True,\n) -&gt; tuple[Assets, float]:\n    \"\"\"Calculate the amount of assets received when swapping a given input amount.\n\n    This function computes the output amount for a swap operation in the\n    stable swap pool, taking into account the volume fee and precision settings.\n\n    Args:\n        asset (Assets): The input asset amount for the swap.\n        precise (bool): If True, returns precise integer output. Default True.\n        fee_on_input (bool): If True, applies the fee to the input amount.\n                                    If False, applies the fee to the output amount.\n                                    Defaults to True.\n\n    Returns:\n        tuple[Assets, float]: A tuple containing:\n            - The output asset amount after the swap.\n            - A float value (always 0 in this implementation).\n\n    Raises:\n        ValueError: If the input asset is invalid or if multiple input\n          assets are provided.\n    \"\"\"\n    volume_fee: int = 0\n    if self.volume_fee is not None:\n        if isinstance(self.volume_fee, (int, float)):\n            volume_fee = self.volume_fee\n        elif asset.unit() == self.unit_a:\n            volume_fee = self.volume_fee[0]\n        else:\n            volume_fee = self.volume_fee[1]\n\n    if fee_on_input:\n        in_asset = Assets(\n            **{\n                asset.unit(): int(\n                    asset.quantity() * (10000 - volume_fee) / 10000,\n                ),\n            },\n        )\n    else:\n        in_asset = asset\n    out_unit = self.unit_a if asset.unit() == self.unit_b else self.unit_b\n    out_asset = self._get_y(in_asset, out_unit, precise=precise)\n    out_reserve = (\n        self.reserve_b / self.asset_mulitipliers[1]\n        if out_unit == self.unit_b\n        else self.reserve_a / self.asset_mulitipliers[0]\n    )\n\n    out_asset.root[out_asset.unit()] = int(out_reserve - out_asset.quantity())\n    if not fee_on_input:\n        out_asset.root[out_asset.unit()] = int(\n            out_asset.quantity() * (10000 - volume_fee) / 10000,\n        )\n    if precise:\n        out_asset.root[out_asset.unit()] = int(out_asset.quantity())\n\n    return out_asset, 0\n</code></pre>"},{"location":"utils/","title":"Utils","text":"<p>This module contains methods that are backend independent.</p>"},{"location":"utils/#charli3_dendrite.backend.utils.get_token_from_registry","title":"<code>get_token_from_registry(asset: str) -&gt; TokenInfo | None</code>","text":"<p>Get token from the Cardano Token Registry.</p> <p>Parameters:</p> Name Type Description Default <code>asset</code> <code>str</code> <p>The policy + name of the asset.</p> required <p>Returns:</p> Type Description <code>TokenInfo | None</code> <p>Either the token information if the asset exists, or None if it doesn't.</p> Source code in <code>src/charli3_dendrite/backend/utils.py</code> <pre><code>def get_token_from_registry(asset: str) -&gt; TokenInfo | None:\n    \"\"\"Get token from the Cardano Token Registry.\n\n    Args:\n        asset: The policy + name of the asset.\n\n    Returns:\n        Either the token information if the asset exists, or None if it doesn't.\n    \"\"\"\n    response = requests.get(\n        f\"https://raw.githubusercontent.com/cardano-foundation/cardano-token-registry/master/mappings/{asset}.json\",\n        timeout=15,\n    )\n\n    if response.status_code != requests.status_codes.codes.OK:\n        return None\n\n    response = response.json()\n\n    ticker = \"\" if \"ticker\" not in response else response[\"ticker\"][\"value\"]\n    if ticker == \"\":\n        ticker = bytes.fromhex(asset[56:]).decode(encoding=\"latin_1\")\n    name = \"\" if \"name\" not in response else response[\"name\"][\"value\"]\n    policy_id = asset[:56]\n    policy_name = asset[56:]\n    decimals = 0 if \"decimals\" not in response else response[\"decimals\"][\"value\"]\n    logo = \"\" if \"logo\" not in response else response[\"logo\"][\"value\"]\n    return TokenInfo(\n        ticker=ticker,\n        name=name,\n        policy_id=policy_id,\n        policy_name=policy_name,\n        decimals=decimals,\n        logo=logo,\n    )\n</code></pre>"},{"location":"vyfi/","title":"Vyfi","text":"<p>VyFi DEX Module.</p>"},{"location":"vyfi/#charli3_dendrite.dexs.amm.vyfi.AtoB","title":"<code>AtoB</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>A to B swap direction.</p> Source code in <code>src/charli3_dendrite/dexs/amm/vyfi.py</code> <pre><code>@dataclass\nclass AtoB(PlutusData):\n    \"\"\"A to B swap direction.\"\"\"\n\n    CONSTR_ID = 3\n    min_receive: int\n</code></pre>"},{"location":"vyfi/#charli3_dendrite.dexs.amm.vyfi.BtoA","title":"<code>BtoA</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>B to A swap direction.</p> Source code in <code>src/charli3_dendrite/dexs/amm/vyfi.py</code> <pre><code>@dataclass\nclass BtoA(PlutusData):\n    \"\"\"B to A swap direction.\"\"\"\n\n    CONSTR_ID = 4\n    min_receive: int\n</code></pre>"},{"location":"vyfi/#charli3_dendrite.dexs.amm.vyfi.Deposit","title":"<code>Deposit</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Deposit assets into the pool.</p> Source code in <code>src/charli3_dendrite/dexs/amm/vyfi.py</code> <pre><code>@dataclass\nclass Deposit(PlutusData):\n    \"\"\"Deposit assets into the pool.\"\"\"\n\n    CONSTR_ID = 0\n    min_lp_receive: int\n</code></pre>"},{"location":"vyfi/#charli3_dendrite.dexs.amm.vyfi.LPFlushA","title":"<code>LPFlushA</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Flush LP tokens from A.</p> Source code in <code>src/charli3_dendrite/dexs/amm/vyfi.py</code> <pre><code>@dataclass\nclass LPFlushA(PlutusData):\n    \"\"\"Flush LP tokens from A.\"\"\"\n\n    CONSTR_ID = 2\n</code></pre>"},{"location":"vyfi/#charli3_dendrite.dexs.amm.vyfi.VyFiCPPState","title":"<code>VyFiCPPState</code>","text":"<p>               Bases: <code>AbstractConstantProductPoolState</code></p> <p>VyFi CPP state.</p> Source code in <code>src/charli3_dendrite/dexs/amm/vyfi.py</code> <pre><code>class VyFiCPPState(AbstractConstantProductPoolState):\n    \"\"\"VyFi CPP state.\"\"\"\n\n    _batcher = Assets(lovelace=1900000)\n    _deposit = Assets(lovelace=2000000)\n    _pools: ClassVar[dict[str, VyFiPoolDefinition] | None] = None\n    _pools_refresh: ClassVar[float] = time.time()\n    lp_fee: int = 0\n    bar_fee: int = 0\n\n    @classmethod\n    def dex(cls) -&gt; str:\n        return \"VyFi\"\n\n    @classmethod\n    @property\n    def pools(cls) -&gt; dict[str, VyFiPoolDefinition]:\n        \"\"\"Get the pools.\"\"\"\n        if cls._pools is None or (time.time() - cls._pools_refresh) &gt; 3600:\n            cls._pools = {}\n            for p in requests.get(\"https://api.vyfi.io/lp?networkId=1&amp;v2=true\").json():\n                p[\"json\"] = json.loads(p[\"json\"])\n                cls._pools[\n                    p[\"json\"][\"mainNFT\"][\"currencySymbol\"]\n                ] = VyFiPoolDefinition.model_validate(p)\n            cls._pools_refresh = time.time()\n\n        return cls._pools\n\n    @classmethod\n    def order_selector(cls) -&gt; list[str]:\n        return [p.orderValidatorUtxoAddress for p in cls.pools.values()]\n\n    @classmethod\n    def pool_selector(cls) -&gt; PoolSelector:\n        return PoolSelector(\n            addresses=[pool.poolValidatorUtxoAddress for pool in cls.pools.values()],\n        )\n\n    @property\n    def swap_forward(self) -&gt; bool:\n        return False\n\n    @property\n    def stake_address(self) -&gt; Address:\n        return Address.from_primitive(\n            VyFiCPPState.pools[self.pool_id].orderValidatorUtxoAddress,\n        )\n\n    @classmethod\n    def order_datum_class(self) -&gt; type[VyFiOrderDatum]:\n        return VyFiOrderDatum\n\n    @classmethod\n    def pool_datum_class(cls) -&gt; type[VyFiPoolDatum]:\n        return VyFiPoolDatum\n\n    @property\n    def pool_id(self) -&gt; str:\n        \"\"\"A unique identifier for the pool.\"\"\"\n        return self.pool_nft.unit()\n\n    @property\n    def volume_fee(self) -&gt; int:\n        return self.lp_fee + self.bar_fee\n\n    @classmethod\n    def extract_pool_nft(cls, values: dict[str, Any]) -&gt; Optional[Assets]:\n        \"\"\"Extract the dex nft from the UTXO.\n\n        Some DEXs put a DEX nft into the pool UTXO.\n\n        This function checks to see if the DEX nft is in the UTXO if the DEX policy is\n        defined.\n\n        If the dex nft is in the values, this value is skipped because it is assumed\n        that this utxo has already been parsed.\n\n        Args:\n            values: The pool UTXO inputs.\n\n        Returns:\n            Assets: None or the dex nft.\n        \"\"\"\n        assets = values[\"assets\"]\n\n        # If the dex nft is in the values, it's been parsed already\n        if \"pool_nft\" in values:\n            assert any([p in cls.pools for p in values[\"pool_nft\"]])\n            if isinstance(values[\"pool_nft\"], dict):\n                pool_nft = Assets(root=values[\"pool_nft\"])\n            else:\n                pool_nft = values[\"pool_nft\"]\n\n        # Check for the dex nft\n        else:\n            nfts = [asset for asset, quantity in assets.items() if asset in cls.pools]\n            if len(nfts) &lt; 1:\n                if len(assets) == 0:\n                    raise NoAssetsError(\n                        f\"{cls.__name__}: No assets supplied.\",\n                    )\n                else:\n                    raise NotAPoolError(\n                        f\"{cls.__name__}: Pool must have one DEX NFT token.\",\n                    )\n            pool_nft = Assets(**{nfts[0]: assets.root.pop(nfts[0])})\n            values[\"pool_nft\"] = pool_nft\n\n        values[\"lp_fee\"] = cls.pools[pool_nft.unit()].json_.feesSettings.liqFee\n        values[\"bar_fee\"] = cls.pools[pool_nft.unit()].json_.feesSettings.barFee\n\n        return pool_nft\n\n    @classmethod\n    def post_init(cls, values):\n        super().post_init(values)\n\n        assets = values[\"assets\"]\n        datum = VyFiPoolDatum.from_cbor(values[\"datum_cbor\"])\n\n        assets.root[assets.unit(0)] -= datum.token_a_fees\n        assets.root[assets.unit(1)] -= datum.token_b_fees\n</code></pre>"},{"location":"vyfi/#charli3_dendrite.dexs.amm.vyfi.VyFiCPPState.pool_id","title":"<code>pool_id: str</code>  <code>property</code>","text":"<p>A unique identifier for the pool.</p>"},{"location":"vyfi/#charli3_dendrite.dexs.amm.vyfi.VyFiCPPState.pools","title":"<code>pools: dict[str, VyFiPoolDefinition]</code>  <code>classmethod</code> <code>property</code>","text":"<p>Get the pools.</p>"},{"location":"vyfi/#charli3_dendrite.dexs.amm.vyfi.VyFiCPPState.extract_pool_nft","title":"<code>extract_pool_nft(values: dict[str, Any]) -&gt; Optional[Assets]</code>  <code>classmethod</code>","text":"<p>Extract the dex nft from the UTXO.</p> <p>Some DEXs put a DEX nft into the pool UTXO.</p> <p>This function checks to see if the DEX nft is in the UTXO if the DEX policy is defined.</p> <p>If the dex nft is in the values, this value is skipped because it is assumed that this utxo has already been parsed.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>dict[str, Any]</code> <p>The pool UTXO inputs.</p> required <p>Returns:</p> Name Type Description <code>Assets</code> <code>Optional[Assets]</code> <p>None or the dex nft.</p> Source code in <code>src/charli3_dendrite/dexs/amm/vyfi.py</code> <pre><code>@classmethod\ndef extract_pool_nft(cls, values: dict[str, Any]) -&gt; Optional[Assets]:\n    \"\"\"Extract the dex nft from the UTXO.\n\n    Some DEXs put a DEX nft into the pool UTXO.\n\n    This function checks to see if the DEX nft is in the UTXO if the DEX policy is\n    defined.\n\n    If the dex nft is in the values, this value is skipped because it is assumed\n    that this utxo has already been parsed.\n\n    Args:\n        values: The pool UTXO inputs.\n\n    Returns:\n        Assets: None or the dex nft.\n    \"\"\"\n    assets = values[\"assets\"]\n\n    # If the dex nft is in the values, it's been parsed already\n    if \"pool_nft\" in values:\n        assert any([p in cls.pools for p in values[\"pool_nft\"]])\n        if isinstance(values[\"pool_nft\"], dict):\n            pool_nft = Assets(root=values[\"pool_nft\"])\n        else:\n            pool_nft = values[\"pool_nft\"]\n\n    # Check for the dex nft\n    else:\n        nfts = [asset for asset, quantity in assets.items() if asset in cls.pools]\n        if len(nfts) &lt; 1:\n            if len(assets) == 0:\n                raise NoAssetsError(\n                    f\"{cls.__name__}: No assets supplied.\",\n                )\n            else:\n                raise NotAPoolError(\n                    f\"{cls.__name__}: Pool must have one DEX NFT token.\",\n                )\n        pool_nft = Assets(**{nfts[0]: assets.root.pop(nfts[0])})\n        values[\"pool_nft\"] = pool_nft\n\n    values[\"lp_fee\"] = cls.pools[pool_nft.unit()].json_.feesSettings.liqFee\n    values[\"bar_fee\"] = cls.pools[pool_nft.unit()].json_.feesSettings.barFee\n\n    return pool_nft\n</code></pre>"},{"location":"vyfi/#charli3_dendrite.dexs.amm.vyfi.VyFiFees","title":"<code>VyFiFees</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>VyFi fees.</p> Source code in <code>src/charli3_dendrite/dexs/amm/vyfi.py</code> <pre><code>class VyFiFees(BaseModel):\n    \"\"\"VyFi fees.\"\"\"\n\n    barFee: int\n    processFee: int\n    liqFee: int\n</code></pre>"},{"location":"vyfi/#charli3_dendrite.dexs.amm.vyfi.VyFiOrderDatum","title":"<code>VyFiOrderDatum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OrderDatum</code></p> <p>VyFi order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/vyfi.py</code> <pre><code>@dataclass\nclass VyFiOrderDatum(OrderDatum):\n    \"\"\"VyFi order datum.\"\"\"\n\n    address: bytes\n    order: Union[AtoB, BtoA, Deposit, LPFlushA, Withdraw, ZapInA, ZapInB]\n\n    @classmethod\n    def create_datum(\n        cls,\n        address_source: Address,\n        in_assets: Assets,\n        out_assets: Assets,\n        batcher_fee: Assets,\n        deposit: Assets,\n        address_target: Address | None = None,\n        datum_target: PlutusData | None = None,\n    ):\n        \"\"\"Create a new order datum.\"\"\"\n        address_hash = (\n            address_source.payment_part.to_primitive()\n            + address_source.staking_part.to_primitive()\n        )\n\n        merged = in_assets + out_assets\n        if in_assets.unit() == merged.unit():\n            order = AtoB(min_receive=out_assets.quantity())\n        else:\n            order = BtoA(min_receive=out_assets.quantity())\n\n        return cls(address=address_hash, order=order)\n\n    def address_source(self) -&gt; Address:\n        payment_part = VerificationKeyHash.from_primitive(self.address[:28])\n        if len(self.address) == 28:\n            staking_part = None\n        else:\n            staking_part = VerificationKeyHash.from_primitive(self.address[28:56])\n        return Address(payment_part=payment_part, staking_part=staking_part)\n\n    def requested_amount(self) -&gt; Assets:\n        if isinstance(self.order, BtoA):\n            return Assets({\"asset_a\": self.order.min_receive})\n        elif isinstance(self.order, AtoB):\n            return Assets({\"asset_b\": self.order.min_receive})\n        elif isinstance(self.order, (ZapInA, ZapInB, Deposit)):\n            return Assets({\"lp\": self.order.min_lp_receive})\n        elif isinstance(self.order, Withdraw):\n            return Assets(\n                {\n                    \"asset_a\": self.order.min_lp_receive.min_amount_a,\n                    \"asset_b\": self.order.min_lp_receive.min_amount_b,\n                },\n            )\n\n    def order_type(self) -&gt; OrderType | None:\n        order_type = None\n        if isinstance(self.order, (BtoA, AtoB, ZapInA, ZapInB)):\n            order_type = OrderType.swap\n        elif isinstance(self.order, Deposit):\n            order_type = OrderType.deposit\n        elif isinstance(self.order, Withdraw):\n            order_type = OrderType.withdraw\n\n        return order_type\n</code></pre>"},{"location":"vyfi/#charli3_dendrite.dexs.amm.vyfi.VyFiOrderDatum.create_datum","title":"<code>create_datum(address_source: Address, in_assets: Assets, out_assets: Assets, batcher_fee: Assets, deposit: Assets, address_target: Address | None = None, datum_target: PlutusData | None = None)</code>  <code>classmethod</code>","text":"<p>Create a new order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/vyfi.py</code> <pre><code>@classmethod\ndef create_datum(\n    cls,\n    address_source: Address,\n    in_assets: Assets,\n    out_assets: Assets,\n    batcher_fee: Assets,\n    deposit: Assets,\n    address_target: Address | None = None,\n    datum_target: PlutusData | None = None,\n):\n    \"\"\"Create a new order datum.\"\"\"\n    address_hash = (\n        address_source.payment_part.to_primitive()\n        + address_source.staking_part.to_primitive()\n    )\n\n    merged = in_assets + out_assets\n    if in_assets.unit() == merged.unit():\n        order = AtoB(min_receive=out_assets.quantity())\n    else:\n        order = BtoA(min_receive=out_assets.quantity())\n\n    return cls(address=address_hash, order=order)\n</code></pre>"},{"location":"vyfi/#charli3_dendrite.dexs.amm.vyfi.VyFiPoolDatum","title":"<code>VyFiPoolDatum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PoolDatum</code></p> <p>TODO: Figure out what each of these numbers mean.</p> Source code in <code>src/charli3_dendrite/dexs/amm/vyfi.py</code> <pre><code>@dataclass\nclass VyFiPoolDatum(PoolDatum):\n    \"\"\"TODO: Figure out what each of these numbers mean.\"\"\"\n\n    token_a_fees: int\n    token_b_fees: int\n    lp_tokens: int\n\n    def pool_pair(self) -&gt; Assets | None:\n        return None\n</code></pre>"},{"location":"vyfi/#charli3_dendrite.dexs.amm.vyfi.VyFiPoolDefinition","title":"<code>VyFiPoolDefinition</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>VyFi pool definition.</p> Source code in <code>src/charli3_dendrite/dexs/amm/vyfi.py</code> <pre><code>class VyFiPoolDefinition(BaseModel):\n    \"\"\"VyFi pool definition.\"\"\"\n\n    unitsPair: str\n    poolValidatorUtxoAddress: str\n    lpPolicyId_assetId: str = Field(alias=\"lpPolicyId-assetId\")\n    json_: VyFiPoolTokens = Field(alias=\"json\")\n    pair: str\n    isLive: bool\n    orderValidatorUtxoAddress: str\n</code></pre>"},{"location":"vyfi/#charli3_dendrite.dexs.amm.vyfi.VyFiPoolTokens","title":"<code>VyFiPoolTokens</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>VyFi pool tokens.</p> Source code in <code>src/charli3_dendrite/dexs/amm/vyfi.py</code> <pre><code>class VyFiPoolTokens(BaseModel):\n    \"\"\"VyFi pool tokens.\"\"\"\n\n    aAsset: VyFiTokenDefinition\n    bAsset: VyFiTokenDefinition\n    mainNFT: VyFiTokenDefinition\n    operatorToken: VyFiTokenDefinition\n    lpTokenName: dict[str, str]\n    feesSettings: VyFiFees\n    stakeKey: Optional[str]\n</code></pre>"},{"location":"vyfi/#charli3_dendrite.dexs.amm.vyfi.VyFiTokenDefinition","title":"<code>VyFiTokenDefinition</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>VyFi token definition.</p> Source code in <code>src/charli3_dendrite/dexs/amm/vyfi.py</code> <pre><code>class VyFiTokenDefinition(BaseModel):\n    \"\"\"VyFi token definition.\"\"\"\n\n    tokenName: str\n    currencySymbol: str\n</code></pre>"},{"location":"vyfi/#charli3_dendrite.dexs.amm.vyfi.Withdraw","title":"<code>Withdraw</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Withdraw assets from the pool.</p> Source code in <code>src/charli3_dendrite/dexs/amm/vyfi.py</code> <pre><code>@dataclass\nclass Withdraw(PlutusData):\n    \"\"\"Withdraw assets from the pool.\"\"\"\n\n    CONSTR_ID = 1\n    min_lp_receive: WithdrawPair\n</code></pre>"},{"location":"vyfi/#charli3_dendrite.dexs.amm.vyfi.WithdrawPair","title":"<code>WithdrawPair</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Withdraw pair of assets.</p> Source code in <code>src/charli3_dendrite/dexs/amm/vyfi.py</code> <pre><code>@dataclass\nclass WithdrawPair(PlutusData):\n    \"\"\"Withdraw pair of assets.\"\"\"\n\n    CONSTR_ID = 0\n    min_amount_a: int\n    min_amount_b: int\n</code></pre>"},{"location":"vyfi/#charli3_dendrite.dexs.amm.vyfi.ZapInA","title":"<code>ZapInA</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Zap in A.</p> Source code in <code>src/charli3_dendrite/dexs/amm/vyfi.py</code> <pre><code>@dataclass\nclass ZapInA(PlutusData):\n    \"\"\"Zap in A.\"\"\"\n\n    CONSTR_ID = 5\n    min_lp_receive: int\n</code></pre>"},{"location":"vyfi/#charli3_dendrite.dexs.amm.vyfi.ZapInB","title":"<code>ZapInB</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Zap in B.</p> Source code in <code>src/charli3_dendrite/dexs/amm/vyfi.py</code> <pre><code>@dataclass\nclass ZapInB(PlutusData):\n    \"\"\"Zap in B.\"\"\"\n\n    CONSTR_ID = 6\n    min_lp_receive: int\n</code></pre>"},{"location":"wingriders/","title":"Wingriders","text":"<p>WingRiders DEX Module.</p>"},{"location":"wingriders/#charli3_dendrite.dexs.amm.wingriders.AtoB","title":"<code>AtoB</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>A to B.</p> Source code in <code>src/charli3_dendrite/dexs/amm/wingriders.py</code> <pre><code>@dataclass\nclass AtoB(PlutusData):\n    \"\"\"A to B.\"\"\"\n\n    CONSTR_ID = 0\n</code></pre>"},{"location":"wingriders/#charli3_dendrite.dexs.amm.wingriders.BtoA","title":"<code>BtoA</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>B to A.</p> Source code in <code>src/charli3_dendrite/dexs/amm/wingriders.py</code> <pre><code>@dataclass\nclass BtoA(PlutusData):\n    \"\"\"B to A.\"\"\"\n\n    CONSTR_ID = 1\n</code></pre>"},{"location":"wingriders/#charli3_dendrite.dexs.amm.wingriders.LiquidityPool","title":"<code>LiquidityPool</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Encode a liquidity pool for the WingRiders DEX.</p> Source code in <code>src/charli3_dendrite/dexs/amm/wingriders.py</code> <pre><code>@dataclass\nclass LiquidityPool(PlutusData):\n    \"\"\"Encode a liquidity pool for the WingRiders DEX.\"\"\"\n\n    CONSTR_ID = 0\n    assets: LiquidityPoolAssets\n    last_swap: int\n    quantity_a: int\n    quantity_b: int\n</code></pre>"},{"location":"wingriders/#charli3_dendrite.dexs.amm.wingriders.LiquidityPoolAssets","title":"<code>LiquidityPoolAssets</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Encode a pair of assets for the WingRiders DEX.</p> Source code in <code>src/charli3_dendrite/dexs/amm/wingriders.py</code> <pre><code>@dataclass\nclass LiquidityPoolAssets(PlutusData):\n    \"\"\"Encode a pair of assets for the WingRiders DEX.\"\"\"\n\n    CONSTR_ID = 0\n    asset_a: AssetClass\n    asset_b: AssetClass\n</code></pre>"},{"location":"wingriders/#charli3_dendrite.dexs.amm.wingriders.RewardPlutusFullAddress","title":"<code>RewardPlutusFullAddress</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusFullAddress</code></p> <p>A full address, including payment and staking keys.</p> Source code in <code>src/charli3_dendrite/dexs/amm/wingriders.py</code> <pre><code>@dataclass\nclass RewardPlutusFullAddress(PlutusFullAddress):\n    \"\"\"A full address, including payment and staking keys.\"\"\"\n\n    CONSTR_ID = 0\n\n    payment: RewardPlutusPartAddress\n</code></pre>"},{"location":"wingriders/#charli3_dendrite.dexs.amm.wingriders.RewardPlutusPartAddress","title":"<code>RewardPlutusPartAddress</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Encode a plutus address part (i.e. payment, stake, etc).</p> Source code in <code>src/charli3_dendrite/dexs/amm/wingriders.py</code> <pre><code>@dataclass\nclass RewardPlutusPartAddress(PlutusData):\n    \"\"\"Encode a plutus address part (i.e. payment, stake, etc).\"\"\"\n\n    CONSTR_ID = 1\n    address: bytes\n</code></pre>"},{"location":"wingriders/#charli3_dendrite.dexs.amm.wingriders.WingRiderOrderConfig","title":"<code>WingRiderOrderConfig</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Configuration for a WingRiders order.</p> Source code in <code>src/charli3_dendrite/dexs/amm/wingriders.py</code> <pre><code>@dataclass\nclass WingRiderOrderConfig(PlutusData):\n    \"\"\"Configuration for a WingRiders order.\"\"\"\n\n    CONSTR_ID = 0\n\n    full_address: Union[PlutusFullAddress, RewardPlutusFullAddress]\n    address: bytes\n    expiration: int\n    assets: WingriderAssetClass\n\n    @classmethod\n    def create_config(\n        cls,\n        address: Address,\n        expiration: int,\n        in_assets: Assets,\n        out_assets: Assets,\n    ):\n        \"\"\"Create a WingRiders order configuration.\"\"\"\n        plutus_address = PlutusFullAddress.from_address(address)\n        assets = WingriderAssetClass.from_assets(\n            in_assets=in_assets,\n            out_assets=out_assets,\n        )\n\n        return cls(\n            full_address=plutus_address,\n            address=bytes.fromhex(str(address.payment_part)),\n            expiration=expiration,\n            assets=assets,\n        )\n</code></pre>"},{"location":"wingriders/#charli3_dendrite.dexs.amm.wingriders.WingRiderOrderConfig.create_config","title":"<code>create_config(address: Address, expiration: int, in_assets: Assets, out_assets: Assets)</code>  <code>classmethod</code>","text":"<p>Create a WingRiders order configuration.</p> Source code in <code>src/charli3_dendrite/dexs/amm/wingriders.py</code> <pre><code>@classmethod\ndef create_config(\n    cls,\n    address: Address,\n    expiration: int,\n    in_assets: Assets,\n    out_assets: Assets,\n):\n    \"\"\"Create a WingRiders order configuration.\"\"\"\n    plutus_address = PlutusFullAddress.from_address(address)\n    assets = WingriderAssetClass.from_assets(\n        in_assets=in_assets,\n        out_assets=out_assets,\n    )\n\n    return cls(\n        full_address=plutus_address,\n        address=bytes.fromhex(str(address.payment_part)),\n        expiration=expiration,\n        assets=assets,\n    )\n</code></pre>"},{"location":"wingriders/#charli3_dendrite.dexs.amm.wingriders.WingRidersCPPState","title":"<code>WingRidersCPPState</code>","text":"<p>               Bases: <code>AbstractConstantProductPoolState</code></p> <p>WingRiders CPP state.</p> Source code in <code>src/charli3_dendrite/dexs/amm/wingriders.py</code> <pre><code>class WingRidersCPPState(AbstractConstantProductPoolState):\n    \"\"\"WingRiders CPP state.\"\"\"\n\n    fee: int = 35\n    _batcher = Assets(lovelace=2000000)\n    _deposit = Assets(lovelace=2000000)\n    _stake_address: ClassVar[Address] = Address.from_primitive(\n        \"addr1wxr2a8htmzuhj39y2gq7ftkpxv98y2g67tg8zezthgq4jkg0a4ul4\",\n    )\n\n    @classmethod\n    def dex(cls) -&gt; str:\n        return \"WingRiders\"\n\n    @classmethod\n    def order_selector(self) -&gt; list[str]:\n        return [self._stake_address.encode()]\n\n    @classmethod\n    def pool_selector(cls) -&gt; PoolSelector:\n        return PoolSelector(\n            addresses=[\n                \"addr1w8nvjzjeydcn4atcd93aac8allvrpjn7pjr2qsweukpnayghhwcpj\",\n                \"addr1wxvx34v0hlxzk9x0clv7as9hvhn7dlzwj5xfcf6g4n5uucg4tkd7w\",\n            ],\n            assets=cls.dex_policy(),\n        )\n\n    @property\n    def swap_forward(self) -&gt; bool:\n        return False\n\n    @property\n    def stake_address(self) -&gt; Address:\n        return self._stake_address\n\n    @classmethod\n    def order_datum_class(self) -&gt; type[WingRidersOrderDatum]:\n        return WingRidersOrderDatum\n\n    @classmethod\n    def pool_datum_class(self) -&gt; type[WingRidersPoolDatum]:\n        return WingRidersPoolDatum\n\n    @classmethod\n    def pool_policy(cls) -&gt; str:\n        return [\"026a18d04a0c642759bb3d83b12e3344894e5c1c7b2aeb1a2113a570\"]\n\n    @classmethod\n    def dex_policy(cls) -&gt; str:\n        return [\"026a18d04a0c642759bb3d83b12e3344894e5c1c7b2aeb1a2113a5704c\"]\n\n    @property\n    def pool_id(self) -&gt; str:\n        \"\"\"A unique identifier for the pool.\"\"\"\n        return self.pool_nft.unit()\n\n    @classmethod\n    def skip_init(cls, values) -&gt; bool:\n        if \"pool_nft\" in values and \"dex_nft\" in values:\n            if cls.dex_policy()[0] not in values[\"dex_nft\"]:\n                raise NotAPoolError(\"Invalid DEX NFT\")\n            if len(values[\"assets\"]) == 3:\n                # Send the ADA token to the end\n                if isinstance(values[\"assets\"], Assets):\n                    values[\"assets\"].root[\"lovelace\"] = values[\"assets\"].root.pop(\n                        \"lovelace\",\n                    )\n                else:\n                    values[\"assets\"][\"lovelace\"] = values[\"assets\"].pop(\"lovelace\")\n            values[\"assets\"] = Assets.model_validate(values[\"assets\"])\n            return True\n        else:\n            return False\n\n    @classmethod\n    def post_init(cls, values):\n        super().post_init(values)\n\n        assets = values[\"assets\"]\n        datum = WingRidersPoolDatum.from_cbor(values[\"datum_cbor\"])\n\n        if len(assets) == 2:\n            assets.root[assets.unit(0)] -= 3000000\n\n        assets.root[assets.unit(0)] -= datum.datum.quantity_a\n        assets.root[assets.unit(1)] -= datum.datum.quantity_b\n\n    def deposit(\n        self,\n        in_assets: Assets | None = None,\n        out_assets: Assets | None = None,\n    ):\n        merged_assets = in_assets + out_assets\n        if \"lovelace\" in merged_assets:\n            return Assets(lovelace=4000000) - self.batcher_fee(\n                in_assets=in_assets,\n                out_assets=out_assets,\n            )\n        else:\n            return self._deposit\n\n    def batcher_fee(\n        self,\n        in_assets: Assets | None = None,\n        out_assets: Assets | None = None,\n        extra_assets: Assets | None = None,\n    ):\n        merged_assets = in_assets + out_assets\n        if \"lovelace\" in merged_assets:\n            if merged_assets[\"lovelace\"] &lt;= 250000000:\n                return Assets(lovelace=850000)\n            elif merged_assets[\"lovelace\"] &lt;= 500000000:\n                return Assets(lovelace=1500000)\n        return self._batcher\n</code></pre>"},{"location":"wingriders/#charli3_dendrite.dexs.amm.wingriders.WingRidersCPPState.pool_id","title":"<code>pool_id: str</code>  <code>property</code>","text":"<p>A unique identifier for the pool.</p>"},{"location":"wingriders/#charli3_dendrite.dexs.amm.wingriders.WingRidersDepositDetail","title":"<code>WingRidersDepositDetail</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>WingRiders deposit detail.</p> Source code in <code>src/charli3_dendrite/dexs/amm/wingriders.py</code> <pre><code>@dataclass\nclass WingRidersDepositDetail(PlutusData):\n    \"\"\"WingRiders deposit detail.\"\"\"\n\n    CONSTR_ID = 1\n\n    min_lp_receive: int\n</code></pre>"},{"location":"wingriders/#charli3_dendrite.dexs.amm.wingriders.WingRidersMaybeFeeClaimDetail","title":"<code>WingRidersMaybeFeeClaimDetail</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>WingRiders maybe fee claim detail.</p> Source code in <code>src/charli3_dendrite/dexs/amm/wingriders.py</code> <pre><code>@dataclass\nclass WingRidersMaybeFeeClaimDetail(PlutusData):\n    \"\"\"WingRiders maybe fee claim detail.\"\"\"\n\n    CONSTR_ID = 3\n</code></pre>"},{"location":"wingriders/#charli3_dendrite.dexs.amm.wingriders.WingRidersOrderDatum","title":"<code>WingRidersOrderDatum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OrderDatum</code></p> <p>WingRiders order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/wingriders.py</code> <pre><code>@dataclass\nclass WingRidersOrderDatum(OrderDatum):\n    \"\"\"WingRiders order datum.\"\"\"\n\n    config: WingRiderOrderConfig\n    detail: Union[\n        WingRidersDepositDetail,\n        WingRidersMaybeFeeClaimDetail,\n        WingRidersStakeRewardDetail,\n        WingRidersOrderDetail,\n        WingRidersWithdrawDetail,\n    ]\n\n    @classmethod\n    def create_datum(\n        cls,\n        address_source: Address,\n        in_assets: Assets,\n        out_assets: Assets,\n        batcher_fee: Assets,\n        deposit: Assets,\n        address_target: Address | None = None,\n        datum_target: PlutusData | None = None,\n    ):\n        \"\"\"Create a WingRiders order datum.\"\"\"\n        timeout = int(((datetime.utcnow() + timedelta(days=360)).timestamp()) * 1000)\n\n        config = WingRiderOrderConfig.create_config(\n            address=address_source,\n            expiration=timeout,\n            in_assets=in_assets,\n            out_assets=out_assets,\n        )\n        detail = WingRidersOrderDetail.from_assets(\n            in_assets=in_assets,\n            out_assets=out_assets,\n        )\n\n        return cls(config=config, detail=detail)\n\n    def address_source(self) -&gt; Address:\n        return self.config.full_address.to_address()\n\n    def requested_amount(self) -&gt; Assets:\n        if isinstance(self.detail, WingRidersDepositDetail):\n            return Assets({\"lp\": self.detail.min_lp_receive})\n        elif isinstance(self.detail, WingRidersOrderDetail):\n            if isinstance(self.detail.direction, BtoA):\n                return Assets(\n                    {self.config.assets.asset_a.assets.unit(): self.detail.min_receive},\n                )\n            else:\n                return Assets(\n                    {self.config.assets.asset_b.assets.unit(): self.detail.min_receive},\n                )\n        elif isinstance(self.detail, WingRidersWithdrawDetail):\n            return Assets(\n                {\n                    self.config.assets.asset_a.assets.unit(): self.detail.min_amount_a,\n                    self.config.assets.asset_b.assets.unit(): self.detail.min_amount_b,\n                },\n            )\n        elif isinstance(self.detail, WingRidersMaybeFeeClaimDetail):\n            return Assets({})\n\n    def order_type(self) -&gt; OrderType | None:\n        order_type = None\n        if isinstance(self.detail, WingRidersOrderDetail):\n            order_type = OrderType.swap\n        elif isinstance(self.detail, WingRidersDepositDetail):\n            order_type = OrderType.deposit\n        elif isinstance(self.detail, WingRidersWithdrawDetail):\n            order_type = OrderType.withdraw\n\n        return order_type\n</code></pre>"},{"location":"wingriders/#charli3_dendrite.dexs.amm.wingriders.WingRidersOrderDatum.create_datum","title":"<code>create_datum(address_source: Address, in_assets: Assets, out_assets: Assets, batcher_fee: Assets, deposit: Assets, address_target: Address | None = None, datum_target: PlutusData | None = None)</code>  <code>classmethod</code>","text":"<p>Create a WingRiders order datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/wingriders.py</code> <pre><code>@classmethod\ndef create_datum(\n    cls,\n    address_source: Address,\n    in_assets: Assets,\n    out_assets: Assets,\n    batcher_fee: Assets,\n    deposit: Assets,\n    address_target: Address | None = None,\n    datum_target: PlutusData | None = None,\n):\n    \"\"\"Create a WingRiders order datum.\"\"\"\n    timeout = int(((datetime.utcnow() + timedelta(days=360)).timestamp()) * 1000)\n\n    config = WingRiderOrderConfig.create_config(\n        address=address_source,\n        expiration=timeout,\n        in_assets=in_assets,\n        out_assets=out_assets,\n    )\n    detail = WingRidersOrderDetail.from_assets(\n        in_assets=in_assets,\n        out_assets=out_assets,\n    )\n\n    return cls(config=config, detail=detail)\n</code></pre>"},{"location":"wingriders/#charli3_dendrite.dexs.amm.wingriders.WingRidersOrderDetail","title":"<code>WingRidersOrderDetail</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>WingRiders order detail.</p> Source code in <code>src/charli3_dendrite/dexs/amm/wingriders.py</code> <pre><code>@dataclass\nclass WingRidersOrderDetail(PlutusData):\n    \"\"\"WingRiders order detail.\"\"\"\n\n    CONSTR_ID = 0\n\n    direction: Union[AtoB, BtoA]\n    min_receive: int\n\n    @classmethod\n    def from_assets(cls, in_assets: Assets, out_assets: Assets):\n        \"\"\"Create a WingRidersOrderDetail from a pair of assets.\"\"\"\n        merged = in_assets + out_assets\n        if in_assets.unit() == merged.unit():\n            return cls(direction=AtoB(), min_receive=out_assets.quantity())\n        else:\n            return cls(direction=BtoA(), min_receive=out_assets.quantity())\n</code></pre>"},{"location":"wingriders/#charli3_dendrite.dexs.amm.wingriders.WingRidersOrderDetail.from_assets","title":"<code>from_assets(in_assets: Assets, out_assets: Assets)</code>  <code>classmethod</code>","text":"<p>Create a WingRidersOrderDetail from a pair of assets.</p> Source code in <code>src/charli3_dendrite/dexs/amm/wingriders.py</code> <pre><code>@classmethod\ndef from_assets(cls, in_assets: Assets, out_assets: Assets):\n    \"\"\"Create a WingRidersOrderDetail from a pair of assets.\"\"\"\n    merged = in_assets + out_assets\n    if in_assets.unit() == merged.unit():\n        return cls(direction=AtoB(), min_receive=out_assets.quantity())\n    else:\n        return cls(direction=BtoA(), min_receive=out_assets.quantity())\n</code></pre>"},{"location":"wingriders/#charli3_dendrite.dexs.amm.wingriders.WingRidersPoolDatum","title":"<code>WingRidersPoolDatum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PoolDatum</code></p> <p>WingRiders pool datum.</p> Source code in <code>src/charli3_dendrite/dexs/amm/wingriders.py</code> <pre><code>@dataclass\nclass WingRidersPoolDatum(PoolDatum):\n    \"\"\"WingRiders pool datum.\"\"\"\n\n    lp_hash: bytes\n    datum: LiquidityPool\n\n    def pool_pair(self) -&gt; Assets | None:\n        return self.datum.assets.asset_a.assets + self.datum.assets.asset_b.assets\n</code></pre>"},{"location":"wingriders/#charli3_dendrite.dexs.amm.wingriders.WingRidersSSPState","title":"<code>WingRidersSSPState</code>","text":"<p>               Bases: <code>AbstractStableSwapPoolState</code>, <code>WingRidersCPPState</code></p> <p>WingRiders SSP state.</p> Source code in <code>src/charli3_dendrite/dexs/amm/wingriders.py</code> <pre><code>class WingRidersSSPState(AbstractStableSwapPoolState, WingRidersCPPState):\n    \"\"\"WingRiders SSP state.\"\"\"\n\n    fee: int = 6\n    _batcher = Assets(lovelace=1500000)\n    _deposit = Assets(lovelace=2000000)\n    _stake_address = Address.from_primitive(\n        \"addr1w8z7qwzszt2lqy93m3atg2axx22yq5k7yvs9rmrvuwlawts2wzadz\",\n    )\n\n    @classmethod\n    def pool_policy(cls) -&gt; str:\n        return [\"980e8c567670d34d4ec13a0c3b6de6199f260ae5dc9dc9e867bc5c93\"]\n\n    @classmethod\n    def dex_policy(cls) -&gt; str:\n        return [\"980e8c567670d34d4ec13a0c3b6de6199f260ae5dc9dc9e867bc5c934c\"]\n</code></pre>"},{"location":"wingriders/#charli3_dendrite.dexs.amm.wingriders.WingRidersStakeRewardDetail","title":"<code>WingRidersStakeRewardDetail</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>WingRiders stake reward detail.</p> Source code in <code>src/charli3_dendrite/dexs/amm/wingriders.py</code> <pre><code>@dataclass\nclass WingRidersStakeRewardDetail(PlutusData):\n    \"\"\"WingRiders stake reward detail.\"\"\"\n\n    CONSTR_ID = 4\n</code></pre>"},{"location":"wingriders/#charli3_dendrite.dexs.amm.wingriders.WingRidersWithdrawDetail","title":"<code>WingRidersWithdrawDetail</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>WingRiders withdraw detail.</p> Source code in <code>src/charli3_dendrite/dexs/amm/wingriders.py</code> <pre><code>@dataclass\nclass WingRidersWithdrawDetail(PlutusData):\n    \"\"\"WingRiders withdraw detail.\"\"\"\n\n    CONSTR_ID = 2\n\n    min_amount_a: int\n    min_amount_b: int\n</code></pre>"},{"location":"wingriders/#charli3_dendrite.dexs.amm.wingriders.WingriderAssetClass","title":"<code>WingriderAssetClass</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlutusData</code></p> <p>Encode a pair of assets for the WingRiders DEX.</p> Source code in <code>src/charli3_dendrite/dexs/amm/wingriders.py</code> <pre><code>@dataclass\nclass WingriderAssetClass(PlutusData):\n    \"\"\"Encode a pair of assets for the WingRiders DEX.\"\"\"\n\n    CONSTR_ID = 0\n\n    asset_a: AssetClass\n    asset_b: AssetClass\n\n    @classmethod\n    def from_assets(cls, in_assets: Assets, out_assets: Assets):\n        \"\"\"Create a WingRiderAssetClass from a pair of assets.\"\"\"\n        merged = in_assets + out_assets\n        if in_assets.unit() == merged.unit():\n            return cls(\n                asset_a=AssetClass.from_assets(in_assets),\n                asset_b=AssetClass.from_assets(out_assets),\n            )\n        else:\n            return cls(\n                asset_a=AssetClass.from_assets(out_assets),\n                asset_b=AssetClass.from_assets(in_assets),\n            )\n</code></pre>"},{"location":"wingriders/#charli3_dendrite.dexs.amm.wingriders.WingriderAssetClass.from_assets","title":"<code>from_assets(in_assets: Assets, out_assets: Assets)</code>  <code>classmethod</code>","text":"<p>Create a WingRiderAssetClass from a pair of assets.</p> Source code in <code>src/charli3_dendrite/dexs/amm/wingriders.py</code> <pre><code>@classmethod\ndef from_assets(cls, in_assets: Assets, out_assets: Assets):\n    \"\"\"Create a WingRiderAssetClass from a pair of assets.\"\"\"\n    merged = in_assets + out_assets\n    if in_assets.unit() == merged.unit():\n        return cls(\n            asset_a=AssetClass.from_assets(in_assets),\n            asset_b=AssetClass.from_assets(out_assets),\n        )\n    else:\n        return cls(\n            asset_a=AssetClass.from_assets(out_assets),\n            asset_b=AssetClass.from_assets(in_assets),\n        )\n</code></pre>"}]}